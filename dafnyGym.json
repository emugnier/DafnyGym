[
    {
        "benchmark_name": "libraries",
        "index": "30",
        "method_filepath": "./src/JSON/ZeroCopy/Serializer.dfy",
        "method_without_assertion_filename": "MembersImpl_fix_30.dfy",
        "method_name": "MembersImpl",
        "method_content": "  method MembersImpl(obj: jobject, writer: Writer) returns (wr: Writer)\n    decreases obj, 1\n    ensures wr == MembersSpec(obj, obj.data, writer)\n  {\n    wr := writer;\n    var members := obj.data;\n    assert wr == MembersSpec(obj, members[..0], writer);\n    for i := 0 to |members| // FIXME uint32\n      invariant wr == MembersSpec(obj, members[..i], writer)\n    {\n      assert members[..i+1][..i] == members[..i];\n      wr := Member(obj, members[i], wr);\n    }\n    assert members[..|members|] == members;\n    assert wr == MembersSpec(obj, members, writer);\n  }\n",
        "method_without_assertion_content": "  method MembersImpl(obj: jobject, writer: Writer) returns (wr: Writer)\n    decreases obj, 1\n    ensures wr == MembersSpec(obj, obj.data, writer)\n  {\n    wr := writer;\n    var members := obj.data;\n        for i := 0 to |members| // FIXME uint32\n      invariant wr == MembersSpec(obj, members[..i], writer)\n    {\n      assert members[..i+1][..i] == members[..i];\n      wr := Member(obj, members[i], wr);\n    }\n    assert members[..|members|] == members;\n    assert wr == MembersSpec(obj, members, writer);\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "31",
        "method_filepath": "./src/JSON/ZeroCopy/Serializer.dfy",
        "method_without_assertion_filename": "MembersImpl_fix_31.dfy",
        "method_name": "MembersImpl",
        "method_content": "  method MembersImpl(obj: jobject, writer: Writer) returns (wr: Writer)\n    decreases obj, 1\n    ensures wr == MembersSpec(obj, obj.data, writer)\n  {\n    wr := writer;\n    var members := obj.data;\n    assert wr == MembersSpec(obj, members[..0], writer);\n    for i := 0 to |members| // FIXME uint32\n      invariant wr == MembersSpec(obj, members[..i], writer)\n    {\n      assert members[..i+1][..i] == members[..i];\n      wr := Member(obj, members[i], wr);\n    }\n    assert members[..|members|] == members;\n    assert wr == MembersSpec(obj, members, writer);\n  }\n",
        "method_without_assertion_content": "  method MembersImpl(obj: jobject, writer: Writer) returns (wr: Writer)\n    decreases obj, 1\n    ensures wr == MembersSpec(obj, obj.data, writer)\n  {\n    wr := writer;\n    var members := obj.data;\n    assert wr == MembersSpec(obj, members[..0], writer);\n    for i := 0 to |members| // FIXME uint32\n      invariant wr == MembersSpec(obj, members[..i], writer)\n    {\n            wr := Member(obj, members[i], wr);\n    }\n    assert members[..|members|] == members;\n    assert wr == MembersSpec(obj, members, writer);\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "32",
        "method_filepath": "./src/JSON/ZeroCopy/Serializer.dfy",
        "method_without_assertion_filename": "MembersImpl_fix_32.dfy",
        "method_name": "MembersImpl",
        "method_content": "  method MembersImpl(obj: jobject, writer: Writer) returns (wr: Writer)\n    decreases obj, 1\n    ensures wr == MembersSpec(obj, obj.data, writer)\n  {\n    wr := writer;\n    var members := obj.data;\n    assert wr == MembersSpec(obj, members[..0], writer);\n    for i := 0 to |members| // FIXME uint32\n      invariant wr == MembersSpec(obj, members[..i], writer)\n    {\n      assert members[..i+1][..i] == members[..i];\n      wr := Member(obj, members[i], wr);\n    }\n    assert members[..|members|] == members;\n    assert wr == MembersSpec(obj, members, writer);\n  }\n",
        "method_without_assertion_content": "  method MembersImpl(obj: jobject, writer: Writer) returns (wr: Writer)\n    decreases obj, 1\n    ensures wr == MembersSpec(obj, obj.data, writer)\n  {\n    wr := writer;\n    var members := obj.data;\n    assert wr == MembersSpec(obj, members[..0], writer);\n    for i := 0 to |members| // FIXME uint32\n      invariant wr == MembersSpec(obj, members[..i], writer)\n    {\n      assert members[..i+1][..i] == members[..i];\n      wr := Member(obj, members[i], wr);\n    }\n        assert wr == MembersSpec(obj, members, writer);\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "39",
        "method_filepath": "./src/Collections/Sets/Sets.dfy",
        "method_without_assertion_filename": "LemmaIsSingleton_fix_39.dfy",
        "method_name": "LemmaIsSingleton",
        "method_content": "  lemma LemmaIsSingleton<T>(s: set<T>)\n    ensures |s| == 1 <==> IsSingleton(s)\n  {\n    if |s| == 1 {\n      forall x, y | x in s && y in s ensures x == y {\n        LemmaSingletonEquality(s, x, y);\n      }\n    }\n    if IsSingleton(s) {\n      var x :| x in s;\n      assert s == {x};\n      assert |s| == 1;\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LemmaIsSingleton<T>(s: set<T>)\n    ensures |s| == 1 <==> IsSingleton(s)\n  {\n    if |s| == 1 {\n      forall x, y | x in s && y in s ensures x == y {\n        LemmaSingletonEquality(s, x, y);\n      }\n    }\n    if IsSingleton(s) {\n      var x :| x in s;\n            assert |s| == 1;\n    }\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "42",
        "method_filepath": "./src/Collections/Sets/Sets.dfy",
        "method_without_assertion_filename": "LemmaUnionSize_fix_42.dfy",
        "method_name": "LemmaUnionSize",
        "method_content": "  lemma LemmaUnionSize<X>(xs: set<X>, ys: set<X>)\n    ensures |xs + ys| >= |xs|\n    ensures |xs + ys| >= |ys|\n  {\n    if ys == {} {\n    } else {\n      var y :| y in ys;\n      if y in xs {\n        var xr := xs - {y};\n        var yr := ys - {y};\n        assert xr + yr == xs + ys - {y};\n        LemmaUnionSize(xr, yr);\n      } else {\n        var yr := ys - {y};\n        assert xs + yr == xs + ys - {y};\n        LemmaUnionSize(xs, yr);\n      }\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LemmaUnionSize<X>(xs: set<X>, ys: set<X>)\n    ensures |xs + ys| >= |xs|\n    ensures |xs + ys| >= |ys|\n  {\n    if ys == {} {\n    } else {\n      var y :| y in ys;\n      if y in xs {\n        var xr := xs - {y};\n        var yr := ys - {y};\n                LemmaUnionSize(xr, yr);\n      } else {\n        var yr := ys - {y};\n        assert xs + yr == xs + ys - {y};\n        LemmaUnionSize(xs, yr);\n      }\n    }\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "43",
        "method_filepath": "./src/Collections/Sets/Sets.dfy",
        "method_without_assertion_filename": "LemmaUnionSize_fix_43.dfy",
        "method_name": "LemmaUnionSize",
        "method_content": "  lemma LemmaUnionSize<X>(xs: set<X>, ys: set<X>)\n    ensures |xs + ys| >= |xs|\n    ensures |xs + ys| >= |ys|\n  {\n    if ys == {} {\n    } else {\n      var y :| y in ys;\n      if y in xs {\n        var xr := xs - {y};\n        var yr := ys - {y};\n        assert xr + yr == xs + ys - {y};\n        LemmaUnionSize(xr, yr);\n      } else {\n        var yr := ys - {y};\n        assert xs + yr == xs + ys - {y};\n        LemmaUnionSize(xs, yr);\n      }\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LemmaUnionSize<X>(xs: set<X>, ys: set<X>)\n    ensures |xs + ys| >= |xs|\n    ensures |xs + ys| >= |ys|\n  {\n    if ys == {} {\n    } else {\n      var y :| y in ys;\n      if y in xs {\n        var xr := xs - {y};\n        var yr := ys - {y};\n        assert xr + yr == xs + ys - {y};\n        LemmaUnionSize(xr, yr);\n      } else {\n        var yr := ys - {y};\n                LemmaUnionSize(xs, yr);\n      }\n    }\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "45",
        "method_filepath": "./src/Collections/Sequences/LittleEndianNat.dfy",
        "method_without_assertion_filename": "LemmaSeqNeq_fix_45.dfy",
        "method_name": "LemmaSeqNeq",
        "method_content": "  lemma LemmaSeqNeq(xs: seq<uint>, ys: seq<uint>)\n    requires |xs| == |ys|\n    requires xs != ys\n    ensures ToNatRight(xs) != ToNatRight(ys)\n  {\n    ghost var i: nat, n: nat := 0, |xs|;\n\n    while i < n\n      invariant 0 <= i < n\n      invariant xs[..i] == ys[..i]\n    {\n      if xs[i] != ys[i] {\n        break;\n      }\n      i := i + 1;\n    }\n    assert ToNatLeft(xs[..i]) == ToNatLeft(ys[..i]);\n\n    reveal ToNatLeft();\n    assert xs[..i+1][..i] == xs[..i];\n    assert ys[..i+1][..i] == ys[..i];\n    LemmaPowPositiveAuto();\n    LemmaMulStrictInequalityAuto();\n    assert ToNatLeft(xs[..i+1]) != ToNatLeft(ys[..i+1]);\n    LemmaToNatLeftEqToNatRightAuto();\n\n    LemmaSeqPrefixNeq(xs, ys, i+1);\n  }\n",
        "method_without_assertion_content": "  lemma LemmaSeqNeq(xs: seq<uint>, ys: seq<uint>)\n    requires |xs| == |ys|\n    requires xs != ys\n    ensures ToNatRight(xs) != ToNatRight(ys)\n  {\n    ghost var i: nat, n: nat := 0, |xs|;\n\n    while i < n\n      invariant 0 <= i < n\n      invariant xs[..i] == ys[..i]\n    {\n      if xs[i] != ys[i] {\n        break;\n      }\n      i := i + 1;\n    }\n    assert ToNatLeft(xs[..i]) == ToNatLeft(ys[..i]);\n\n    reveal ToNatLeft();\n        assert ys[..i+1][..i] == ys[..i];\n    LemmaPowPositiveAuto();\n    LemmaMulStrictInequalityAuto();\n    assert ToNatLeft(xs[..i+1]) != ToNatLeft(ys[..i+1]);\n    LemmaToNatLeftEqToNatRightAuto();\n\n    LemmaSeqPrefixNeq(xs, ys, i+1);\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "46",
        "method_filepath": "./src/Collections/Sequences/LittleEndianNat.dfy",
        "method_without_assertion_filename": "LemmaSeqNeq_fix_46.dfy",
        "method_name": "LemmaSeqNeq",
        "method_content": "  lemma LemmaSeqNeq(xs: seq<uint>, ys: seq<uint>)\n    requires |xs| == |ys|\n    requires xs != ys\n    ensures ToNatRight(xs) != ToNatRight(ys)\n  {\n    ghost var i: nat, n: nat := 0, |xs|;\n\n    while i < n\n      invariant 0 <= i < n\n      invariant xs[..i] == ys[..i]\n    {\n      if xs[i] != ys[i] {\n        break;\n      }\n      i := i + 1;\n    }\n    assert ToNatLeft(xs[..i]) == ToNatLeft(ys[..i]);\n\n    reveal ToNatLeft();\n    assert xs[..i+1][..i] == xs[..i];\n    assert ys[..i+1][..i] == ys[..i];\n    LemmaPowPositiveAuto();\n    LemmaMulStrictInequalityAuto();\n    assert ToNatLeft(xs[..i+1]) != ToNatLeft(ys[..i+1]);\n    LemmaToNatLeftEqToNatRightAuto();\n\n    LemmaSeqPrefixNeq(xs, ys, i+1);\n  }\n",
        "method_without_assertion_content": "  lemma LemmaSeqNeq(xs: seq<uint>, ys: seq<uint>)\n    requires |xs| == |ys|\n    requires xs != ys\n    ensures ToNatRight(xs) != ToNatRight(ys)\n  {\n    ghost var i: nat, n: nat := 0, |xs|;\n\n    while i < n\n      invariant 0 <= i < n\n      invariant xs[..i] == ys[..i]\n    {\n      if xs[i] != ys[i] {\n        break;\n      }\n      i := i + 1;\n    }\n    assert ToNatLeft(xs[..i]) == ToNatLeft(ys[..i]);\n\n    reveal ToNatLeft();\n    assert xs[..i+1][..i] == xs[..i];\n        LemmaPowPositiveAuto();\n    LemmaMulStrictInequalityAuto();\n    assert ToNatLeft(xs[..i+1]) != ToNatLeft(ys[..i+1]);\n    LemmaToNatLeftEqToNatRightAuto();\n\n    LemmaSeqPrefixNeq(xs, ys, i+1);\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "49",
        "method_filepath": "./src/Collections/Sequences/LittleEndianNat.dfy",
        "method_without_assertion_filename": "LemmaSeqPrefixNeq_fix_49.dfy",
        "method_name": "LemmaSeqPrefixNeq",
        "method_content": "  lemma LemmaSeqPrefixNeq(xs: seq<uint>, ys: seq<uint>, i: nat)\n    requires 0 <= i <= |xs| == |ys|\n    requires ToNatRight(xs[..i]) != ToNatRight(ys[..i])\n    ensures ToNatRight(xs) != ToNatRight(ys)\n    decreases |xs| - i\n  {\n    if i == |xs| {\n      assert xs[..i] == xs;\n      assert ys[..i] == ys;\n    } else {\n      if xs[i] == ys[i] {\n        reveal ToNatLeft();\n        assert DropLast(xs[..i+1]) == xs[..i];\n        assert DropLast(ys[..i+1]) == ys[..i];\n\n        LemmaToNatLeftEqToNatRightAuto();\n        assert ToNatRight(xs[..i+1]) == ToNatLeft(xs[..i+1]);\n      } else if xs[i] < ys[i] {\n        LemmaSeqMswInequality(xs[..i+1], ys[..i+1]);\n      } else {\n        LemmaSeqMswInequality(ys[..i+1], xs[..i+1]);\n      }\n      reveal ToNatRight();\n      LemmaSeqPrefixNeq(xs, ys, i + 1);\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LemmaSeqPrefixNeq(xs: seq<uint>, ys: seq<uint>, i: nat)\n    requires 0 <= i <= |xs| == |ys|\n    requires ToNatRight(xs[..i]) != ToNatRight(ys[..i])\n    ensures ToNatRight(xs) != ToNatRight(ys)\n    decreases |xs| - i\n  {\n    if i == |xs| {\n            assert ys[..i] == ys;\n    } else {\n      if xs[i] == ys[i] {\n        reveal ToNatLeft();\n        assert DropLast(xs[..i+1]) == xs[..i];\n        assert DropLast(ys[..i+1]) == ys[..i];\n\n        LemmaToNatLeftEqToNatRightAuto();\n        assert ToNatRight(xs[..i+1]) == ToNatLeft(xs[..i+1]);\n      } else if xs[i] < ys[i] {\n        LemmaSeqMswInequality(xs[..i+1], ys[..i+1]);\n      } else {\n        LemmaSeqMswInequality(ys[..i+1], xs[..i+1]);\n      }\n      reveal ToNatRight();\n      LemmaSeqPrefixNeq(xs, ys, i + 1);\n    }\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "50",
        "method_filepath": "./src/Collections/Sequences/LittleEndianNat.dfy",
        "method_without_assertion_filename": "LemmaSeqPrefixNeq_fix_50.dfy",
        "method_name": "LemmaSeqPrefixNeq",
        "method_content": "  lemma LemmaSeqPrefixNeq(xs: seq<uint>, ys: seq<uint>, i: nat)\n    requires 0 <= i <= |xs| == |ys|\n    requires ToNatRight(xs[..i]) != ToNatRight(ys[..i])\n    ensures ToNatRight(xs) != ToNatRight(ys)\n    decreases |xs| - i\n  {\n    if i == |xs| {\n      assert xs[..i] == xs;\n      assert ys[..i] == ys;\n    } else {\n      if xs[i] == ys[i] {\n        reveal ToNatLeft();\n        assert DropLast(xs[..i+1]) == xs[..i];\n        assert DropLast(ys[..i+1]) == ys[..i];\n\n        LemmaToNatLeftEqToNatRightAuto();\n        assert ToNatRight(xs[..i+1]) == ToNatLeft(xs[..i+1]);\n      } else if xs[i] < ys[i] {\n        LemmaSeqMswInequality(xs[..i+1], ys[..i+1]);\n      } else {\n        LemmaSeqMswInequality(ys[..i+1], xs[..i+1]);\n      }\n      reveal ToNatRight();\n      LemmaSeqPrefixNeq(xs, ys, i + 1);\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LemmaSeqPrefixNeq(xs: seq<uint>, ys: seq<uint>, i: nat)\n    requires 0 <= i <= |xs| == |ys|\n    requires ToNatRight(xs[..i]) != ToNatRight(ys[..i])\n    ensures ToNatRight(xs) != ToNatRight(ys)\n    decreases |xs| - i\n  {\n    if i == |xs| {\n      assert xs[..i] == xs;\n          } else {\n      if xs[i] == ys[i] {\n        reveal ToNatLeft();\n        assert DropLast(xs[..i+1]) == xs[..i];\n        assert DropLast(ys[..i+1]) == ys[..i];\n\n        LemmaToNatLeftEqToNatRightAuto();\n        assert ToNatRight(xs[..i+1]) == ToNatLeft(xs[..i+1]);\n      } else if xs[i] < ys[i] {\n        LemmaSeqMswInequality(xs[..i+1], ys[..i+1]);\n      } else {\n        LemmaSeqMswInequality(ys[..i+1], xs[..i+1]);\n      }\n      reveal ToNatRight();\n      LemmaSeqPrefixNeq(xs, ys, i + 1);\n    }\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "51",
        "method_filepath": "./src/Collections/Sequences/LittleEndianNat.dfy",
        "method_without_assertion_filename": "LemmaSeqPrefixNeq_fix_51.dfy",
        "method_name": "LemmaSeqPrefixNeq",
        "method_content": "  lemma LemmaSeqPrefixNeq(xs: seq<uint>, ys: seq<uint>, i: nat)\n    requires 0 <= i <= |xs| == |ys|\n    requires ToNatRight(xs[..i]) != ToNatRight(ys[..i])\n    ensures ToNatRight(xs) != ToNatRight(ys)\n    decreases |xs| - i\n  {\n    if i == |xs| {\n      assert xs[..i] == xs;\n      assert ys[..i] == ys;\n    } else {\n      if xs[i] == ys[i] {\n        reveal ToNatLeft();\n        assert DropLast(xs[..i+1]) == xs[..i];\n        assert DropLast(ys[..i+1]) == ys[..i];\n\n        LemmaToNatLeftEqToNatRightAuto();\n        assert ToNatRight(xs[..i+1]) == ToNatLeft(xs[..i+1]);\n      } else if xs[i] < ys[i] {\n        LemmaSeqMswInequality(xs[..i+1], ys[..i+1]);\n      } else {\n        LemmaSeqMswInequality(ys[..i+1], xs[..i+1]);\n      }\n      reveal ToNatRight();\n      LemmaSeqPrefixNeq(xs, ys, i + 1);\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LemmaSeqPrefixNeq(xs: seq<uint>, ys: seq<uint>, i: nat)\n    requires 0 <= i <= |xs| == |ys|\n    requires ToNatRight(xs[..i]) != ToNatRight(ys[..i])\n    ensures ToNatRight(xs) != ToNatRight(ys)\n    decreases |xs| - i\n  {\n    if i == |xs| {\n      assert xs[..i] == xs;\n      assert ys[..i] == ys;\n    } else {\n      if xs[i] == ys[i] {\n        reveal ToNatLeft();\n                assert DropLast(ys[..i+1]) == ys[..i];\n\n        LemmaToNatLeftEqToNatRightAuto();\n        assert ToNatRight(xs[..i+1]) == ToNatLeft(xs[..i+1]);\n      } else if xs[i] < ys[i] {\n        LemmaSeqMswInequality(xs[..i+1], ys[..i+1]);\n      } else {\n        LemmaSeqMswInequality(ys[..i+1], xs[..i+1]);\n      }\n      reveal ToNatRight();\n      LemmaSeqPrefixNeq(xs, ys, i + 1);\n    }\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "52",
        "method_filepath": "./src/Collections/Sequences/LittleEndianNat.dfy",
        "method_without_assertion_filename": "LemmaSeqPrefixNeq_fix_52.dfy",
        "method_name": "LemmaSeqPrefixNeq",
        "method_content": "  lemma LemmaSeqPrefixNeq(xs: seq<uint>, ys: seq<uint>, i: nat)\n    requires 0 <= i <= |xs| == |ys|\n    requires ToNatRight(xs[..i]) != ToNatRight(ys[..i])\n    ensures ToNatRight(xs) != ToNatRight(ys)\n    decreases |xs| - i\n  {\n    if i == |xs| {\n      assert xs[..i] == xs;\n      assert ys[..i] == ys;\n    } else {\n      if xs[i] == ys[i] {\n        reveal ToNatLeft();\n        assert DropLast(xs[..i+1]) == xs[..i];\n        assert DropLast(ys[..i+1]) == ys[..i];\n\n        LemmaToNatLeftEqToNatRightAuto();\n        assert ToNatRight(xs[..i+1]) == ToNatLeft(xs[..i+1]);\n      } else if xs[i] < ys[i] {\n        LemmaSeqMswInequality(xs[..i+1], ys[..i+1]);\n      } else {\n        LemmaSeqMswInequality(ys[..i+1], xs[..i+1]);\n      }\n      reveal ToNatRight();\n      LemmaSeqPrefixNeq(xs, ys, i + 1);\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LemmaSeqPrefixNeq(xs: seq<uint>, ys: seq<uint>, i: nat)\n    requires 0 <= i <= |xs| == |ys|\n    requires ToNatRight(xs[..i]) != ToNatRight(ys[..i])\n    ensures ToNatRight(xs) != ToNatRight(ys)\n    decreases |xs| - i\n  {\n    if i == |xs| {\n      assert xs[..i] == xs;\n      assert ys[..i] == ys;\n    } else {\n      if xs[i] == ys[i] {\n        reveal ToNatLeft();\n        assert DropLast(xs[..i+1]) == xs[..i];\n        \n        LemmaToNatLeftEqToNatRightAuto();\n        assert ToNatRight(xs[..i+1]) == ToNatLeft(xs[..i+1]);\n      } else if xs[i] < ys[i] {\n        LemmaSeqMswInequality(xs[..i+1], ys[..i+1]);\n      } else {\n        LemmaSeqMswInequality(ys[..i+1], xs[..i+1]);\n      }\n      reveal ToNatRight();\n      LemmaSeqPrefixNeq(xs, ys, i + 1);\n    }\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "54",
        "method_filepath": "./src/Collections/Sequences/Seq.dfy",
        "method_without_assertion_filename": "LemmaCardinalityOfEmptySetIs0_fix_54.dfy",
        "method_name": "LemmaCardinalityOfEmptySetIs0",
        "method_content": "  lemma LemmaCardinalityOfEmptySetIs0<T>(xs: seq<T>)\n    ensures |ToSet(xs)| == 0 <==> |xs| == 0\n  {\n    reveal ToSet();\n    if |xs| != 0 {\n      assert xs[0] in ToSet(xs);\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LemmaCardinalityOfEmptySetIs0<T>(xs: seq<T>)\n    ensures |ToSet(xs)| == 0 <==> |xs| == 0\n  {\n    reveal ToSet();\n    if |xs| != 0 {\n          }\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "56",
        "method_filepath": "./src/Collections/Sequences/Seq.dfy",
        "method_without_assertion_filename": "LemmaFlattenReverseConcat_fix_56.dfy",
        "method_name": "LemmaFlattenReverseConcat",
        "method_content": "  lemma LemmaFlattenReverseConcat<T>(xs: seq<seq<T>>, ys: seq<seq<T>>)\n    ensures FlattenReverse(xs + ys) == FlattenReverse(xs) + FlattenReverse(ys)\n  {\n    if |ys| == 0 {\n      assert FlattenReverse(ys) == [];\n      assert xs + ys == xs;\n    } else {\n      calc == {\n        FlattenReverse(xs + ys);\n        { assert Last(xs + ys) == Last(ys);  assert DropLast(xs + ys) == xs + DropLast(ys); }\n        FlattenReverse(xs + DropLast(ys)) + Last(ys);\n        FlattenReverse(xs) + FlattenReverse(DropLast(ys)) + Last(ys);\n        FlattenReverse(xs) + FlattenReverse(ys);\n      }\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LemmaFlattenReverseConcat<T>(xs: seq<seq<T>>, ys: seq<seq<T>>)\n    ensures FlattenReverse(xs + ys) == FlattenReverse(xs) + FlattenReverse(ys)\n  {\n    if |ys| == 0 {\n      assert FlattenReverse(ys) == [];\n          } else {\n      calc == {\n        FlattenReverse(xs + ys);\n        { assert Last(xs + ys) == Last(ys);  assert DropLast(xs + ys) == xs + DropLast(ys); }\n        FlattenReverse(xs + DropLast(ys)) + Last(ys);\n        FlattenReverse(xs) + FlattenReverse(DropLast(ys)) + Last(ys);\n        FlattenReverse(xs) + FlattenReverse(ys);\n      }\n    }\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "57",
        "method_filepath": "./src/Collections/Sequences/Seq.dfy",
        "method_without_assertion_filename": "LemmaInvFoldRight_fix_57.dfy",
        "method_name": "LemmaInvFoldRight",
        "method_content": "  lemma LemmaInvFoldRight<A,B>(inv: (seq<A>, B) -> bool,\n                               stp: (A, B, B) -> bool,\n                               f: (A, B) -> B,\n                               b: B,\n                               xs: seq<A>)\n    requires InvFoldRight(inv, stp)\n    requires forall a, b :: stp(a, b, f(a, b))\n    requires inv([], b)\n    ensures inv(xs, FoldRight(f, xs, b))\n  {\n    reveal FoldRight();\n    if xs == [] {\n    } else {\n      assert [xs[0]] + xs[1..] == xs;\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LemmaInvFoldRight<A,B>(inv: (seq<A>, B) -> bool,\n                               stp: (A, B, B) -> bool,\n                               f: (A, B) -> B,\n                               b: B,\n                               xs: seq<A>)\n    requires InvFoldRight(inv, stp)\n    requires forall a, b :: stp(a, b, f(a, b))\n    requires inv([], b)\n    ensures inv(xs, FoldRight(f, xs, b))\n  {\n    reveal FoldRight();\n    if xs == [] {\n    } else {\n          }\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "58",
        "method_filepath": "./src/Collections/Sequences/Seq.dfy",
        "method_without_assertion_filename": "LemmaInvFoldLeft_fix_58.dfy",
        "method_name": "LemmaInvFoldLeft",
        "method_content": "  lemma LemmaInvFoldLeft<A,B>(inv: (B, seq<A>) -> bool,\n                              stp: (B, A, B) -> bool,\n                              f: (B, A) -> B,\n                              b: B,\n                              xs: seq<A>)\n    requires InvFoldLeft(inv, stp)\n    requires forall b, a :: stp(b, a, f(b, a))\n    requires inv(b, xs)\n    ensures inv(FoldLeft(f, b, xs), [])\n  {\n    reveal FoldLeft();\n    if xs == [] {\n    } else {\n      assert [xs[0]] + xs[1..] == xs;\n      LemmaInvFoldLeft(inv, stp, f, f(b, xs[0]), xs[1..]);\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LemmaInvFoldLeft<A,B>(inv: (B, seq<A>) -> bool,\n                              stp: (B, A, B) -> bool,\n                              f: (B, A) -> B,\n                              b: B,\n                              xs: seq<A>)\n    requires InvFoldLeft(inv, stp)\n    requires forall b, a :: stp(b, a, f(b, a))\n    requires inv(b, xs)\n    ensures inv(FoldLeft(f, b, xs), [])\n  {\n    reveal FoldLeft();\n    if xs == [] {\n    } else {\n            LemmaInvFoldLeft(inv, stp, f, f(b, xs[0]), xs[1..]);\n    }\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "59",
        "method_filepath": "./src/Collections/Sequences/Seq.dfy",
        "method_without_assertion_filename": "LemmaSubseqMin_fix_59.dfy",
        "method_name": "LemmaSubseqMin",
        "method_content": "  lemma LemmaSubseqMin(xs: seq<int>, from: nat, to: nat)\n    requires from < to <= |xs|\n    ensures Min(xs[from..to]) >= Min(xs)\n  {\n    var subseq := xs[from..to];\n    if Min(subseq) < Min(xs) {\n      var k :| 0 <= k < |subseq| && subseq[k] == Min(subseq);\n      assert xs[seq(|subseq|, i requires 0 <= i < |subseq| => i + from)[k]] in xs;\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LemmaSubseqMin(xs: seq<int>, from: nat, to: nat)\n    requires from < to <= |xs|\n    ensures Min(xs[from..to]) >= Min(xs)\n  {\n    var subseq := xs[from..to];\n    if Min(subseq) < Min(xs) {\n      var k :| 0 <= k < |subseq| && subseq[k] == Min(subseq);\n          }\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "60",
        "method_filepath": "./src/Collections/Sequences/Seq.dfy",
        "method_without_assertion_filename": "LemmaFlattenConcat_fix_60.dfy",
        "method_name": "LemmaFlattenConcat",
        "method_content": "  lemma LemmaFlattenConcat<T>(xs: seq<seq<T>>, ys: seq<seq<T>>)\n    ensures Flatten(xs + ys) == Flatten(xs) + Flatten(ys)\n  {\n    if |xs| == 0 {\n      assert xs + ys == ys;\n    } else {\n      calc == {\n        Flatten(xs + ys);\n        { assert (xs + ys)[0] == xs[0];  assert (xs + ys)[1..] == xs[1..] + ys; }\n        xs[0] + Flatten(xs[1..] + ys);\n        xs[0] + Flatten(xs[1..]) + Flatten(ys);\n        Flatten(xs) + Flatten(ys);\n      }\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LemmaFlattenConcat<T>(xs: seq<seq<T>>, ys: seq<seq<T>>)\n    ensures Flatten(xs + ys) == Flatten(xs) + Flatten(ys)\n  {\n    if |xs| == 0 {\n          } else {\n      calc == {\n        Flatten(xs + ys);\n        { assert (xs + ys)[0] == xs[0];  assert (xs + ys)[1..] == xs[1..] + ys; }\n        xs[0] + Flatten(xs[1..] + ys);\n        xs[0] + Flatten(xs[1..]) + Flatten(ys);\n        Flatten(xs) + Flatten(ys);\n      }\n    }\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "61",
        "method_filepath": "./src/Collections/Sequences/Seq.dfy",
        "method_without_assertion_filename": "LemmaSubseqMax_fix_61.dfy",
        "method_name": "LemmaSubseqMax",
        "method_content": "  lemma LemmaSubseqMax(xs: seq<int>, from: nat, to: nat)\n    requires from < to <= |xs|\n    ensures Max(xs[from..to]) <= Max(xs)\n  {\n    var subseq := xs[from..to];\n    if Max(subseq) > Max(xs) {\n      var k :| 0 <= k < |subseq| && subseq[k] == Max(subseq);\n      assert xs[seq(|subseq|, i requires 0 <= i < |subseq| => i + from)[k]] in xs;\n      assert false;\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LemmaSubseqMax(xs: seq<int>, from: nat, to: nat)\n    requires from < to <= |xs|\n    ensures Max(xs[from..to]) <= Max(xs)\n  {\n    var subseq := xs[from..to];\n    if Max(subseq) > Max(xs) {\n      var k :| 0 <= k < |subseq| && subseq[k] == Max(subseq);\n            assert false;\n    }\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "63",
        "method_filepath": "./src/Collections/Sequences/Seq.dfy",
        "method_without_assertion_filename": "LemmaFlattenLengthLeMul_fix_63.dfy",
        "method_name": "LemmaFlattenLengthLeMul",
        "method_content": "  lemma LemmaFlattenLengthLeMul<T>(xs: seq<seq<T>>, j: int)\n    requires forall i | 0 <= i < |xs| :: |xs[i]| <= j\n    ensures |FlattenReverse(xs)| <= |xs| * j\n  {\n    if |xs| == 0 {\n    } else {\n      LemmaFlattenLengthLeMul(xs[..|xs|-1], j);\n      assert |FlattenReverse(xs[..|xs|-1])| <= (|xs|-1) * j;\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LemmaFlattenLengthLeMul<T>(xs: seq<seq<T>>, j: int)\n    requires forall i | 0 <= i < |xs| :: |xs[i]| <= j\n    ensures |FlattenReverse(xs)| <= |xs| * j\n  {\n    if |xs| == 0 {\n    } else {\n      LemmaFlattenLengthLeMul(xs[..|xs|-1], j);\n          }\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "64",
        "method_filepath": "./src/Collections/Sequences/Seq.dfy",
        "method_without_assertion_filename": "LemmaCardinalityOfSet_fix_64.dfy",
        "method_name": "LemmaCardinalityOfSet",
        "method_content": "  lemma LemmaCardinalityOfSet<T>(xs: seq<T>)\n    ensures |ToSet(xs)| <= |xs|\n  {\n    reveal ToSet();\n    if |xs| == 0 {\n    } else {\n      assert ToSet(xs) == ToSet(DropLast(xs)) + {Last(xs)};\n      LemmaCardinalityOfSet(DropLast(xs));\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LemmaCardinalityOfSet<T>(xs: seq<T>)\n    ensures |ToSet(xs)| <= |xs|\n  {\n    reveal ToSet();\n    if |xs| == 0 {\n    } else {\n            LemmaCardinalityOfSet(DropLast(xs));\n    }\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "65",
        "method_filepath": "./src/Collections/Sequences/Seq.dfy",
        "method_without_assertion_filename": "LemmaCardinalityOfSetNoDuplicates_fix_65.dfy",
        "method_name": "LemmaCardinalityOfSetNoDuplicates",
        "method_content": "  lemma LemmaCardinalityOfSetNoDuplicates<T>(xs: seq<T>)\n    requires HasNoDuplicates(xs)\n    ensures |ToSet(xs)| == |xs|\n  {\n    reveal HasNoDuplicates();\n    reveal ToSet();\n    if |xs| == 0 {\n    } else {\n      LemmaCardinalityOfSetNoDuplicates(DropLast(xs));\n      assert ToSet(xs) == ToSet(DropLast(xs)) + {Last(xs)};\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LemmaCardinalityOfSetNoDuplicates<T>(xs: seq<T>)\n    requires HasNoDuplicates(xs)\n    ensures |ToSet(xs)| == |xs|\n  {\n    reveal HasNoDuplicates();\n    reveal ToSet();\n    if |xs| == 0 {\n    } else {\n      LemmaCardinalityOfSetNoDuplicates(DropLast(xs));\n          }\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "67",
        "method_filepath": "./src/Collections/Sequences/Seq.dfy",
        "method_without_assertion_filename": "LemmaNoDuplicatesCardinalityOfSet_fix_67.dfy",
        "method_name": "LemmaNoDuplicatesCardinalityOfSet",
        "method_content": "  lemma LemmaNoDuplicatesCardinalityOfSet<T>(xs: seq<T>)\n    requires |ToSet(xs)| == |xs|\n    ensures HasNoDuplicates(xs)\n  {\n    reveal HasNoDuplicates();\n    reveal ToSet();\n    if |xs| == 0 {\n    } else {\n      assert xs == [First(xs)] + DropFirst(xs);\n      assert ToSet(xs) == {First(xs)} + ToSet(DropFirst(xs));\n      if First(xs) in DropFirst(xs) {\n        // If there is a duplicate, then we show that |ToSet(s)| == |s| cannot hold.\n        assert ToSet(xs) == ToSet(DropFirst(xs));\n        LemmaCardinalityOfSet(DropFirst(xs));\n        assert |ToSet(xs)| <= |DropFirst(xs)|;\n      } else {\n        assert |ToSet(xs)| == 1 + |ToSet(DropFirst(xs))|;\n        LemmaNoDuplicatesCardinalityOfSet(DropFirst(xs));\n      }\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LemmaNoDuplicatesCardinalityOfSet<T>(xs: seq<T>)\n    requires |ToSet(xs)| == |xs|\n    ensures HasNoDuplicates(xs)\n  {\n    reveal HasNoDuplicates();\n    reveal ToSet();\n    if |xs| == 0 {\n    } else {\n      assert xs == [First(xs)] + DropFirst(xs);\n            if First(xs) in DropFirst(xs) {\n        // If there is a duplicate, then we show that |ToSet(s)| == |s| cannot hold.\n        assert ToSet(xs) == ToSet(DropFirst(xs));\n        LemmaCardinalityOfSet(DropFirst(xs));\n        assert |ToSet(xs)| <= |DropFirst(xs)|;\n      } else {\n        assert |ToSet(xs)| == 1 + |ToSet(DropFirst(xs))|;\n        LemmaNoDuplicatesCardinalityOfSet(DropFirst(xs));\n      }\n    }\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "71",
        "method_filepath": "./src/Collections/Sequences/Seq.dfy",
        "method_without_assertion_filename": "LemmaMultisetHasNoDuplicates_fix_71.dfy",
        "method_name": "LemmaMultisetHasNoDuplicates",
        "method_content": "  lemma LemmaMultisetHasNoDuplicates<T>(xs: seq<T>)\n    requires HasNoDuplicates(xs)\n    ensures forall x | x in multiset(xs) :: multiset(xs)[x] == 1\n  {\n    if |xs| == 0 {\n    } else {\n      assert xs == DropLast(xs) + [Last(xs)];\n      assert Last(xs) !in DropLast(xs) by {\n        reveal HasNoDuplicates();\n      }\n      assert HasNoDuplicates(DropLast(xs)) by {\n        reveal HasNoDuplicates();\n      }\n      LemmaMultisetHasNoDuplicates(DropLast(xs));\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LemmaMultisetHasNoDuplicates<T>(xs: seq<T>)\n    requires HasNoDuplicates(xs)\n    ensures forall x | x in multiset(xs) :: multiset(xs)[x] == 1\n  {\n    if |xs| == 0 {\n    } else {\n            assert Last(xs) !in DropLast(xs) by {\n        reveal HasNoDuplicates();\n      }\n      assert HasNoDuplicates(DropLast(xs)) by {\n        reveal HasNoDuplicates();\n      }\n      LemmaMultisetHasNoDuplicates(DropLast(xs));\n    }\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "73",
        "method_filepath": "./src/Collections/Sequences/Seq.dfy",
        "method_without_assertion_filename": "LemmaMinOfConcat_fix_73.dfy",
        "method_name": "LemmaMinOfConcat",
        "method_content": "  lemma LemmaMinOfConcat(xs: seq<int>, ys: seq<int>)\n    requires 0 < |xs| && 0 < |ys|\n    ensures Min(xs+ys) <= Min(xs)\n    ensures Min(xs+ys) <= Min(ys)\n    ensures forall i :: i in xs + ys ==> Min(xs + ys) <= i\n  {\n    reveal Min();\n    if |xs| == 1 {\n    } else {\n      assert xs[1..] + ys == (xs + ys)[1..];\n      LemmaMinOfConcat(xs[1..], ys);\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LemmaMinOfConcat(xs: seq<int>, ys: seq<int>)\n    requires 0 < |xs| && 0 < |ys|\n    ensures Min(xs+ys) <= Min(xs)\n    ensures Min(xs+ys) <= Min(ys)\n    ensures forall i :: i in xs + ys ==> Min(xs + ys) <= i\n  {\n    reveal Min();\n    if |xs| == 1 {\n    } else {\n            LemmaMinOfConcat(xs[1..], ys);\n    }\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "74",
        "method_filepath": "./src/Collections/Sequences/Seq.dfy",
        "method_without_assertion_filename": "LemmaMaxOfConcat_fix_74.dfy",
        "method_name": "LemmaMaxOfConcat",
        "method_content": "  lemma LemmaMaxOfConcat(xs: seq<int>, ys: seq<int>)\n    requires 0 < |xs| && 0 < |ys|\n    ensures Max(xs+ys) >= Max(xs)\n    ensures Max(xs+ys) >= Max(ys)\n    ensures forall i {:trigger i in [Max(xs + ys)]} :: i in xs + ys ==> Max(xs + ys) >= i\n  {\n    reveal Max();\n    if |xs| == 1 {\n    } else {\n      assert xs[1..] + ys == (xs + ys)[1..];\n      LemmaMaxOfConcat(xs[1..], ys);\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LemmaMaxOfConcat(xs: seq<int>, ys: seq<int>)\n    requires 0 < |xs| && 0 < |ys|\n    ensures Max(xs+ys) >= Max(xs)\n    ensures Max(xs+ys) >= Max(ys)\n    ensures forall i {:trigger i in [Max(xs + ys)]} :: i in xs + ys ==> Max(xs + ys) >= i\n  {\n    reveal Max();\n    if |xs| == 1 {\n    } else {\n            LemmaMaxOfConcat(xs[1..], ys);\n    }\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "76",
        "method_filepath": "./src/Collections/Sequences/Seq.dfy",
        "method_without_assertion_filename": "SortedUnique_fix_76.dfy",
        "method_name": "SortedUnique",
        "method_content": "  lemma SortedUnique<T>(xs: seq<T>, ys: seq<T>, R: (T, T) -> bool)\n    requires SortedBy(xs, R)\n    requires SortedBy(ys, R)\n    requires TotalOrdering(R)\n    requires multiset(xs) == multiset(ys)\n    ensures xs == ys\n  {\n    assert |xs| == |multiset(xs)| == |multiset(ys)| == |ys|;\n    if xs == [] || ys == [] {\n    } else {\n      assert xs == [xs[0]] + xs[1..];\n      assert ys == [ys[0]] + ys[1..];\n      assert multiset(xs[1..]) == multiset(xs) - multiset{xs[0]};\n      assert multiset(ys[1..]) == multiset(ys) - multiset{ys[0]};\n      assert multiset(xs[1..]) == multiset(ys[1..]);\n      SortedUnique(xs[1..], ys[1..], R);\n    }\n  }\n",
        "method_without_assertion_content": "  lemma SortedUnique<T>(xs: seq<T>, ys: seq<T>, R: (T, T) -> bool)\n    requires SortedBy(xs, R)\n    requires SortedBy(ys, R)\n    requires TotalOrdering(R)\n    requires multiset(xs) == multiset(ys)\n    ensures xs == ys\n  {\n    assert |xs| == |multiset(xs)| == |multiset(ys)| == |ys|;\n    if xs == [] || ys == [] {\n    } else {\n            assert ys == [ys[0]] + ys[1..];\n      assert multiset(xs[1..]) == multiset(xs) - multiset{xs[0]};\n      assert multiset(ys[1..]) == multiset(ys) - multiset{ys[0]};\n      assert multiset(xs[1..]) == multiset(ys[1..]);\n      SortedUnique(xs[1..], ys[1..], R);\n    }\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "77",
        "method_filepath": "./src/Collections/Sequences/Seq.dfy",
        "method_without_assertion_filename": "SortedUnique_fix_77.dfy",
        "method_name": "SortedUnique",
        "method_content": "  lemma SortedUnique<T>(xs: seq<T>, ys: seq<T>, R: (T, T) -> bool)\n    requires SortedBy(xs, R)\n    requires SortedBy(ys, R)\n    requires TotalOrdering(R)\n    requires multiset(xs) == multiset(ys)\n    ensures xs == ys\n  {\n    assert |xs| == |multiset(xs)| == |multiset(ys)| == |ys|;\n    if xs == [] || ys == [] {\n    } else {\n      assert xs == [xs[0]] + xs[1..];\n      assert ys == [ys[0]] + ys[1..];\n      assert multiset(xs[1..]) == multiset(xs) - multiset{xs[0]};\n      assert multiset(ys[1..]) == multiset(ys) - multiset{ys[0]};\n      assert multiset(xs[1..]) == multiset(ys[1..]);\n      SortedUnique(xs[1..], ys[1..], R);\n    }\n  }\n",
        "method_without_assertion_content": "  lemma SortedUnique<T>(xs: seq<T>, ys: seq<T>, R: (T, T) -> bool)\n    requires SortedBy(xs, R)\n    requires SortedBy(ys, R)\n    requires TotalOrdering(R)\n    requires multiset(xs) == multiset(ys)\n    ensures xs == ys\n  {\n    assert |xs| == |multiset(xs)| == |multiset(ys)| == |ys|;\n    if xs == [] || ys == [] {\n    } else {\n      assert xs == [xs[0]] + xs[1..];\n            assert multiset(xs[1..]) == multiset(xs) - multiset{xs[0]};\n      assert multiset(ys[1..]) == multiset(ys) - multiset{ys[0]};\n      assert multiset(xs[1..]) == multiset(ys[1..]);\n      SortedUnique(xs[1..], ys[1..], R);\n    }\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "99",
        "method_filepath": "./src/NonlinearArithmetic/Power2.dfy",
        "method_without_assertion_filename": "LemmaPow2MaskDiv2_fix_99.dfy",
        "method_name": "LemmaPow2MaskDiv2",
        "method_content": "  lemma LemmaPow2MaskDiv2(e: nat)\n    requires 0 < e\n    ensures (Pow2(e) - 1) / 2 == Pow2(e - 1) - 1\n  {\n    LemmaPow2Auto();\n    LemmaPowAuto();\n    var f := e => 0 < e ==> (Pow2(e) - 1) / 2 == Pow2(e - 1) - 1;\n    assert forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + 1);\n    assert forall i {:trigger IsLe(i, 0)} :: IsLe(i, 0) && f(i) ==> f(i - 1);\n    LemmaMulInductionAuto(e, f);\n  }\n",
        "method_without_assertion_content": "  lemma LemmaPow2MaskDiv2(e: nat)\n    requires 0 < e\n    ensures (Pow2(e) - 1) / 2 == Pow2(e - 1) - 1\n  {\n    LemmaPow2Auto();\n    LemmaPowAuto();\n    var f := e => 0 < e ==> (Pow2(e) - 1) / 2 == Pow2(e - 1) - 1;\n        assert forall i {:trigger IsLe(i, 0)} :: IsLe(i, 0) && f(i) ==> f(i - 1);\n    LemmaMulInductionAuto(e, f);\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "151",
        "method_filepath": "./src/NonlinearArithmetic/Internals/GeneralInternals.dfy",
        "method_without_assertion_filename": "LemmaInductionHelper_fix_151.dfy",
        "method_name": "LemmaInductionHelper",
        "method_content": "  lemma LemmaInductionHelper(n: int, f: int -> bool, x: int)\n    requires n > 0\n    requires forall i :: 0 <= i < n ==> f(i)\n    requires forall i {:trigger f(i), f(i + n)} :: i >= 0 && f(i) ==> f(i + n)\n    requires forall i {:trigger f(i), f(i - n)} :: i < n  && f(i) ==> f(i - n)\n    ensures  f(x)\n    decreases if x >= n then x else -x\n  {\n    if (x >= n)\n    {\n      LemmaInductionHelper(n, f, x - n);\n      assert f((x - n) + n);\n    }\n    else if (x < 0)\n    {\n      LemmaInductionHelper(n, f, x + n);\n      assert f((x + n) - n);\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LemmaInductionHelper(n: int, f: int -> bool, x: int)\n    requires n > 0\n    requires forall i :: 0 <= i < n ==> f(i)\n    requires forall i {:trigger f(i), f(i + n)} :: i >= 0 && f(i) ==> f(i + n)\n    requires forall i {:trigger f(i), f(i - n)} :: i < n  && f(i) ==> f(i - n)\n    ensures  f(x)\n    decreases if x >= n then x else -x\n  {\n    if (x >= n)\n    {\n      LemmaInductionHelper(n, f, x - n);\n          }\n    else if (x < 0)\n    {\n      LemmaInductionHelper(n, f, x + n);\n      assert f((x + n) - n);\n    }\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "152",
        "method_filepath": "./src/NonlinearArithmetic/Internals/GeneralInternals.dfy",
        "method_without_assertion_filename": "LemmaInductionHelper_fix_152.dfy",
        "method_name": "LemmaInductionHelper",
        "method_content": "  lemma LemmaInductionHelper(n: int, f: int -> bool, x: int)\n    requires n > 0\n    requires forall i :: 0 <= i < n ==> f(i)\n    requires forall i {:trigger f(i), f(i + n)} :: i >= 0 && f(i) ==> f(i + n)\n    requires forall i {:trigger f(i), f(i - n)} :: i < n  && f(i) ==> f(i - n)\n    ensures  f(x)\n    decreases if x >= n then x else -x\n  {\n    if (x >= n)\n    {\n      LemmaInductionHelper(n, f, x - n);\n      assert f((x - n) + n);\n    }\n    else if (x < 0)\n    {\n      LemmaInductionHelper(n, f, x + n);\n      assert f((x + n) - n);\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LemmaInductionHelper(n: int, f: int -> bool, x: int)\n    requires n > 0\n    requires forall i :: 0 <= i < n ==> f(i)\n    requires forall i {:trigger f(i), f(i + n)} :: i >= 0 && f(i) ==> f(i + n)\n    requires forall i {:trigger f(i), f(i - n)} :: i < n  && f(i) ==> f(i - n)\n    ensures  f(x)\n    decreases if x >= n then x else -x\n  {\n    if (x >= n)\n    {\n      LemmaInductionHelper(n, f, x - n);\n      assert f((x - n) + n);\n    }\n    else if (x < 0)\n    {\n      LemmaInductionHelper(n, f, x + n);\n          }\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "153",
        "method_filepath": "./src/NonlinearArithmetic/Internals/DivInternals.dfy",
        "method_without_assertion_filename": "LemmaDivInductionAutoForall_fix_153.dfy",
        "method_name": "LemmaDivInductionAutoForall",
        "method_content": "  lemma LemmaDivInductionAutoForall(n:int, f:int->bool)\n    requires n > 0\n    requires DivAuto(n) ==> && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i))\n                            && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + n))\n                            && (forall i {:trigger IsLe(i + 1, n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n))\n    ensures  DivAuto(n)\n    ensures  forall i {:trigger f(i)} :: f(i)\n  {\n    LemmaDivAuto(n);\n    assert forall i :: IsLe(0, i) && i < n ==> f(i);\n    assert forall i {:trigger f(i), f(i + n)} :: IsLe(0, i) && f(i) ==> f(i + n);\n    assert forall i {:trigger f(i), f(i - n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n);\n    LemmaModInductionForall(n, f);\n  }\n",
        "method_without_assertion_content": "  lemma LemmaDivInductionAutoForall(n:int, f:int->bool)\n    requires n > 0\n    requires DivAuto(n) ==> && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i))\n                            && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + n))\n                            && (forall i {:trigger IsLe(i + 1, n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n))\n    ensures  DivAuto(n)\n    ensures  forall i {:trigger f(i)} :: f(i)\n  {\n    LemmaDivAuto(n);\n        assert forall i {:trigger f(i), f(i + n)} :: IsLe(0, i) && f(i) ==> f(i + n);\n    assert forall i {:trigger f(i), f(i - n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n);\n    LemmaModInductionForall(n, f);\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "154",
        "method_filepath": "./src/NonlinearArithmetic/Internals/DivInternals.dfy",
        "method_without_assertion_filename": "LemmaDivInductionAutoForall_fix_154.dfy",
        "method_name": "LemmaDivInductionAutoForall",
        "method_content": "  lemma LemmaDivInductionAutoForall(n:int, f:int->bool)\n    requires n > 0\n    requires DivAuto(n) ==> && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i))\n                            && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + n))\n                            && (forall i {:trigger IsLe(i + 1, n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n))\n    ensures  DivAuto(n)\n    ensures  forall i {:trigger f(i)} :: f(i)\n  {\n    LemmaDivAuto(n);\n    assert forall i :: IsLe(0, i) && i < n ==> f(i);\n    assert forall i {:trigger f(i), f(i + n)} :: IsLe(0, i) && f(i) ==> f(i + n);\n    assert forall i {:trigger f(i), f(i - n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n);\n    LemmaModInductionForall(n, f);\n  }\n",
        "method_without_assertion_content": "  lemma LemmaDivInductionAutoForall(n:int, f:int->bool)\n    requires n > 0\n    requires DivAuto(n) ==> && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i))\n                            && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + n))\n                            && (forall i {:trigger IsLe(i + 1, n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n))\n    ensures  DivAuto(n)\n    ensures  forall i {:trigger f(i)} :: f(i)\n  {\n    LemmaDivAuto(n);\n    assert forall i :: IsLe(0, i) && i < n ==> f(i);\n        assert forall i {:trigger f(i), f(i - n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n);\n    LemmaModInductionForall(n, f);\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "155",
        "method_filepath": "./src/NonlinearArithmetic/Internals/DivInternals.dfy",
        "method_without_assertion_filename": "LemmaDivInductionAutoForall_fix_155.dfy",
        "method_name": "LemmaDivInductionAutoForall",
        "method_content": "  lemma LemmaDivInductionAutoForall(n:int, f:int->bool)\n    requires n > 0\n    requires DivAuto(n) ==> && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i))\n                            && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + n))\n                            && (forall i {:trigger IsLe(i + 1, n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n))\n    ensures  DivAuto(n)\n    ensures  forall i {:trigger f(i)} :: f(i)\n  {\n    LemmaDivAuto(n);\n    assert forall i :: IsLe(0, i) && i < n ==> f(i);\n    assert forall i {:trigger f(i), f(i + n)} :: IsLe(0, i) && f(i) ==> f(i + n);\n    assert forall i {:trigger f(i), f(i - n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n);\n    LemmaModInductionForall(n, f);\n  }\n",
        "method_without_assertion_content": "  lemma LemmaDivInductionAutoForall(n:int, f:int->bool)\n    requires n > 0\n    requires DivAuto(n) ==> && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i))\n                            && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + n))\n                            && (forall i {:trigger IsLe(i + 1, n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n))\n    ensures  DivAuto(n)\n    ensures  forall i {:trigger f(i)} :: f(i)\n  {\n    LemmaDivAuto(n);\n    assert forall i :: IsLe(0, i) && i < n ==> f(i);\n    assert forall i {:trigger f(i), f(i + n)} :: IsLe(0, i) && f(i) ==> f(i + n);\n        LemmaModInductionForall(n, f);\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "156",
        "method_filepath": "./src/NonlinearArithmetic/Internals/DivInternals.dfy",
        "method_without_assertion_filename": "LemmaDivInductionAuto_fix_156.dfy",
        "method_name": "LemmaDivInductionAuto",
        "method_content": "  lemma LemmaDivInductionAuto(n: int, x: int, f: int->bool)\n    requires n > 0\n    requires DivAuto(n) ==> && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i))\n                            && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + n))\n                            && (forall i {:trigger IsLe(i + 1, n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n))\n    ensures  DivAuto(n)\n    ensures  f(x)\n  {\n    LemmaDivAuto(n);\n    assert forall i :: IsLe(0, i) && i < n ==> f(i);\n    assert forall i {:trigger f(i), f(i + n)} :: IsLe(0, i) && f(i) ==> f(i + n);\n    assert forall i {:trigger f(i), f(i - n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n);\n    LemmaModInductionForall(n, f);\n    assert f(x);\n  }\n",
        "method_without_assertion_content": "  lemma LemmaDivInductionAuto(n: int, x: int, f: int->bool)\n    requires n > 0\n    requires DivAuto(n) ==> && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i))\n                            && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + n))\n                            && (forall i {:trigger IsLe(i + 1, n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n))\n    ensures  DivAuto(n)\n    ensures  f(x)\n  {\n    LemmaDivAuto(n);\n        assert forall i {:trigger f(i), f(i + n)} :: IsLe(0, i) && f(i) ==> f(i + n);\n    assert forall i {:trigger f(i), f(i - n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n);\n    LemmaModInductionForall(n, f);\n    assert f(x);\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "157",
        "method_filepath": "./src/NonlinearArithmetic/Internals/DivInternals.dfy",
        "method_without_assertion_filename": "LemmaDivInductionAuto_fix_157.dfy",
        "method_name": "LemmaDivInductionAuto",
        "method_content": "  lemma LemmaDivInductionAuto(n: int, x: int, f: int->bool)\n    requires n > 0\n    requires DivAuto(n) ==> && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i))\n                            && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + n))\n                            && (forall i {:trigger IsLe(i + 1, n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n))\n    ensures  DivAuto(n)\n    ensures  f(x)\n  {\n    LemmaDivAuto(n);\n    assert forall i :: IsLe(0, i) && i < n ==> f(i);\n    assert forall i {:trigger f(i), f(i + n)} :: IsLe(0, i) && f(i) ==> f(i + n);\n    assert forall i {:trigger f(i), f(i - n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n);\n    LemmaModInductionForall(n, f);\n    assert f(x);\n  }\n",
        "method_without_assertion_content": "  lemma LemmaDivInductionAuto(n: int, x: int, f: int->bool)\n    requires n > 0\n    requires DivAuto(n) ==> && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i))\n                            && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + n))\n                            && (forall i {:trigger IsLe(i + 1, n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n))\n    ensures  DivAuto(n)\n    ensures  f(x)\n  {\n    LemmaDivAuto(n);\n    assert forall i :: IsLe(0, i) && i < n ==> f(i);\n        assert forall i {:trigger f(i), f(i - n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n);\n    LemmaModInductionForall(n, f);\n    assert f(x);\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "158",
        "method_filepath": "./src/NonlinearArithmetic/Internals/DivInternals.dfy",
        "method_without_assertion_filename": "LemmaDivInductionAuto_fix_158.dfy",
        "method_name": "LemmaDivInductionAuto",
        "method_content": "  lemma LemmaDivInductionAuto(n: int, x: int, f: int->bool)\n    requires n > 0\n    requires DivAuto(n) ==> && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i))\n                            && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + n))\n                            && (forall i {:trigger IsLe(i + 1, n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n))\n    ensures  DivAuto(n)\n    ensures  f(x)\n  {\n    LemmaDivAuto(n);\n    assert forall i :: IsLe(0, i) && i < n ==> f(i);\n    assert forall i {:trigger f(i), f(i + n)} :: IsLe(0, i) && f(i) ==> f(i + n);\n    assert forall i {:trigger f(i), f(i - n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n);\n    LemmaModInductionForall(n, f);\n    assert f(x);\n  }\n",
        "method_without_assertion_content": "  lemma LemmaDivInductionAuto(n: int, x: int, f: int->bool)\n    requires n > 0\n    requires DivAuto(n) ==> && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i))\n                            && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + n))\n                            && (forall i {:trigger IsLe(i + 1, n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n))\n    ensures  DivAuto(n)\n    ensures  f(x)\n  {\n    LemmaDivAuto(n);\n    assert forall i :: IsLe(0, i) && i < n ==> f(i);\n    assert forall i {:trigger f(i), f(i + n)} :: IsLe(0, i) && f(i) ==> f(i + n);\n        LemmaModInductionForall(n, f);\n    assert f(x);\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "170",
        "method_filepath": "./src/NonlinearArithmetic/Internals/DivInternals.dfy",
        "method_without_assertion_filename": "LemmaDivAuto_fix_170.dfy",
        "method_name": "LemmaDivAuto",
        "method_content": "  lemma LemmaDivAuto(n: int)\n    requires n > 0\n    ensures  DivAuto(n)\n  {\n    LemmaModAuto(n);\n    LemmaDivBasics(n);\n    assert (0 + n) / n == 1;\n    assert (0 - n) / n == -1;\n    forall x:int, y:int {:trigger (x + y) / n}\n      ensures  var z := (x % n) + (y % n);\n               (|| (0 <= z < n && (x + y) / n == x / n + y / n)\n                || (n <= z < 2 * n && (x + y) / n == x / n + y / n + 1))\n    {\n      var f := (xx:int, yy:int) =>\n          (var z := (xx % n) + (yy % n);\n           (   (0 <= z < n && (xx + yy) / n == xx / n + yy / n)\n               || (n <= z < 2 * n && (xx + yy) / n == xx / n + yy / n + 1)));\n      forall i, j\n        ensures j >= 0 && f(i, j) ==> f(i, j + n)\n        ensures i < n  && f(i, j) ==> f(i - n, j)\n        ensures j < n  && f(i, j) ==> f(i, j - n)\n        ensures i >= 0 && f(i, j) ==> f(i + n, j)\n      {\n        assert ((i + n) + j) / n == ((i + j) + n) / n;\n        assert (i + (j + n)) / n == ((i + j) + n) / n;\n        assert ((i - n) + j) / n == ((i + j) - n) / n;\n        assert (i + (j - n)) / n == ((i + j) - n) / n;\n      }\n      forall i, j\n        ensures 0 <= i < n && 0 <= j < n ==> f(i, j)\n      {\n        assert ((i + n) + j) / n == ((i + j) + n) / n;\n        assert (i + (j + n)) / n == ((i + j) + n) / n;\n        assert ((i - n) + j) / n == ((i + j) - n) / n;\n        assert (i + (j - n)) / n == ((i + j) - n) / n;\n      }\n      LemmaModInductionForall2(n, f);\n      assert f(x, y);\n    }\n    forall x:int, y:int {:trigger (x - y) / n}\n      ensures  var z := (x % n) - (y % n);\n               (|| (0 <= z < n && (x - y) / n == x / n - y / n)\n                || (-n <= z < 0 && (x - y) / n == x / n - y / n - 1))\n    {\n      var f := (xx:int, yy:int) =>\n          (var z := (xx % n) - (yy % n);\n           (   (0 <= z < n && (xx - yy) / n == xx / n - yy / n)\n               || (-n <= z < 0 && (xx - yy) / n == xx / n - yy / n - 1)));\n      forall i, j\n        ensures j >= 0 && f(i, j) ==> f(i, j + n)\n        ensures i < n  && f(i, j) ==> f(i - n, j)\n        ensures j < n  && f(i, j) ==> f(i, j - n)\n        ensures i >= 0 && f(i, j) ==> f(i + n, j)\n      {\n        assert ((i + n) - j) / n == ((i - j) + n) / n;\n        assert (i - (j - n)) / n == ((i - j) + n) / n;\n        assert ((i - n) - j) / n == ((i - j) - n) / n;\n        assert (i - (j + n)) / n == ((i - j) - n) / n;\n      }\n      forall i, j\n        ensures 0 <= i < n && 0 <= j < n ==> f(i, j)\n      {\n        assert ((i + n) - j) / n == ((i - j) + n) / n;\n        assert (i - (j - n)) / n == ((i - j) + n) / n;\n        assert ((i - n) - j) / n == ((i - j) - n) / n;\n        assert (i - (j + n)) / n == ((i - j) - n) / n;\n      }\n      LemmaModInductionForall2(n, f);\n      assert f(x, y);\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LemmaDivAuto(n: int)\n    requires n > 0\n    ensures  DivAuto(n)\n  {\n    LemmaModAuto(n);\n    LemmaDivBasics(n);\n    assert (0 + n) / n == 1;\n    assert (0 - n) / n == -1;\n    forall x:int, y:int {:trigger (x + y) / n}\n      ensures  var z := (x % n) + (y % n);\n               (|| (0 <= z < n && (x + y) / n == x / n + y / n)\n                || (n <= z < 2 * n && (x + y) / n == x / n + y / n + 1))\n    {\n      var f := (xx:int, yy:int) =>\n          (var z := (xx % n) + (yy % n);\n           (   (0 <= z < n && (xx + yy) / n == xx / n + yy / n)\n               || (n <= z < 2 * n && (xx + yy) / n == xx / n + yy / n + 1)));\n      forall i, j\n        ensures j >= 0 && f(i, j) ==> f(i, j + n)\n        ensures i < n  && f(i, j) ==> f(i - n, j)\n        ensures j < n  && f(i, j) ==> f(i, j - n)\n        ensures i >= 0 && f(i, j) ==> f(i + n, j)\n      {\n        assert ((i + n) + j) / n == ((i + j) + n) / n;\n        assert (i + (j + n)) / n == ((i + j) + n) / n;\n        assert ((i - n) + j) / n == ((i + j) - n) / n;\n        assert (i + (j - n)) / n == ((i + j) - n) / n;\n      }\n      forall i, j\n        ensures 0 <= i < n && 0 <= j < n ==> f(i, j)\n      {\n        assert ((i + n) + j) / n == ((i + j) + n) / n;\n        assert (i + (j + n)) / n == ((i + j) + n) / n;\n        assert ((i - n) + j) / n == ((i + j) - n) / n;\n        assert (i + (j - n)) / n == ((i + j) - n) / n;\n      }\n      LemmaModInductionForall2(n, f);\n          }\n    forall x:int, y:int {:trigger (x - y) / n}\n      ensures  var z := (x % n) - (y % n);\n               (|| (0 <= z < n && (x - y) / n == x / n - y / n)\n                || (-n <= z < 0 && (x - y) / n == x / n - y / n - 1))\n    {\n      var f := (xx:int, yy:int) =>\n          (var z := (xx % n) - (yy % n);\n           (   (0 <= z < n && (xx - yy) / n == xx / n - yy / n)\n               || (-n <= z < 0 && (xx - yy) / n == xx / n - yy / n - 1)));\n      forall i, j\n        ensures j >= 0 && f(i, j) ==> f(i, j + n)\n        ensures i < n  && f(i, j) ==> f(i - n, j)\n        ensures j < n  && f(i, j) ==> f(i, j - n)\n        ensures i >= 0 && f(i, j) ==> f(i + n, j)\n      {\n        assert ((i + n) - j) / n == ((i - j) + n) / n;\n        assert (i - (j - n)) / n == ((i - j) + n) / n;\n        assert ((i - n) - j) / n == ((i - j) - n) / n;\n        assert (i - (j + n)) / n == ((i - j) - n) / n;\n      }\n      forall i, j\n        ensures 0 <= i < n && 0 <= j < n ==> f(i, j)\n      {\n        assert ((i + n) - j) / n == ((i - j) + n) / n;\n        assert (i - (j - n)) / n == ((i - j) + n) / n;\n        assert ((i - n) - j) / n == ((i - j) - n) / n;\n        assert (i - (j + n)) / n == ((i - j) - n) / n;\n      }\n      LemmaModInductionForall2(n, f);\n      assert f(x, y);\n    }\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "180",
        "method_filepath": "./src/NonlinearArithmetic/Internals/MulInternals.dfy",
        "method_without_assertion_filename": "LemmaMulInductionAutoForall_fix_180.dfy",
        "method_name": "LemmaMulInductionAutoForall",
        "method_content": "  lemma LemmaMulInductionAutoForall(f: int -> bool)\n    requires MulAuto() ==> f(0)\n                           && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + 1))\n                           && (forall i {:trigger IsLe(i, 0)} :: IsLe(i, 0) && f(i) ==> f(i - 1))\n    ensures  MulAuto()\n    ensures  forall i {:trigger f(i)} :: f(i)\n  {\n    LemmaMulCommutes();\n    LemmaMulDistributes();\n    assert forall i {:trigger f(i)} :: IsLe(0, i) && f(i) ==> f(i + 1);\n    assert forall i {:trigger f(i)} :: IsLe(i, 0) && f(i) ==> f(i - 1);\n    LemmaMulInduction(f);\n  }\n",
        "method_without_assertion_content": "  lemma LemmaMulInductionAutoForall(f: int -> bool)\n    requires MulAuto() ==> f(0)\n                           && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + 1))\n                           && (forall i {:trigger IsLe(i, 0)} :: IsLe(i, 0) && f(i) ==> f(i - 1))\n    ensures  MulAuto()\n    ensures  forall i {:trigger f(i)} :: f(i)\n  {\n    LemmaMulCommutes();\n    LemmaMulDistributes();\n        assert forall i {:trigger f(i)} :: IsLe(i, 0) && f(i) ==> f(i - 1);\n    LemmaMulInduction(f);\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "181",
        "method_filepath": "./src/NonlinearArithmetic/Internals/MulInternals.dfy",
        "method_without_assertion_filename": "LemmaMulInductionAutoForall_fix_181.dfy",
        "method_name": "LemmaMulInductionAutoForall",
        "method_content": "  lemma LemmaMulInductionAutoForall(f: int -> bool)\n    requires MulAuto() ==> f(0)\n                           && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + 1))\n                           && (forall i {:trigger IsLe(i, 0)} :: IsLe(i, 0) && f(i) ==> f(i - 1))\n    ensures  MulAuto()\n    ensures  forall i {:trigger f(i)} :: f(i)\n  {\n    LemmaMulCommutes();\n    LemmaMulDistributes();\n    assert forall i {:trigger f(i)} :: IsLe(0, i) && f(i) ==> f(i + 1);\n    assert forall i {:trigger f(i)} :: IsLe(i, 0) && f(i) ==> f(i - 1);\n    LemmaMulInduction(f);\n  }\n",
        "method_without_assertion_content": "  lemma LemmaMulInductionAutoForall(f: int -> bool)\n    requires MulAuto() ==> f(0)\n                           && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + 1))\n                           && (forall i {:trigger IsLe(i, 0)} :: IsLe(i, 0) && f(i) ==> f(i - 1))\n    ensures  MulAuto()\n    ensures  forall i {:trigger f(i)} :: f(i)\n  {\n    LemmaMulCommutes();\n    LemmaMulDistributes();\n    assert forall i {:trigger f(i)} :: IsLe(0, i) && f(i) ==> f(i + 1);\n        LemmaMulInduction(f);\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "182",
        "method_filepath": "./src/NonlinearArithmetic/Internals/MulInternals.dfy",
        "method_without_assertion_filename": "LemmaMulInductionAuto_fix_182.dfy",
        "method_name": "LemmaMulInductionAuto",
        "method_content": "  lemma LemmaMulInductionAuto(x: int, f: int -> bool)\n    requires MulAuto() ==> f(0)\n                           && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + 1))\n                           && (forall i {:trigger IsLe(i, 0)} :: IsLe(i, 0) && f(i) ==> f(i - 1))\n    ensures  MulAuto()\n    ensures  f(x)\n  {\n    LemmaMulCommutes();\n    LemmaMulDistributes();\n    assert forall i {:trigger f(i)} :: IsLe(0, i) && f(i) ==> f(i + 1);\n    assert forall i {:trigger f(i)} :: IsLe(i, 0) && f(i) ==> f(i - 1);\n    LemmaMulInduction(f);\n    assert f(x);\n  }\n",
        "method_without_assertion_content": "  lemma LemmaMulInductionAuto(x: int, f: int -> bool)\n    requires MulAuto() ==> f(0)\n                           && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + 1))\n                           && (forall i {:trigger IsLe(i, 0)} :: IsLe(i, 0) && f(i) ==> f(i - 1))\n    ensures  MulAuto()\n    ensures  f(x)\n  {\n    LemmaMulCommutes();\n    LemmaMulDistributes();\n        assert forall i {:trigger f(i)} :: IsLe(i, 0) && f(i) ==> f(i - 1);\n    LemmaMulInduction(f);\n    assert f(x);\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "183",
        "method_filepath": "./src/NonlinearArithmetic/Internals/MulInternals.dfy",
        "method_without_assertion_filename": "LemmaMulInductionAuto_fix_183.dfy",
        "method_name": "LemmaMulInductionAuto",
        "method_content": "  lemma LemmaMulInductionAuto(x: int, f: int -> bool)\n    requires MulAuto() ==> f(0)\n                           && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + 1))\n                           && (forall i {:trigger IsLe(i, 0)} :: IsLe(i, 0) && f(i) ==> f(i - 1))\n    ensures  MulAuto()\n    ensures  f(x)\n  {\n    LemmaMulCommutes();\n    LemmaMulDistributes();\n    assert forall i {:trigger f(i)} :: IsLe(0, i) && f(i) ==> f(i + 1);\n    assert forall i {:trigger f(i)} :: IsLe(i, 0) && f(i) ==> f(i - 1);\n    LemmaMulInduction(f);\n    assert f(x);\n  }\n",
        "method_without_assertion_content": "  lemma LemmaMulInductionAuto(x: int, f: int -> bool)\n    requires MulAuto() ==> f(0)\n                           && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + 1))\n                           && (forall i {:trigger IsLe(i, 0)} :: IsLe(i, 0) && f(i) ==> f(i - 1))\n    ensures  MulAuto()\n    ensures  f(x)\n  {\n    LemmaMulCommutes();\n    LemmaMulDistributes();\n    assert forall i {:trigger f(i)} :: IsLe(0, i) && f(i) ==> f(i + 1);\n        LemmaMulInduction(f);\n    assert f(x);\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "185",
        "method_filepath": "./src/NonlinearArithmetic/Internals/MulInternals.dfy",
        "method_without_assertion_filename": "LemmaMulDistributes_fix_185.dfy",
        "method_name": "LemmaMulDistributes",
        "method_content": "  lemma LemmaMulDistributes()\n    ensures forall x:int, y:int, z:int {:trigger (x + y) * z} :: (x + y) * z == x * z + y * z\n    ensures forall x:int, y:int, z:int {:trigger (x - y) * z} :: (x - y) * z == x * z - y * z\n  {\n    LemmaMulSuccessor();\n    forall x:int, y:int, z:int\n      ensures (x + y) * z == x * z + y * z\n      ensures (x - y) * z == x * z - y * z\n    {\n      var f1 := i => (x + i) * z == x * z + i * z;\n      var f2 := i => (x - i) * z == x * z - i * z;\n      assert forall i {:trigger (x + (i + 1)) * z} :: (x + (i + 1)) * z == ((x + i) + 1) * z == (x + i) * z + z;\n      assert forall i {:trigger (x + (i - 1)) * z} :: (x + (i - 1)) * z == ((x + i) - 1) * z == (x + i) * z - z;\n      assert forall i {:trigger (x - (i + 1)) * z} :: (x - (i + 1)) * z == ((x - i) - 1) * z == (x - i) * z - z;\n      assert forall i {:trigger (x - (i - 1)) * z} :: (x - (i - 1)) * z == ((x - i) + 1) * z == (x - i) * z + z;\n      LemmaMulInduction(f1);\n      LemmaMulInduction(f2);\n      assert f1(y);\n      assert f2(y);\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LemmaMulDistributes()\n    ensures forall x:int, y:int, z:int {:trigger (x + y) * z} :: (x + y) * z == x * z + y * z\n    ensures forall x:int, y:int, z:int {:trigger (x - y) * z} :: (x - y) * z == x * z - y * z\n  {\n    LemmaMulSuccessor();\n    forall x:int, y:int, z:int\n      ensures (x + y) * z == x * z + y * z\n      ensures (x - y) * z == x * z - y * z\n    {\n      var f1 := i => (x + i) * z == x * z + i * z;\n      var f2 := i => (x - i) * z == x * z - i * z;\n            assert forall i {:trigger (x + (i - 1)) * z} :: (x + (i - 1)) * z == ((x + i) - 1) * z == (x + i) * z - z;\n      assert forall i {:trigger (x - (i + 1)) * z} :: (x - (i + 1)) * z == ((x - i) - 1) * z == (x - i) * z - z;\n      assert forall i {:trigger (x - (i - 1)) * z} :: (x - (i - 1)) * z == ((x - i) + 1) * z == (x - i) * z + z;\n      LemmaMulInduction(f1);\n      LemmaMulInduction(f2);\n      assert f1(y);\n      assert f2(y);\n    }\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "186",
        "method_filepath": "./src/NonlinearArithmetic/Internals/MulInternals.dfy",
        "method_without_assertion_filename": "LemmaMulDistributes_fix_186.dfy",
        "method_name": "LemmaMulDistributes",
        "method_content": "  lemma LemmaMulDistributes()\n    ensures forall x:int, y:int, z:int {:trigger (x + y) * z} :: (x + y) * z == x * z + y * z\n    ensures forall x:int, y:int, z:int {:trigger (x - y) * z} :: (x - y) * z == x * z - y * z\n  {\n    LemmaMulSuccessor();\n    forall x:int, y:int, z:int\n      ensures (x + y) * z == x * z + y * z\n      ensures (x - y) * z == x * z - y * z\n    {\n      var f1 := i => (x + i) * z == x * z + i * z;\n      var f2 := i => (x - i) * z == x * z - i * z;\n      assert forall i {:trigger (x + (i + 1)) * z} :: (x + (i + 1)) * z == ((x + i) + 1) * z == (x + i) * z + z;\n      assert forall i {:trigger (x + (i - 1)) * z} :: (x + (i - 1)) * z == ((x + i) - 1) * z == (x + i) * z - z;\n      assert forall i {:trigger (x - (i + 1)) * z} :: (x - (i + 1)) * z == ((x - i) - 1) * z == (x - i) * z - z;\n      assert forall i {:trigger (x - (i - 1)) * z} :: (x - (i - 1)) * z == ((x - i) + 1) * z == (x - i) * z + z;\n      LemmaMulInduction(f1);\n      LemmaMulInduction(f2);\n      assert f1(y);\n      assert f2(y);\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LemmaMulDistributes()\n    ensures forall x:int, y:int, z:int {:trigger (x + y) * z} :: (x + y) * z == x * z + y * z\n    ensures forall x:int, y:int, z:int {:trigger (x - y) * z} :: (x - y) * z == x * z - y * z\n  {\n    LemmaMulSuccessor();\n    forall x:int, y:int, z:int\n      ensures (x + y) * z == x * z + y * z\n      ensures (x - y) * z == x * z - y * z\n    {\n      var f1 := i => (x + i) * z == x * z + i * z;\n      var f2 := i => (x - i) * z == x * z - i * z;\n      assert forall i {:trigger (x + (i + 1)) * z} :: (x + (i + 1)) * z == ((x + i) + 1) * z == (x + i) * z + z;\n            assert forall i {:trigger (x - (i + 1)) * z} :: (x - (i + 1)) * z == ((x - i) - 1) * z == (x - i) * z - z;\n      assert forall i {:trigger (x - (i - 1)) * z} :: (x - (i - 1)) * z == ((x - i) + 1) * z == (x - i) * z + z;\n      LemmaMulInduction(f1);\n      LemmaMulInduction(f2);\n      assert f1(y);\n      assert f2(y);\n    }\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "187",
        "method_filepath": "./src/NonlinearArithmetic/Internals/MulInternals.dfy",
        "method_without_assertion_filename": "LemmaMulDistributes_fix_187.dfy",
        "method_name": "LemmaMulDistributes",
        "method_content": "  lemma LemmaMulDistributes()\n    ensures forall x:int, y:int, z:int {:trigger (x + y) * z} :: (x + y) * z == x * z + y * z\n    ensures forall x:int, y:int, z:int {:trigger (x - y) * z} :: (x - y) * z == x * z - y * z\n  {\n    LemmaMulSuccessor();\n    forall x:int, y:int, z:int\n      ensures (x + y) * z == x * z + y * z\n      ensures (x - y) * z == x * z - y * z\n    {\n      var f1 := i => (x + i) * z == x * z + i * z;\n      var f2 := i => (x - i) * z == x * z - i * z;\n      assert forall i {:trigger (x + (i + 1)) * z} :: (x + (i + 1)) * z == ((x + i) + 1) * z == (x + i) * z + z;\n      assert forall i {:trigger (x + (i - 1)) * z} :: (x + (i - 1)) * z == ((x + i) - 1) * z == (x + i) * z - z;\n      assert forall i {:trigger (x - (i + 1)) * z} :: (x - (i + 1)) * z == ((x - i) - 1) * z == (x - i) * z - z;\n      assert forall i {:trigger (x - (i - 1)) * z} :: (x - (i - 1)) * z == ((x - i) + 1) * z == (x - i) * z + z;\n      LemmaMulInduction(f1);\n      LemmaMulInduction(f2);\n      assert f1(y);\n      assert f2(y);\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LemmaMulDistributes()\n    ensures forall x:int, y:int, z:int {:trigger (x + y) * z} :: (x + y) * z == x * z + y * z\n    ensures forall x:int, y:int, z:int {:trigger (x - y) * z} :: (x - y) * z == x * z - y * z\n  {\n    LemmaMulSuccessor();\n    forall x:int, y:int, z:int\n      ensures (x + y) * z == x * z + y * z\n      ensures (x - y) * z == x * z - y * z\n    {\n      var f1 := i => (x + i) * z == x * z + i * z;\n      var f2 := i => (x - i) * z == x * z - i * z;\n      assert forall i {:trigger (x + (i + 1)) * z} :: (x + (i + 1)) * z == ((x + i) + 1) * z == (x + i) * z + z;\n      assert forall i {:trigger (x + (i - 1)) * z} :: (x + (i - 1)) * z == ((x + i) - 1) * z == (x + i) * z - z;\n            assert forall i {:trigger (x - (i - 1)) * z} :: (x - (i - 1)) * z == ((x - i) + 1) * z == (x - i) * z + z;\n      LemmaMulInduction(f1);\n      LemmaMulInduction(f2);\n      assert f1(y);\n      assert f2(y);\n    }\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "188",
        "method_filepath": "./src/NonlinearArithmetic/Internals/MulInternals.dfy",
        "method_without_assertion_filename": "LemmaMulDistributes_fix_188.dfy",
        "method_name": "LemmaMulDistributes",
        "method_content": "  lemma LemmaMulDistributes()\n    ensures forall x:int, y:int, z:int {:trigger (x + y) * z} :: (x + y) * z == x * z + y * z\n    ensures forall x:int, y:int, z:int {:trigger (x - y) * z} :: (x - y) * z == x * z - y * z\n  {\n    LemmaMulSuccessor();\n    forall x:int, y:int, z:int\n      ensures (x + y) * z == x * z + y * z\n      ensures (x - y) * z == x * z - y * z\n    {\n      var f1 := i => (x + i) * z == x * z + i * z;\n      var f2 := i => (x - i) * z == x * z - i * z;\n      assert forall i {:trigger (x + (i + 1)) * z} :: (x + (i + 1)) * z == ((x + i) + 1) * z == (x + i) * z + z;\n      assert forall i {:trigger (x + (i - 1)) * z} :: (x + (i - 1)) * z == ((x + i) - 1) * z == (x + i) * z - z;\n      assert forall i {:trigger (x - (i + 1)) * z} :: (x - (i + 1)) * z == ((x - i) - 1) * z == (x - i) * z - z;\n      assert forall i {:trigger (x - (i - 1)) * z} :: (x - (i - 1)) * z == ((x - i) + 1) * z == (x - i) * z + z;\n      LemmaMulInduction(f1);\n      LemmaMulInduction(f2);\n      assert f1(y);\n      assert f2(y);\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LemmaMulDistributes()\n    ensures forall x:int, y:int, z:int {:trigger (x + y) * z} :: (x + y) * z == x * z + y * z\n    ensures forall x:int, y:int, z:int {:trigger (x - y) * z} :: (x - y) * z == x * z - y * z\n  {\n    LemmaMulSuccessor();\n    forall x:int, y:int, z:int\n      ensures (x + y) * z == x * z + y * z\n      ensures (x - y) * z == x * z - y * z\n    {\n      var f1 := i => (x + i) * z == x * z + i * z;\n      var f2 := i => (x - i) * z == x * z - i * z;\n      assert forall i {:trigger (x + (i + 1)) * z} :: (x + (i + 1)) * z == ((x + i) + 1) * z == (x + i) * z + z;\n      assert forall i {:trigger (x + (i - 1)) * z} :: (x + (i - 1)) * z == ((x + i) - 1) * z == (x + i) * z - z;\n      assert forall i {:trigger (x - (i + 1)) * z} :: (x - (i + 1)) * z == ((x - i) - 1) * z == (x - i) * z - z;\n            LemmaMulInduction(f1);\n      LemmaMulInduction(f2);\n      assert f1(y);\n      assert f2(y);\n    }\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "189",
        "method_filepath": "./src/NonlinearArithmetic/Internals/MulInternals.dfy",
        "method_without_assertion_filename": "LemmaMulDistributes_fix_189.dfy",
        "method_name": "LemmaMulDistributes",
        "method_content": "  lemma LemmaMulDistributes()\n    ensures forall x:int, y:int, z:int {:trigger (x + y) * z} :: (x + y) * z == x * z + y * z\n    ensures forall x:int, y:int, z:int {:trigger (x - y) * z} :: (x - y) * z == x * z - y * z\n  {\n    LemmaMulSuccessor();\n    forall x:int, y:int, z:int\n      ensures (x + y) * z == x * z + y * z\n      ensures (x - y) * z == x * z - y * z\n    {\n      var f1 := i => (x + i) * z == x * z + i * z;\n      var f2 := i => (x - i) * z == x * z - i * z;\n      assert forall i {:trigger (x + (i + 1)) * z} :: (x + (i + 1)) * z == ((x + i) + 1) * z == (x + i) * z + z;\n      assert forall i {:trigger (x + (i - 1)) * z} :: (x + (i - 1)) * z == ((x + i) - 1) * z == (x + i) * z - z;\n      assert forall i {:trigger (x - (i + 1)) * z} :: (x - (i + 1)) * z == ((x - i) - 1) * z == (x - i) * z - z;\n      assert forall i {:trigger (x - (i - 1)) * z} :: (x - (i - 1)) * z == ((x - i) + 1) * z == (x - i) * z + z;\n      LemmaMulInduction(f1);\n      LemmaMulInduction(f2);\n      assert f1(y);\n      assert f2(y);\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LemmaMulDistributes()\n    ensures forall x:int, y:int, z:int {:trigger (x + y) * z} :: (x + y) * z == x * z + y * z\n    ensures forall x:int, y:int, z:int {:trigger (x - y) * z} :: (x - y) * z == x * z - y * z\n  {\n    LemmaMulSuccessor();\n    forall x:int, y:int, z:int\n      ensures (x + y) * z == x * z + y * z\n      ensures (x - y) * z == x * z - y * z\n    {\n      var f1 := i => (x + i) * z == x * z + i * z;\n      var f2 := i => (x - i) * z == x * z - i * z;\n      assert forall i {:trigger (x + (i + 1)) * z} :: (x + (i + 1)) * z == ((x + i) + 1) * z == (x + i) * z + z;\n      assert forall i {:trigger (x + (i - 1)) * z} :: (x + (i - 1)) * z == ((x + i) - 1) * z == (x + i) * z - z;\n      assert forall i {:trigger (x - (i + 1)) * z} :: (x - (i + 1)) * z == ((x - i) - 1) * z == (x - i) * z - z;\n      assert forall i {:trigger (x - (i - 1)) * z} :: (x - (i - 1)) * z == ((x - i) + 1) * z == (x - i) * z + z;\n      LemmaMulInduction(f1);\n      LemmaMulInduction(f2);\n            assert f2(y);\n    }\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "190",
        "method_filepath": "./src/NonlinearArithmetic/Internals/MulInternals.dfy",
        "method_without_assertion_filename": "LemmaMulDistributes_fix_190.dfy",
        "method_name": "LemmaMulDistributes",
        "method_content": "  lemma LemmaMulDistributes()\n    ensures forall x:int, y:int, z:int {:trigger (x + y) * z} :: (x + y) * z == x * z + y * z\n    ensures forall x:int, y:int, z:int {:trigger (x - y) * z} :: (x - y) * z == x * z - y * z\n  {\n    LemmaMulSuccessor();\n    forall x:int, y:int, z:int\n      ensures (x + y) * z == x * z + y * z\n      ensures (x - y) * z == x * z - y * z\n    {\n      var f1 := i => (x + i) * z == x * z + i * z;\n      var f2 := i => (x - i) * z == x * z - i * z;\n      assert forall i {:trigger (x + (i + 1)) * z} :: (x + (i + 1)) * z == ((x + i) + 1) * z == (x + i) * z + z;\n      assert forall i {:trigger (x + (i - 1)) * z} :: (x + (i - 1)) * z == ((x + i) - 1) * z == (x + i) * z - z;\n      assert forall i {:trigger (x - (i + 1)) * z} :: (x - (i + 1)) * z == ((x - i) - 1) * z == (x - i) * z - z;\n      assert forall i {:trigger (x - (i - 1)) * z} :: (x - (i - 1)) * z == ((x - i) + 1) * z == (x - i) * z + z;\n      LemmaMulInduction(f1);\n      LemmaMulInduction(f2);\n      assert f1(y);\n      assert f2(y);\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LemmaMulDistributes()\n    ensures forall x:int, y:int, z:int {:trigger (x + y) * z} :: (x + y) * z == x * z + y * z\n    ensures forall x:int, y:int, z:int {:trigger (x - y) * z} :: (x - y) * z == x * z - y * z\n  {\n    LemmaMulSuccessor();\n    forall x:int, y:int, z:int\n      ensures (x + y) * z == x * z + y * z\n      ensures (x - y) * z == x * z - y * z\n    {\n      var f1 := i => (x + i) * z == x * z + i * z;\n      var f2 := i => (x - i) * z == x * z - i * z;\n      assert forall i {:trigger (x + (i + 1)) * z} :: (x + (i + 1)) * z == ((x + i) + 1) * z == (x + i) * z + z;\n      assert forall i {:trigger (x + (i - 1)) * z} :: (x + (i - 1)) * z == ((x + i) - 1) * z == (x + i) * z - z;\n      assert forall i {:trigger (x - (i + 1)) * z} :: (x - (i + 1)) * z == ((x - i) - 1) * z == (x - i) * z - z;\n      assert forall i {:trigger (x - (i - 1)) * z} :: (x - (i - 1)) * z == ((x - i) + 1) * z == (x - i) * z + z;\n      LemmaMulInduction(f1);\n      LemmaMulInduction(f2);\n      assert f1(y);\n          }\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "197",
        "method_filepath": "./src/NonlinearArithmetic/Internals/ModInternals.dfy",
        "method_without_assertion_filename": "LemmaModInductionAuto_fix_197.dfy",
        "method_name": "LemmaModInductionAuto",
        "method_content": "  lemma LemmaModInductionAuto(n: int, x: int, f: int -> bool)\n    requires n > 0\n    requires ModAuto(n) ==> && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i))\n                            && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + n))\n                            && (forall i {:trigger IsLe(i + 1, n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n))\n    ensures  ModAuto(n)\n    ensures  f(x)\n  {\n    LemmaModAuto(n);\n    assert forall i :: IsLe(0, i) && i < n ==> f(i);\n    assert forall i {:trigger f(i), f(i + n)} :: IsLe(0, i) && f(i) ==> f(i + n);\n    assert forall i {:trigger f(i), f(i - n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n);\n    LemmaModInductionForall(n, f);\n    assert f(x);\n  }\n",
        "method_without_assertion_content": "  lemma LemmaModInductionAuto(n: int, x: int, f: int -> bool)\n    requires n > 0\n    requires ModAuto(n) ==> && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i))\n                            && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + n))\n                            && (forall i {:trigger IsLe(i + 1, n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n))\n    ensures  ModAuto(n)\n    ensures  f(x)\n  {\n    LemmaModAuto(n);\n    assert forall i :: IsLe(0, i) && i < n ==> f(i);\n    assert forall i {:trigger f(i), f(i + n)} :: IsLe(0, i) && f(i) ==> f(i + n);\n        LemmaModInductionForall(n, f);\n    assert f(x);\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "199",
        "method_filepath": "./src/NonlinearArithmetic/Internals/ModInternals.dfy",
        "method_without_assertion_filename": "LemmaModInductionForall2_fix_199.dfy",
        "method_name": "LemmaModInductionForall2",
        "method_content": "  lemma LemmaModInductionForall2(n: int, f:(int, int)->bool)\n    requires n > 0\n    requires forall i, j :: 0 <= i < n && 0 <= j < n ==> f(i, j)\n    requires forall i, j {:trigger f(i, j), f(i + n, j)} :: i >= 0 && f(i, j) ==> f(i + n, j)\n    requires forall i, j {:trigger f(i, j), f(i, j + n)} :: j >= 0 && f(i, j) ==> f(i, j + n)\n    requires forall i, j {:trigger f(i, j), f(i - n, j)} :: i < n  && f(i, j) ==> f(i - n, j)\n    requires forall i, j {:trigger f(i, j), f(i, j - n)} :: j < n  && f(i, j) ==> f(i, j - n)\n    ensures  forall i, j :: f(i, j)\n  {\n    forall x, y\n      ensures f(x, y)\n    {\n      forall i | 0 <= i < n\n        ensures f(i, y)\n      {\n        var fj := j => f(i, j);\n        LemmaModInductionForall(n, fj);\n        assert fj(y);\n      }\n      var fi := i => f(i, y);\n      LemmaModInductionForall(n, fi);\n      assert fi(x);\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LemmaModInductionForall2(n: int, f:(int, int)->bool)\n    requires n > 0\n    requires forall i, j :: 0 <= i < n && 0 <= j < n ==> f(i, j)\n    requires forall i, j {:trigger f(i, j), f(i + n, j)} :: i >= 0 && f(i, j) ==> f(i + n, j)\n    requires forall i, j {:trigger f(i, j), f(i, j + n)} :: j >= 0 && f(i, j) ==> f(i, j + n)\n    requires forall i, j {:trigger f(i, j), f(i - n, j)} :: i < n  && f(i, j) ==> f(i - n, j)\n    requires forall i, j {:trigger f(i, j), f(i, j - n)} :: j < n  && f(i, j) ==> f(i, j - n)\n    ensures  forall i, j :: f(i, j)\n  {\n    forall x, y\n      ensures f(x, y)\n    {\n      forall i | 0 <= i < n\n        ensures f(i, y)\n      {\n        var fj := j => f(i, j);\n        LemmaModInductionForall(n, fj);\n              }\n      var fi := i => f(i, y);\n      LemmaModInductionForall(n, fi);\n      assert fi(x);\n    }\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "200",
        "method_filepath": "./src/NonlinearArithmetic/Internals/ModInternals.dfy",
        "method_without_assertion_filename": "LemmaModInductionForall2_fix_200.dfy",
        "method_name": "LemmaModInductionForall2",
        "method_content": "  lemma LemmaModInductionForall2(n: int, f:(int, int)->bool)\n    requires n > 0\n    requires forall i, j :: 0 <= i < n && 0 <= j < n ==> f(i, j)\n    requires forall i, j {:trigger f(i, j), f(i + n, j)} :: i >= 0 && f(i, j) ==> f(i + n, j)\n    requires forall i, j {:trigger f(i, j), f(i, j + n)} :: j >= 0 && f(i, j) ==> f(i, j + n)\n    requires forall i, j {:trigger f(i, j), f(i - n, j)} :: i < n  && f(i, j) ==> f(i - n, j)\n    requires forall i, j {:trigger f(i, j), f(i, j - n)} :: j < n  && f(i, j) ==> f(i, j - n)\n    ensures  forall i, j :: f(i, j)\n  {\n    forall x, y\n      ensures f(x, y)\n    {\n      forall i | 0 <= i < n\n        ensures f(i, y)\n      {\n        var fj := j => f(i, j);\n        LemmaModInductionForall(n, fj);\n        assert fj(y);\n      }\n      var fi := i => f(i, y);\n      LemmaModInductionForall(n, fi);\n      assert fi(x);\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LemmaModInductionForall2(n: int, f:(int, int)->bool)\n    requires n > 0\n    requires forall i, j :: 0 <= i < n && 0 <= j < n ==> f(i, j)\n    requires forall i, j {:trigger f(i, j), f(i + n, j)} :: i >= 0 && f(i, j) ==> f(i + n, j)\n    requires forall i, j {:trigger f(i, j), f(i, j + n)} :: j >= 0 && f(i, j) ==> f(i, j + n)\n    requires forall i, j {:trigger f(i, j), f(i - n, j)} :: i < n  && f(i, j) ==> f(i - n, j)\n    requires forall i, j {:trigger f(i, j), f(i, j - n)} :: j < n  && f(i, j) ==> f(i, j - n)\n    ensures  forall i, j :: f(i, j)\n  {\n    forall x, y\n      ensures f(x, y)\n    {\n      forall i | 0 <= i < n\n        ensures f(i, y)\n      {\n        var fj := j => f(i, j);\n        LemmaModInductionForall(n, fj);\n        assert fj(y);\n      }\n      var fi := i => f(i, y);\n      LemmaModInductionForall(n, fi);\n          }\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "201",
        "method_filepath": "./src/NonlinearArithmetic/Internals/ModInternals.dfy",
        "method_without_assertion_filename": "LemmaModInductionAutoForall_fix_201.dfy",
        "method_name": "LemmaModInductionAutoForall",
        "method_content": "  lemma LemmaModInductionAutoForall(n: int, f: int -> bool)\n    requires n > 0\n    requires ModAuto(n) ==> && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i))\n                            && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + n))\n                            && (forall i {:trigger IsLe(i + 1, n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n))\n    ensures  ModAuto(n)\n    ensures  forall i {:trigger f(i)} :: f(i)\n  {\n    LemmaModAuto(n);\n    assert forall i :: IsLe(0, i) && i < n ==> f(i);\n    assert forall i {:trigger f(i), f(i + n)} :: IsLe(0, i) && f(i) ==> f(i + n);\n    assert forall i {:trigger f(i), f(i - n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n);\n    LemmaModInductionForall(n, f);\n  }\n",
        "method_without_assertion_content": "  lemma LemmaModInductionAutoForall(n: int, f: int -> bool)\n    requires n > 0\n    requires ModAuto(n) ==> && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i))\n                            && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + n))\n                            && (forall i {:trigger IsLe(i + 1, n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n))\n    ensures  ModAuto(n)\n    ensures  forall i {:trigger f(i)} :: f(i)\n  {\n    LemmaModAuto(n);\n        assert forall i {:trigger f(i), f(i + n)} :: IsLe(0, i) && f(i) ==> f(i + n);\n    assert forall i {:trigger f(i), f(i - n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n);\n    LemmaModInductionForall(n, f);\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "202",
        "method_filepath": "./src/NonlinearArithmetic/Internals/ModInternals.dfy",
        "method_without_assertion_filename": "LemmaModInductionAutoForall_fix_202.dfy",
        "method_name": "LemmaModInductionAutoForall",
        "method_content": "  lemma LemmaModInductionAutoForall(n: int, f: int -> bool)\n    requires n > 0\n    requires ModAuto(n) ==> && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i))\n                            && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + n))\n                            && (forall i {:trigger IsLe(i + 1, n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n))\n    ensures  ModAuto(n)\n    ensures  forall i {:trigger f(i)} :: f(i)\n  {\n    LemmaModAuto(n);\n    assert forall i :: IsLe(0, i) && i < n ==> f(i);\n    assert forall i {:trigger f(i), f(i + n)} :: IsLe(0, i) && f(i) ==> f(i + n);\n    assert forall i {:trigger f(i), f(i - n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n);\n    LemmaModInductionForall(n, f);\n  }\n",
        "method_without_assertion_content": "  lemma LemmaModInductionAutoForall(n: int, f: int -> bool)\n    requires n > 0\n    requires ModAuto(n) ==> && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i))\n                            && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + n))\n                            && (forall i {:trigger IsLe(i + 1, n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n))\n    ensures  ModAuto(n)\n    ensures  forall i {:trigger f(i)} :: f(i)\n  {\n    LemmaModAuto(n);\n    assert forall i :: IsLe(0, i) && i < n ==> f(i);\n        assert forall i {:trigger f(i), f(i - n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n);\n    LemmaModInductionForall(n, f);\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "203",
        "method_filepath": "./src/NonlinearArithmetic/Internals/ModInternals.dfy",
        "method_without_assertion_filename": "LemmaModInductionAutoForall_fix_203.dfy",
        "method_name": "LemmaModInductionAutoForall",
        "method_content": "  lemma LemmaModInductionAutoForall(n: int, f: int -> bool)\n    requires n > 0\n    requires ModAuto(n) ==> && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i))\n                            && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + n))\n                            && (forall i {:trigger IsLe(i + 1, n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n))\n    ensures  ModAuto(n)\n    ensures  forall i {:trigger f(i)} :: f(i)\n  {\n    LemmaModAuto(n);\n    assert forall i :: IsLe(0, i) && i < n ==> f(i);\n    assert forall i {:trigger f(i), f(i + n)} :: IsLe(0, i) && f(i) ==> f(i + n);\n    assert forall i {:trigger f(i), f(i - n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n);\n    LemmaModInductionForall(n, f);\n  }\n",
        "method_without_assertion_content": "  lemma LemmaModInductionAutoForall(n: int, f: int -> bool)\n    requires n > 0\n    requires ModAuto(n) ==> && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i))\n                            && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + n))\n                            && (forall i {:trigger IsLe(i + 1, n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n))\n    ensures  ModAuto(n)\n    ensures  forall i {:trigger f(i)} :: f(i)\n  {\n    LemmaModAuto(n);\n    assert forall i :: IsLe(0, i) && i < n ==> f(i);\n    assert forall i {:trigger f(i), f(i + n)} :: IsLe(0, i) && f(i) ==> f(i + n);\n        LemmaModInductionForall(n, f);\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "204",
        "method_filepath": "./src/Unicode/UnicodeEncodingForm.dfy",
        "method_without_assertion_filename": "LemmaSplitPrefixMinimalWellFormedCodeUnitSubsequenceInvertsPrepend_fix_204.dfy",
        "method_name": "LemmaSplitPrefixMinimalWellFormedCodeUnitSubsequenceInvertsPrepend",
        "method_content": "  lemma LemmaSplitPrefixMinimalWellFormedCodeUnitSubsequenceInvertsPrepend(m: MinimalWellFormedCodeUnitSeq, s: CodeUnitSeq)\n    ensures SplitPrefixMinimalWellFormedCodeUnitSubsequence(m + s) == Some(m)\n  {\n    var ms := m + s;\n    assert IsMinimalWellFormedCodeUnitSubsequence(ms[..|m|]);\n    var prefix := SplitPrefixMinimalWellFormedCodeUnitSubsequence(ms).Extract();\n    calc ==> {\n      IsMinimalWellFormedCodeUnitSubsequence(m);\n      |prefix| <= |m|;\n      prefix == ms[..|prefix|] == m[..|prefix|] == m;\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LemmaSplitPrefixMinimalWellFormedCodeUnitSubsequenceInvertsPrepend(m: MinimalWellFormedCodeUnitSeq, s: CodeUnitSeq)\n    ensures SplitPrefixMinimalWellFormedCodeUnitSubsequence(m + s) == Some(m)\n  {\n    var ms := m + s;\n        var prefix := SplitPrefixMinimalWellFormedCodeUnitSubsequence(ms).Extract();\n    calc ==> {\n      IsMinimalWellFormedCodeUnitSubsequence(m);\n      |prefix| <= |m|;\n      prefix == ms[..|prefix|] == m[..|prefix|] == m;\n    }\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "211",
        "method_filepath": "./src/dafny/BinaryOperations.dfy",
        "method_without_assertion_filename": "MonoidInverseIsUnique_fix_211.dfy",
        "method_name": "MonoidInverseIsUnique",
        "method_content": "  lemma MonoidInverseIsUnique<T(!new)>(m: Monoid<T>, inverse1: T -> T, inverse2: T -> T)\n    requires IsInverse(m.bop, inverse1, m.unit)\n    requires IsInverse(m.bop, inverse2, m.unit)\n    ensures forall x :: inverse1(x) == inverse2(x)\n  {\n    assert IsMonoid(m.bop, m.unit);\n    forall x ensures inverse1(x) == inverse2(x) {\n      calc {\n        inverse1(x);\n      == { assert IsRightUnital(m.bop, m.unit); }\n        m.bop(inverse1(x), m.unit);\n      == { assert IsRightInverse(m.bop, inverse2, m.unit); assert m.unit == m.bop(x, inverse2(x)); }\n        m.bop(inverse1(x), m.bop(x, inverse2(x)));\n      == { assert IsAssociative(m.bop); }\n        m.bop(m.bop(inverse1(x), x), inverse2(x));\n      == { assert IsLeftInverse(m.bop, inverse1, m.unit); }\n        m.bop(m.unit, inverse2(x));\n      == { assert IsLeftUnital(m.bop, m.unit); }\n        inverse2(x);\n      }\n    }\n  }\n",
        "method_without_assertion_content": "  lemma MonoidInverseIsUnique<T(!new)>(m: Monoid<T>, inverse1: T -> T, inverse2: T -> T)\n    requires IsInverse(m.bop, inverse1, m.unit)\n    requires IsInverse(m.bop, inverse2, m.unit)\n    ensures forall x :: inverse1(x) == inverse2(x)\n  {\n        forall x ensures inverse1(x) == inverse2(x) {\n      calc {\n        inverse1(x);\n      == { assert IsRightUnital(m.bop, m.unit); }\n        m.bop(inverse1(x), m.unit);\n      == { assert IsRightInverse(m.bop, inverse2, m.unit); assert m.unit == m.bop(x, inverse2(x)); }\n        m.bop(inverse1(x), m.bop(x, inverse2(x)));\n      == { assert IsAssociative(m.bop); }\n        m.bop(m.bop(inverse1(x), x), inverse2(x));\n      == { assert IsLeftInverse(m.bop, inverse1, m.unit); }\n        m.bop(m.unit, inverse2(x));\n      == { assert IsLeftUnital(m.bop, m.unit); }\n        inverse2(x);\n      }\n    }\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "378",
        "method_filepath": "./src/dafny/NonlinearArithmetic/Internals/ModInternals.dfy",
        "method_without_assertion_filename": "LemmaModInductionAuto_fix_378.dfy",
        "method_name": "LemmaModInductionAuto",
        "method_content": "  lemma LemmaModInductionAuto(n: int, x: int, f: int -> bool)\n    requires n > 0\n    requires ModAuto(n) ==> && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i))\n                            && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + n))\n                            && (forall i {:trigger IsLe(i + 1, n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n))\n    ensures  ModAuto(n)\n    ensures  f(x)\n  {\n    LemmaModAuto(n);\n    assert forall i :: IsLe(0, i) && i < n ==> f(i);\n    assert forall i {:trigger f(i), f(i + n)} :: IsLe(0, i) && f(i) ==> f(i + n);\n    assert forall i {:trigger f(i), f(i - n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n);\n    LemmaModInductionForall(n, f);\n    assert f(x);\n  }\n",
        "method_without_assertion_content": "  lemma LemmaModInductionAuto(n: int, x: int, f: int -> bool)\n    requires n > 0\n    requires ModAuto(n) ==> && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i))\n                            && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + n))\n                            && (forall i {:trigger IsLe(i + 1, n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n))\n    ensures  ModAuto(n)\n    ensures  f(x)\n  {\n    LemmaModAuto(n);\n        assert forall i {:trigger f(i), f(i + n)} :: IsLe(0, i) && f(i) ==> f(i + n);\n    assert forall i {:trigger f(i), f(i - n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n);\n    LemmaModInductionForall(n, f);\n    assert f(x);\n  }\n"
    },
    {
        "benchmark_name": "libraries",
        "index": "379",
        "method_filepath": "./src/dafny/NonlinearArithmetic/Internals/ModInternals.dfy",
        "method_without_assertion_filename": "LemmaModInductionAuto_fix_379.dfy",
        "method_name": "LemmaModInductionAuto",
        "method_content": "  lemma LemmaModInductionAuto(n: int, x: int, f: int -> bool)\n    requires n > 0\n    requires ModAuto(n) ==> && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i))\n                            && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + n))\n                            && (forall i {:trigger IsLe(i + 1, n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n))\n    ensures  ModAuto(n)\n    ensures  f(x)\n  {\n    LemmaModAuto(n);\n    assert forall i :: IsLe(0, i) && i < n ==> f(i);\n    assert forall i {:trigger f(i), f(i + n)} :: IsLe(0, i) && f(i) ==> f(i + n);\n    assert forall i {:trigger f(i), f(i - n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n);\n    LemmaModInductionForall(n, f);\n    assert f(x);\n  }\n",
        "method_without_assertion_content": "  lemma LemmaModInductionAuto(n: int, x: int, f: int -> bool)\n    requires n > 0\n    requires ModAuto(n) ==> && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i))\n                            && (forall i {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + n))\n                            && (forall i {:trigger IsLe(i + 1, n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n))\n    ensures  ModAuto(n)\n    ensures  f(x)\n  {\n    LemmaModAuto(n);\n    assert forall i :: IsLe(0, i) && i < n ==> f(i);\n        assert forall i {:trigger f(i), f(i - n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n);\n    LemmaModInductionForall(n, f);\n    assert f(x);\n  }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "891",
        "method_filepath": "./cedar-dafny/def/ext/ipaddr.dfy",
        "method_without_assertion_filename": "CountDCComp_fix_891.dfy",
        "method_name": "CountDCComp",
        "method_content": "  lemma CountDCComp(l: seq<SegV6>, r: seq<SegV6>)\n    ensures countDC(l+r) == countDC(l)+countDC(r)\n  {\n    if |l| == 0 {\n      assert l + r == r;\n    } else {\n      assert l + r == [l[0]] + (l[1..] + r);\n    }\n  }\n",
        "method_without_assertion_content": "  lemma CountDCComp(l: seq<SegV6>, r: seq<SegV6>)\n    ensures countDC(l+r) == countDC(l)+countDC(r)\n  {\n    if |l| == 0 {\n          } else {\n      assert l + r == [l[0]] + (l[1..] + r);\n    }\n  }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "443",
        "method_filepath": "./cedar-dafny/validation/thm/soundness.dfy",
        "method_without_assertion_filename": "SoundEqAuxDiffUids_fix_443.dfy",
        "method_name": "SoundEqAuxDiffUids",
        "method_content": "    lemma SoundEqAuxDiffUids(u1: EntityUID, u2: EntityUID, t: Type, effs: Effects)\n      requires Typesafe(BinaryApp(BinaryOp.Eq,PrimitiveLit(Primitive.EntityUID(u1)),PrimitiveLit(Primitive.EntityUID(u2))),effs,t)\n      requires u1 != u2\n      ensures IsSafe(r,s,BinaryApp(BinaryOp.Eq,PrimitiveLit(Primitive.EntityUID(u1)),PrimitiveLit(Primitive.EntityUID(u2))),t) {\n      var e1: Expr := PrimitiveLit(Primitive.EntityUID(u1));\n      var e2: Expr := PrimitiveLit(Primitive.EntityUID(u2));\n      var t' :| getType(BinaryApp(BinaryOp.Eq,e1,e2),effs) == t' && subty(t',t,ValidationMode.Permissive);\n      assert TC.inferEq(e1,e2,effs) == types.Ok(t');\n      // Somehow, these unused variables help nudge Dafny to complete the proof.\n      var t1 := getType(e1,effs);\n      var t2 := getType(e2,effs);\n      assert t' == Type.Bool(False);\n      assert IsSafe(r,s,BinaryApp(BinaryOp.Eq,e1,e2),t') by { EqEntityDiffSafe(r,s,u1,u2); }\n      assert IsSafe(r,s,BinaryApp(BinaryOp.Eq,e1,e2),t) by {\n        SubtyCompat(t',t);\n        SemSubtyTransport(r,s,BinaryApp(BinaryOp.Eq,e1,e2),t',t); }\n    }\n",
        "method_without_assertion_content": "    lemma SoundEqAuxDiffUids(u1: EntityUID, u2: EntityUID, t: Type, effs: Effects)\n      requires Typesafe(BinaryApp(BinaryOp.Eq,PrimitiveLit(Primitive.EntityUID(u1)),PrimitiveLit(Primitive.EntityUID(u2))),effs,t)\n      requires u1 != u2\n      ensures IsSafe(r,s,BinaryApp(BinaryOp.Eq,PrimitiveLit(Primitive.EntityUID(u1)),PrimitiveLit(Primitive.EntityUID(u2))),t) {\n      var e1: Expr := PrimitiveLit(Primitive.EntityUID(u1));\n      var e2: Expr := PrimitiveLit(Primitive.EntityUID(u2));\n      var t' :| getType(BinaryApp(BinaryOp.Eq,e1,e2),effs) == t' && subty(t',t,ValidationMode.Permissive);\n            // Somehow, these unused variables help nudge Dafny to complete the proof.\n      var t1 := getType(e1,effs);\n      var t2 := getType(e2,effs);\n      assert t' == Type.Bool(False);\n      assert IsSafe(r,s,BinaryApp(BinaryOp.Eq,e1,e2),t') by { EqEntityDiffSafe(r,s,u1,u2); }\n      assert IsSafe(r,s,BinaryApp(BinaryOp.Eq,e1,e2),t) by {\n        SubtyCompat(t',t);\n        SemSubtyTransport(r,s,BinaryApp(BinaryOp.Eq,e1,e2),t',t); }\n    }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "104",
        "method_filepath": "./cedar-dafny/validation/thm/model.dfy",
        "method_without_assertion_filename": "OrRShortSafe_fix_104.dfy",
        "method_name": "OrRShortSafe",
        "method_content": "  lemma OrRShortSafe(r: Request, s: EntityStore, e: Expr, e': Expr)\n    requires IsSafe(r,s,e,Type.Bool(AnyBool))\n    requires IsTrue(r,s,e')\n    ensures IsTrue(r,s,Or(e,e'))\n  {\n    reveal IsSafe();\n    if Evaluate(e,r,s).Ok? && Evaluate(e',r,s).Ok? {\n      assert Evaluate(e',r,s) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n      assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n      assert Evaluate(Or(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n    } else {\n      if Evaluate(e,r,s).Err? {\n        assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == Evaluate(e,r,s);\n        assert Evaluate(Or(e,e'),r,s) == Evaluate(e,r,s);\n      } else {\n        assert Evaluate(e',r,s).Err?;\n        var b :| Evaluate(e,r,s) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n        if b {\n          assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n          assert Evaluate(Or(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n        } else {\n          assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == Evaluate(e',r,s);\n          assert Evaluate(Or(e,e'),r,s) == Evaluate(e',r,s);\n        }\n      }\n    }\n  }\n",
        "method_without_assertion_content": "  lemma OrRShortSafe(r: Request, s: EntityStore, e: Expr, e': Expr)\n    requires IsSafe(r,s,e,Type.Bool(AnyBool))\n    requires IsTrue(r,s,e')\n    ensures IsTrue(r,s,Or(e,e'))\n  {\n    reveal IsSafe();\n    if Evaluate(e,r,s).Ok? && Evaluate(e',r,s).Ok? {\n      assert Evaluate(e',r,s) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n      assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n      assert Evaluate(Or(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n    } else {\n      if Evaluate(e,r,s).Err? {\n                assert Evaluate(Or(e,e'),r,s) == Evaluate(e,r,s);\n      } else {\n        assert Evaluate(e',r,s).Err?;\n        var b :| Evaluate(e,r,s) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n        if b {\n          assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n          assert Evaluate(Or(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n        } else {\n          assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == Evaluate(e',r,s);\n          assert Evaluate(Or(e,e'),r,s) == Evaluate(e',r,s);\n        }\n      }\n    }\n  }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "854",
        "method_filepath": "./cedar-dafny/validation/thm/strict_soundness.dfy",
        "method_without_assertion_filename": "StrictGetLubRecordType_fix_854.dfy",
        "method_name": "StrictGetLubRecordType",
        "method_content": "    lemma StrictGetLubRecordType(lub: EntityLUB)\n      requires ets.getLubRecordType(lub, ValidationMode.Strict).Ok?\n      ensures ets.getLubRecordType(lub, ValidationMode.Permissive) == ets.getLubRecordType(lub, ValidationMode.Strict)\n    {\n      if lub.AnyEntity? || exists et <- lub.tys :: isAction(et) {\n        assert ets.getLubRecordType(lub, ValidationMode.Permissive).Ok?;\n      } else {\n        assert forall et <- lub.tys :: et in ets.types;\n        def.util.EntityTypeLeqIsTotalOrder();\n        var lubSeq := def.util.SetToSortedSeq(lub.tys,def.util.EntityTypeLeq);\n        var s := seq (|lubSeq|, i requires 0 <= i < |lubSeq| => ets.types[lubSeq[i]]);\n        assert s != [];\n        assert lubRecordTypeSeq(s, ValidationMode.Strict) == lubRecordTypeSeq(s, ValidationMode.Permissive) by {\n          assert ets.getLubRecordType(lub, ValidationMode.Strict).Ok?;\n          StrictLubRecordTypeSeq(s);\n        }\n      }\n    }\n",
        "method_without_assertion_content": "    lemma StrictGetLubRecordType(lub: EntityLUB)\n      requires ets.getLubRecordType(lub, ValidationMode.Strict).Ok?\n      ensures ets.getLubRecordType(lub, ValidationMode.Permissive) == ets.getLubRecordType(lub, ValidationMode.Strict)\n    {\n      if lub.AnyEntity? || exists et <- lub.tys :: isAction(et) {\n              } else {\n        assert forall et <- lub.tys :: et in ets.types;\n        def.util.EntityTypeLeqIsTotalOrder();\n        var lubSeq := def.util.SetToSortedSeq(lub.tys,def.util.EntityTypeLeq);\n        var s := seq (|lubSeq|, i requires 0 <= i < |lubSeq| => ets.types[lubSeq[i]]);\n        assert s != [];\n        assert lubRecordTypeSeq(s, ValidationMode.Strict) == lubRecordTypeSeq(s, ValidationMode.Permissive) by {\n          assert ets.getLubRecordType(lub, ValidationMode.Strict).Ok?;\n          StrictLubRecordTypeSeq(s);\n        }\n      }\n    }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "94",
        "method_filepath": "./cedar-dafny/validation/thm/model.dfy",
        "method_without_assertion_filename": "OrRRetSafe_fix_94.dfy",
        "method_name": "OrRRetSafe",
        "method_content": "  lemma OrRRetSafe(r: Request, s: EntityStore, e: Expr, e': Expr, t: Type)\n    requires IsFalse(r,s,e)\n    requires IsSafe(r,s,e',t)\n    requires SemanticSubty(t,Type.Bool(AnyBool))\n    ensures IsSafe(r,s,Or(e,e'),t)\n  {\n    reveal IsSafe();\n    if Evaluate(e,r,s).Ok? && Evaluate(e',r,s).Ok? {\n      assert Evaluate(e,r,s) == base.Ok(Value.Primitive(Primitive.Bool(false)));\n      var v :| Evaluate(e',r,s) == base.Ok(v) && InstanceOfType(v,t);\n      assert InstanceOfType(v,Type.Bool(AnyBool)) by {\n        SemSubtyTransportVal(t,Type.Bool(AnyBool),v);\n      }\n      var b :| v == Value.Primitive(Primitive.Bool(b));\n      assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n      assert Evaluate(Or(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n      assert IsSafe(r,s,e',Type.Bool(AnyBool)) by {\n        SemSubtyTransport(r,s,e',t,Type.Bool(AnyBool));\n      }\n    } else {\n      if Evaluate(e,r,s).Err? {\n        assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == Evaluate(e,r,s);\n        assert Evaluate(Or(e,e'),r,s) == Evaluate(e,r,s);\n      } else {\n        assert Evaluate(e',r,s).Err?;\n        var b :| Evaluate(e,r,s) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n        if b {\n          assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n          assert Evaluate(Or(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n        } else {\n          assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == Evaluate(e',r,s);\n          assert Evaluate(Or(e,e'),r,s) == Evaluate(e',r,s);\n        }\n      }\n    }\n  }\n",
        "method_without_assertion_content": "  lemma OrRRetSafe(r: Request, s: EntityStore, e: Expr, e': Expr, t: Type)\n    requires IsFalse(r,s,e)\n    requires IsSafe(r,s,e',t)\n    requires SemanticSubty(t,Type.Bool(AnyBool))\n    ensures IsSafe(r,s,Or(e,e'),t)\n  {\n    reveal IsSafe();\n    if Evaluate(e,r,s).Ok? && Evaluate(e',r,s).Ok? {\n      assert Evaluate(e,r,s) == base.Ok(Value.Primitive(Primitive.Bool(false)));\n      var v :| Evaluate(e',r,s) == base.Ok(v) && InstanceOfType(v,t);\n      assert InstanceOfType(v,Type.Bool(AnyBool)) by {\n        SemSubtyTransportVal(t,Type.Bool(AnyBool),v);\n      }\n      var b :| v == Value.Primitive(Primitive.Bool(b));\n      assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n      assert Evaluate(Or(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n      assert IsSafe(r,s,e',Type.Bool(AnyBool)) by {\n        SemSubtyTransport(r,s,e',t,Type.Bool(AnyBool));\n      }\n    } else {\n      if Evaluate(e,r,s).Err? {\n                assert Evaluate(Or(e,e'),r,s) == Evaluate(e,r,s);\n      } else {\n        assert Evaluate(e',r,s).Err?;\n        var b :| Evaluate(e,r,s) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n        if b {\n          assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n          assert Evaluate(Or(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n        } else {\n          assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == Evaluate(e',r,s);\n          assert Evaluate(Or(e,e'),r,s) == Evaluate(e',r,s);\n        }\n      }\n    }\n  }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "109",
        "method_filepath": "./cedar-dafny/validation/thm/model.dfy",
        "method_without_assertion_filename": "OrRShortSafe_fix_109.dfy",
        "method_name": "OrRShortSafe",
        "method_content": "  lemma OrRShortSafe(r: Request, s: EntityStore, e: Expr, e': Expr)\n    requires IsSafe(r,s,e,Type.Bool(AnyBool))\n    requires IsTrue(r,s,e')\n    ensures IsTrue(r,s,Or(e,e'))\n  {\n    reveal IsSafe();\n    if Evaluate(e,r,s).Ok? && Evaluate(e',r,s).Ok? {\n      assert Evaluate(e',r,s) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n      assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n      assert Evaluate(Or(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n    } else {\n      if Evaluate(e,r,s).Err? {\n        assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == Evaluate(e,r,s);\n        assert Evaluate(Or(e,e'),r,s) == Evaluate(e,r,s);\n      } else {\n        assert Evaluate(e',r,s).Err?;\n        var b :| Evaluate(e,r,s) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n        if b {\n          assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n          assert Evaluate(Or(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n        } else {\n          assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == Evaluate(e',r,s);\n          assert Evaluate(Or(e,e'),r,s) == Evaluate(e',r,s);\n        }\n      }\n    }\n  }\n",
        "method_without_assertion_content": "  lemma OrRShortSafe(r: Request, s: EntityStore, e: Expr, e': Expr)\n    requires IsSafe(r,s,e,Type.Bool(AnyBool))\n    requires IsTrue(r,s,e')\n    ensures IsTrue(r,s,Or(e,e'))\n  {\n    reveal IsSafe();\n    if Evaluate(e,r,s).Ok? && Evaluate(e',r,s).Ok? {\n      assert Evaluate(e',r,s) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n      assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n      assert Evaluate(Or(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n    } else {\n      if Evaluate(e,r,s).Err? {\n        assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == Evaluate(e,r,s);\n        assert Evaluate(Or(e,e'),r,s) == Evaluate(e,r,s);\n      } else {\n        assert Evaluate(e',r,s).Err?;\n        var b :| Evaluate(e,r,s) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n        if b {\n          assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n          assert Evaluate(Or(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n        } else {\n                    assert Evaluate(Or(e,e'),r,s) == Evaluate(e',r,s);\n        }\n      }\n    }\n  }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "82",
        "method_filepath": "./cedar-dafny/validation/thm/model.dfy",
        "method_without_assertion_filename": "AndRShortSafe_fix_82.dfy",
        "method_name": "AndRShortSafe",
        "method_content": "  lemma AndRShortSafe(r: Request, s: EntityStore, e: Expr, e': Expr)\n    requires IsSafe(r,s,e,Type.Bool(AnyBool))\n    requires IsFalse(r,s,e')\n    ensures IsFalse(r,s,And(e,e'))\n  {\n    reveal IsSafe();\n    if Evaluate(e,r,s).Ok? && Evaluate(e',r,s).Ok? {\n      assert Evaluate(e',r,s) == base.Ok(Value.Primitive(Primitive.Bool(false)));\n      assert Evaluator(r,s).interpretShortcircuit(And(e,e'),e,e',false) == base.Ok(Value.Primitive(Primitive.Bool(false)));\n      assert Evaluate(And(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(false)));\n    } else {\n      if Evaluate(e,r,s).Err? {\n        assert Evaluator(r,s).interpretShortcircuit(And(e,e'),e,e',false) == Evaluate(e,r,s);\n        assert Evaluate(And(e,e'),r,s) == Evaluate(e,r,s);\n      } else {\n        assert Evaluate(e',r,s).Err?;\n        var b :| Evaluate(e,r,s) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n        if b {\n          assert Evaluator(r,s).interpretShortcircuit(And(e,e'),e,e',false) == Evaluate(e',r,s);\n          assert Evaluate(And(e,e'),r,s) == Evaluate(e',r,s);\n        } else {\n          assert Evaluator(r,s).interpretShortcircuit(And(e,e'),e,e',false) == base.Ok(Value.Primitive(Primitive.Bool(false)));\n          assert Evaluate(And(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(false)));\n        }\n      }\n    }\n  }\n",
        "method_without_assertion_content": "  lemma AndRShortSafe(r: Request, s: EntityStore, e: Expr, e': Expr)\n    requires IsSafe(r,s,e,Type.Bool(AnyBool))\n    requires IsFalse(r,s,e')\n    ensures IsFalse(r,s,And(e,e'))\n  {\n    reveal IsSafe();\n    if Evaluate(e,r,s).Ok? && Evaluate(e',r,s).Ok? {\n      assert Evaluate(e',r,s) == base.Ok(Value.Primitive(Primitive.Bool(false)));\n            assert Evaluate(And(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(false)));\n    } else {\n      if Evaluate(e,r,s).Err? {\n        assert Evaluator(r,s).interpretShortcircuit(And(e,e'),e,e',false) == Evaluate(e,r,s);\n        assert Evaluate(And(e,e'),r,s) == Evaluate(e,r,s);\n      } else {\n        assert Evaluate(e',r,s).Err?;\n        var b :| Evaluate(e,r,s) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n        if b {\n          assert Evaluator(r,s).interpretShortcircuit(And(e,e'),e,e',false) == Evaluate(e',r,s);\n          assert Evaluate(And(e,e'),r,s) == Evaluate(e',r,s);\n        } else {\n          assert Evaluator(r,s).interpretShortcircuit(And(e,e'),e,e',false) == base.Ok(Value.Primitive(Primitive.Bool(false)));\n          assert Evaluate(And(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(false)));\n        }\n      }\n    }\n  }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "788",
        "method_filepath": "./cedar-dafny/validation/thm/soundness.dfy",
        "method_without_assertion_filename": "SoundArith_fix_788.dfy",
        "method_name": "SoundArith",
        "method_content": "    lemma SoundArith(op: BinaryOp, e1: Expr, e2: Expr, t: Type, effs: Effects)\n      decreases BinaryApp(op,e1,e2) , 0\n      requires op == Add || op == Sub\n      requires WellFormedRequestAndStore()\n      requires EffectsInvariant(effs)\n      requires Typesafe(BinaryApp(op,e1,e2),effs,t)\n      ensures IsSafe(r,s,BinaryApp(op,e1,e2),t)\n      ensures getEffects(BinaryApp(op,e1,e2),effs) == Effects.empty()\n    {\n      var t' :| getType(BinaryApp(op,e1,e2),effs) == t' && subty(t',t,ValidationMode.Permissive);\n      assert TC.inferArith2(op,e1,e2,effs) == types.Ok(Type.Int);\n      assert TC.ensureIntType(e1,effs).Ok?;\n      assert Typesafe(e1,effs,Type.Int);\n      assert TC.ensureIntType(e2,effs).Ok?;\n      assert Typesafe(e2,effs,Type.Int);\n      assert IsSafe(r,s,e1,Type.Int) by { Sound(e1,Type.Int,effs); }\n      assert IsSafe(r,s,e2,Type.Int) by { Sound(e2,Type.Int,effs); }\n      assert IsSafe(r,s,BinaryApp(op,e1,e2),t') by { ArithSafe(r,s,op,e1,e2); }\n      assert IsSafe(r,s,BinaryApp(op,e1,e2),t) by {\n        SubtyCompat(t',t);\n        SemSubtyTransport(r,s,BinaryApp(op,e1,e2),t',t);\n      }\n    }\n",
        "method_without_assertion_content": "    lemma SoundArith(op: BinaryOp, e1: Expr, e2: Expr, t: Type, effs: Effects)\n      decreases BinaryApp(op,e1,e2) , 0\n      requires op == Add || op == Sub\n      requires WellFormedRequestAndStore()\n      requires EffectsInvariant(effs)\n      requires Typesafe(BinaryApp(op,e1,e2),effs,t)\n      ensures IsSafe(r,s,BinaryApp(op,e1,e2),t)\n      ensures getEffects(BinaryApp(op,e1,e2),effs) == Effects.empty()\n    {\n      var t' :| getType(BinaryApp(op,e1,e2),effs) == t' && subty(t',t,ValidationMode.Permissive);\n            assert TC.ensureIntType(e1,effs).Ok?;\n      assert Typesafe(e1,effs,Type.Int);\n      assert TC.ensureIntType(e2,effs).Ok?;\n      assert Typesafe(e2,effs,Type.Int);\n      assert IsSafe(r,s,e1,Type.Int) by { Sound(e1,Type.Int,effs); }\n      assert IsSafe(r,s,e2,Type.Int) by { Sound(e2,Type.Int,effs); }\n      assert IsSafe(r,s,BinaryApp(op,e1,e2),t') by { ArithSafe(r,s,op,e1,e2); }\n      assert IsSafe(r,s,BinaryApp(op,e1,e2),t) by {\n        SubtyCompat(t',t);\n        SemSubtyTransport(r,s,BinaryApp(op,e1,e2),t',t);\n      }\n    }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "816",
        "method_filepath": "./cedar-dafny/validation/thm/soundness.dfy",
        "method_without_assertion_filename": "SoundInSetMemberFalse_fix_816.dfy",
        "method_name": "SoundInSetMemberFalse",
        "method_content": "    lemma SoundInSetMemberFalse(e1: Expr, ei2s: seq<Expr>, i: nat, effs: Effects)\n      decreases BinaryApp(BinaryOp.In,e1,Expr.Set(ei2s)) , 0 , Expr.Set(ei2s) , 0\n      requires WellFormedRequestAndStore()\n      requires EffectsInvariant(effs)\n      requires WellTyped(BinaryApp(BinaryOp.In,e1,Expr.Set(ei2s)),effs)\n      requires getType(BinaryApp(BinaryOp.In,e1,Expr.Set(ei2s)),effs) == Type.Bool(False)\n      requires !reqty.isUnspecifiedVar(e1)\n      requires 0 <= i < |ei2s|\n      ensures IsFalse(r,s,BinaryApp(BinaryOp.In,e1,ei2s[i]))\n    {\n      // Reestablishing things we had at the call site in `SoundIn`.\n      var e2 := Expr.Set(ei2s);\n\n      assert TC.inferIn(BinaryApp(BinaryOp.In,e1,e2),e1,e2,effs) == types.Ok(Type.Bool(False));\n\n      assert TC.ensureEntityType(e1,effs).Ok?;\n      var t1 := getType(e1,effs);\n\n      var euids2 :- assert TC.tryGetEUIDs(e2);\n      var ets2 := set u <- euids2 :: u.ty;\n\n      // New proof.\n      var u2 :- assert TC.tryGetEUID(ei2s[i]);\n      assert u2 in euids2;\n      match e1 {\n        case Var(v1) =>\n          var et1 :- assert TC.getPrincipalOrResource(v1);\n          assert t1 == Type.Entity(EntityLUB({et1}));\n          assert IsSafe(r,s,Var(v1),t1) by { Sound(e1,t1,effs); }\n          assert !ets.possibleDescendantOf(et1,u2.ty);\n          reveal WellFormedRequestAndStore();\n          InSingleFalseEntityTypeAndLiteral(r,s,e1,et1,u2);\n        case PrimitiveLit(EntityUID(u1)) =>\n          if isAction(u1.ty) {\n            assert !acts.descendantOfSet(u1,euids2);\n            assert !acts.descendantOf(u1,u2);\n          } else {\n            assert !ets.possibleDescendantOfSet(u1.ty,ets2);\n            assert !ets.possibleDescendantOf(u1.ty,u2.ty);\n          }\n          reveal WellFormedRequestAndStore();\n          InSingleFalseLiterals(r,s,u1,u2);\n      }\n    }\n",
        "method_without_assertion_content": "    lemma SoundInSetMemberFalse(e1: Expr, ei2s: seq<Expr>, i: nat, effs: Effects)\n      decreases BinaryApp(BinaryOp.In,e1,Expr.Set(ei2s)) , 0 , Expr.Set(ei2s) , 0\n      requires WellFormedRequestAndStore()\n      requires EffectsInvariant(effs)\n      requires WellTyped(BinaryApp(BinaryOp.In,e1,Expr.Set(ei2s)),effs)\n      requires getType(BinaryApp(BinaryOp.In,e1,Expr.Set(ei2s)),effs) == Type.Bool(False)\n      requires !reqty.isUnspecifiedVar(e1)\n      requires 0 <= i < |ei2s|\n      ensures IsFalse(r,s,BinaryApp(BinaryOp.In,e1,ei2s[i]))\n    {\n      // Reestablishing things we had at the call site in `SoundIn`.\n      var e2 := Expr.Set(ei2s);\n\n      assert TC.inferIn(BinaryApp(BinaryOp.In,e1,e2),e1,e2,effs) == types.Ok(Type.Bool(False));\n\n      assert TC.ensureEntityType(e1,effs).Ok?;\n      var t1 := getType(e1,effs);\n\n      var euids2 :- assert TC.tryGetEUIDs(e2);\n      var ets2 := set u <- euids2 :: u.ty;\n\n      // New proof.\n      var u2 :- assert TC.tryGetEUID(ei2s[i]);\n      assert u2 in euids2;\n      match e1 {\n        case Var(v1) =>\n          var et1 :- assert TC.getPrincipalOrResource(v1);\n          assert t1 == Type.Entity(EntityLUB({et1}));\n          assert IsSafe(r,s,Var(v1),t1) by { Sound(e1,t1,effs); }\n                    reveal WellFormedRequestAndStore();\n          InSingleFalseEntityTypeAndLiteral(r,s,e1,et1,u2);\n        case PrimitiveLit(EntityUID(u1)) =>\n          if isAction(u1.ty) {\n            assert !acts.descendantOfSet(u1,euids2);\n            assert !acts.descendantOf(u1,u2);\n          } else {\n            assert !ets.possibleDescendantOfSet(u1.ty,ets2);\n            assert !ets.possibleDescendantOf(u1.ty,u2.ty);\n          }\n          reveal WellFormedRequestAndStore();\n          InSingleFalseLiterals(r,s,u1,u2);\n      }\n    }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "797",
        "method_filepath": "./cedar-dafny/validation/thm/soundness.dfy",
        "method_without_assertion_filename": "SoundIneq_fix_797.dfy",
        "method_name": "SoundIneq",
        "method_content": "    lemma SoundIneq(op: BinaryOp, e1: Expr, e2: Expr, t: Type, effs: Effects)\n      decreases BinaryApp(op,e1,e2) , 0\n      requires op == Less || op == BinaryOp.LessEq\n      requires WellFormedRequestAndStore()\n      requires EffectsInvariant(effs)\n      requires Typesafe(BinaryApp(op,e1,e2),effs,t)\n      ensures IsSafe(r,s,BinaryApp(op,e1,e2),t)\n      ensures getEffects(BinaryApp(op,e1,e2),effs) == Effects.empty()\n    {\n      var t' :| getType(BinaryApp(op,e1,e2),effs) == t' && subty(t',t,ValidationMode.Permissive);\n      assert TC.inferIneq(op,e1,e2,effs) == types.Ok(Type.Bool(AnyBool));\n      assert TC.ensureIntType(e1,effs).Ok?;\n      assert Typesafe(e1,effs,Type.Int);\n      assert TC.ensureIntType(e2,effs).Ok?;\n      assert Typesafe(e2,effs,Type.Int);\n      assert IsSafe(r,s,e1,Type.Int) by { Sound(e1,Type.Int,effs); }\n      assert IsSafe(r,s,e2,Type.Int) by { Sound(e2,Type.Int,effs); }\n      assert IsSafe(r,s,BinaryApp(op,e1,e2),t') by { IneqSafe(r,s,op,e1,e2); }\n      assert IsSafe(r,s,BinaryApp(op,e1,e2),t) by {\n        SubtyCompat(t',t);\n        SemSubtyTransport(r,s,BinaryApp(op,e1,e2),t',t);\n      }\n    }\n",
        "method_without_assertion_content": "    lemma SoundIneq(op: BinaryOp, e1: Expr, e2: Expr, t: Type, effs: Effects)\n      decreases BinaryApp(op,e1,e2) , 0\n      requires op == Less || op == BinaryOp.LessEq\n      requires WellFormedRequestAndStore()\n      requires EffectsInvariant(effs)\n      requires Typesafe(BinaryApp(op,e1,e2),effs,t)\n      ensures IsSafe(r,s,BinaryApp(op,e1,e2),t)\n      ensures getEffects(BinaryApp(op,e1,e2),effs) == Effects.empty()\n    {\n      var t' :| getType(BinaryApp(op,e1,e2),effs) == t' && subty(t',t,ValidationMode.Permissive);\n      assert TC.inferIneq(op,e1,e2,effs) == types.Ok(Type.Bool(AnyBool));\n            assert Typesafe(e1,effs,Type.Int);\n      assert TC.ensureIntType(e2,effs).Ok?;\n      assert Typesafe(e2,effs,Type.Int);\n      assert IsSafe(r,s,e1,Type.Int) by { Sound(e1,Type.Int,effs); }\n      assert IsSafe(r,s,e2,Type.Int) by { Sound(e2,Type.Int,effs); }\n      assert IsSafe(r,s,BinaryApp(op,e1,e2),t') by { IneqSafe(r,s,op,e1,e2); }\n      assert IsSafe(r,s,BinaryApp(op,e1,e2),t) by {\n        SubtyCompat(t',t);\n        SemSubtyTransport(r,s,BinaryApp(op,e1,e2),t',t);\n      }\n    }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "857",
        "method_filepath": "./cedar-dafny/validation/thm/strict_soundness.dfy",
        "method_without_assertion_filename": "StrictGetLubRecordType_fix_857.dfy",
        "method_name": "StrictGetLubRecordType",
        "method_content": "    lemma StrictGetLubRecordType(lub: EntityLUB)\n      requires ets.getLubRecordType(lub, ValidationMode.Strict).Ok?\n      ensures ets.getLubRecordType(lub, ValidationMode.Permissive) == ets.getLubRecordType(lub, ValidationMode.Strict)\n    {\n      if lub.AnyEntity? || exists et <- lub.tys :: isAction(et) {\n        assert ets.getLubRecordType(lub, ValidationMode.Permissive).Ok?;\n      } else {\n        assert forall et <- lub.tys :: et in ets.types;\n        def.util.EntityTypeLeqIsTotalOrder();\n        var lubSeq := def.util.SetToSortedSeq(lub.tys,def.util.EntityTypeLeq);\n        var s := seq (|lubSeq|, i requires 0 <= i < |lubSeq| => ets.types[lubSeq[i]]);\n        assert s != [];\n        assert lubRecordTypeSeq(s, ValidationMode.Strict) == lubRecordTypeSeq(s, ValidationMode.Permissive) by {\n          assert ets.getLubRecordType(lub, ValidationMode.Strict).Ok?;\n          StrictLubRecordTypeSeq(s);\n        }\n      }\n    }\n",
        "method_without_assertion_content": "    lemma StrictGetLubRecordType(lub: EntityLUB)\n      requires ets.getLubRecordType(lub, ValidationMode.Strict).Ok?\n      ensures ets.getLubRecordType(lub, ValidationMode.Permissive) == ets.getLubRecordType(lub, ValidationMode.Strict)\n    {\n      if lub.AnyEntity? || exists et <- lub.tys :: isAction(et) {\n        assert ets.getLubRecordType(lub, ValidationMode.Permissive).Ok?;\n      } else {\n        assert forall et <- lub.tys :: et in ets.types;\n        def.util.EntityTypeLeqIsTotalOrder();\n        var lubSeq := def.util.SetToSortedSeq(lub.tys,def.util.EntityTypeLeq);\n        var s := seq (|lubSeq|, i requires 0 <= i < |lubSeq| => ets.types[lubSeq[i]]);\n        assert s != [];\n        assert lubRecordTypeSeq(s, ValidationMode.Strict) == lubRecordTypeSeq(s, ValidationMode.Permissive) by {\n                    StrictLubRecordTypeSeq(s);\n        }\n      }\n    }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "2",
        "method_filepath": "./cedar-dafny/validation/subtyping.dfy",
        "method_without_assertion_filename": "StrictSubtyIsStrict_fix_2.dfy",
        "method_name": "StrictSubtyIsStrict",
        "method_content": "  lemma StrictSubtyIsStrict(t1: Type, t2: Type)\n    requires subty(t1, t2, ValidationMode.Strict)\n    ensures subty(t1, t2, ValidationMode.Permissive)\n  {\n    match (t1,t2) {\n      case (Record(rt1),Record(rt2)) =>  {\n        if(rt2.attrs.Keys <= rt1.attrs.Keys) {\n          if ! (forall k | k in rt2.attrs.Keys :: subtyAttrType(rt1.attrs[k], rt2.attrs[k], ValidationMode.Permissive)) {\n            assert exists k | k in rt2.attrs.Keys :: !subtyAttrType(rt1.attrs[k], rt2.attrs[k], ValidationMode.Permissive);\n            assert exists k | k in rt2.attrs.Keys :: !subtyAttrType(rt1.attrs[k], rt2.attrs[k], ValidationMode.Strict);\n          }\n        }\n      }\n      case _ =>\n    }\n  }\n",
        "method_without_assertion_content": "  lemma StrictSubtyIsStrict(t1: Type, t2: Type)\n    requires subty(t1, t2, ValidationMode.Strict)\n    ensures subty(t1, t2, ValidationMode.Permissive)\n  {\n    match (t1,t2) {\n      case (Record(rt1),Record(rt2)) =>  {\n        if(rt2.attrs.Keys <= rt1.attrs.Keys) {\n          if ! (forall k | k in rt2.attrs.Keys :: subtyAttrType(rt1.attrs[k], rt2.attrs[k], ValidationMode.Permissive)) {\n            assert exists k | k in rt2.attrs.Keys :: !subtyAttrType(rt1.attrs[k], rt2.attrs[k], ValidationMode.Permissive);\n                      }\n        }\n      }\n      case _ =>\n    }\n  }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "856",
        "method_filepath": "./cedar-dafny/validation/thm/strict_soundness.dfy",
        "method_without_assertion_filename": "StrictGetLubRecordType_fix_856.dfy",
        "method_name": "StrictGetLubRecordType",
        "method_content": "    lemma StrictGetLubRecordType(lub: EntityLUB)\n      requires ets.getLubRecordType(lub, ValidationMode.Strict).Ok?\n      ensures ets.getLubRecordType(lub, ValidationMode.Permissive) == ets.getLubRecordType(lub, ValidationMode.Strict)\n    {\n      if lub.AnyEntity? || exists et <- lub.tys :: isAction(et) {\n        assert ets.getLubRecordType(lub, ValidationMode.Permissive).Ok?;\n      } else {\n        assert forall et <- lub.tys :: et in ets.types;\n        def.util.EntityTypeLeqIsTotalOrder();\n        var lubSeq := def.util.SetToSortedSeq(lub.tys,def.util.EntityTypeLeq);\n        var s := seq (|lubSeq|, i requires 0 <= i < |lubSeq| => ets.types[lubSeq[i]]);\n        assert s != [];\n        assert lubRecordTypeSeq(s, ValidationMode.Strict) == lubRecordTypeSeq(s, ValidationMode.Permissive) by {\n          assert ets.getLubRecordType(lub, ValidationMode.Strict).Ok?;\n          StrictLubRecordTypeSeq(s);\n        }\n      }\n    }\n",
        "method_without_assertion_content": "    lemma StrictGetLubRecordType(lub: EntityLUB)\n      requires ets.getLubRecordType(lub, ValidationMode.Strict).Ok?\n      ensures ets.getLubRecordType(lub, ValidationMode.Permissive) == ets.getLubRecordType(lub, ValidationMode.Strict)\n    {\n      if lub.AnyEntity? || exists et <- lub.tys :: isAction(et) {\n        assert ets.getLubRecordType(lub, ValidationMode.Permissive).Ok?;\n      } else {\n        assert forall et <- lub.tys :: et in ets.types;\n        def.util.EntityTypeLeqIsTotalOrder();\n        var lubSeq := def.util.SetToSortedSeq(lub.tys,def.util.EntityTypeLeq);\n        var s := seq (|lubSeq|, i requires 0 <= i < |lubSeq| => ets.types[lubSeq[i]]);\n                assert lubRecordTypeSeq(s, ValidationMode.Strict) == lubRecordTypeSeq(s, ValidationMode.Permissive) by {\n          assert ets.getLubRecordType(lub, ValidationMode.Strict).Ok?;\n          StrictLubRecordTypeSeq(s);\n        }\n      }\n    }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "895",
        "method_filepath": "./cedar-dafny/def/ext/ipaddr.dfy",
        "method_without_assertion_filename": "CountDC1SepMeansNoDc_fix_895.dfy",
        "method_name": "CountDC1SepMeansNoDc",
        "method_content": "  lemma CountDC1SepMeansNoDc(segs: seq<SegV6>)\n    requires countDC(segs) <= 1\n    ensures findDCIdx(segs).Some? ==> countDC(segs[0..findDCIdx(segs).value]) == 0 && countDC(segs[findDCIdx(segs).value+1..]) == 0\n  {\n    var idx := findDCIdx(segs);\n    if idx.None? {\n\n    } else {\n      assert segs == segs[0..idx.value+1] + segs[idx.value+1..];\n      CountDCComp(segs[0..idx.value+1], segs[idx.value+1..]);\n      assert countDC(segs[0..idx.value+1]) + countDC(segs[idx.value+1..]) == countDC(segs);\n      assert segs[0..idx.value+1] == segs[0..idx.value] + [segs[idx.value]];\n      CountDCComp(segs[0..idx.value], [segs[idx.value]]);\n      assert countDC(segs[0..idx.value]) + countDC([segs[idx.value]]) == countDC(segs[0..idx.value+1]);\n    }\n  }\n",
        "method_without_assertion_content": "  lemma CountDC1SepMeansNoDc(segs: seq<SegV6>)\n    requires countDC(segs) <= 1\n    ensures findDCIdx(segs).Some? ==> countDC(segs[0..findDCIdx(segs).value]) == 0 && countDC(segs[findDCIdx(segs).value+1..]) == 0\n  {\n    var idx := findDCIdx(segs);\n    if idx.None? {\n\n    } else {\n      assert segs == segs[0..idx.value+1] + segs[idx.value+1..];\n      CountDCComp(segs[0..idx.value+1], segs[idx.value+1..]);\n      assert countDC(segs[0..idx.value+1]) + countDC(segs[idx.value+1..]) == countDC(segs);\n            CountDCComp(segs[0..idx.value], [segs[idx.value]]);\n      assert countDC(segs[0..idx.value]) + countDC([segs[idx.value]]) == countDC(segs[0..idx.value+1]);\n    }\n  }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "772",
        "method_filepath": "./cedar-dafny/validation/thm/soundness.dfy",
        "method_without_assertion_filename": "SoundOr_fix_772.dfy",
        "method_name": "SoundOr",
        "method_content": "    lemma SoundOr(e1: Expr, e2: Expr, t: Type, effs: Effects)\n      decreases Or(e1,e2) , 0\n      requires WellFormedRequestAndStore()\n      requires EffectsInvariant(effs)\n      requires Typesafe(Or(e1,e2),effs,t)\n      ensures IsSafe(r,s,Or(e1,e2),t)\n      ensures GuardedEffectsInvariant(Or(e1,e2),getEffects(Or(e1,e2),effs))\n    {\n      var t' :| getType(Or(e1,e2),effs) == t' && subty(t',t,ValidationMode.Permissive);\n      assert TC.inferOr(e1,e2,effs).Ok?;\n      var (bt1, effs1) := TC.inferBoolType(e1,effs).value;\n      assert Typesafe(e1,effs,Type.Bool(bt1));\n      assert IsSafe(r,s,e1,Type.Bool(bt1)) && GuardedEffectsInvariant(e1,effs1) by {\n        Sound(e1,Type.Bool(bt1),effs);\n      }\n      assert GuardedEffectsInvariant(Or(e1,e2),Effects.empty()) by {\n        EmptyEffectsInvariant();\n      }\n      match bt1 {\n        case True =>\n          assert IsTrue(r,s,e1);\n          assert IsSafe(r,s,Or(e1,e2),t') by { OrLShortSafe(r,s,e1,e2); }\n          assert IsSafe(r,s,Or(e1,e2),t) by {\n            SubtyCompat(t',t);\n            SemSubtyTransport(r,s,Or(e1,e2),t',t);\n          }\n        case False =>\n          assert IsFalse(r,s,e1);\n          var (bt2, effs2) := TC.inferBoolType(e2,effs).value;\n          assert Typesafe(e2,effs,Type.Bool(bt2));\n          assert IsSafe(r,s,e2,Type.Bool(bt2)) && GuardedEffectsInvariant(e2,effs2) by {\n            Sound(e2,Type.Bool(bt2),effs);\n          }\n          assert SemanticSubty(Type.Bool(bt2),Type.Bool(AnyBool)) by {\n            assert subty(Type.Bool(bt2),Type.Bool(AnyBool),ValidationMode.Permissive);\n            SubtyCompat(Type.Bool(bt2),Type.Bool(AnyBool));\n          }\n          assert IsSafe(r,s,Or(e1,e2),Type.Bool(bt2)) by { OrRRetSafe(r,s,e1,e2,Type.Bool(bt2)); }\n          assert IsSafe(r,s,Or(e1,e2),t) by {\n            SubtyCompat(t',t);\n            SemSubtyTransport(r,s,Or(e1,e2),t',t);\n          }\n          assert GuardedEffectsInvariant(Or(e1,e2),effs2) by {\n            if IsTrueStrong(r,s,Or(e1,e2)) {\n              OrTrueStrong(r,s,e1,e2);\n              FalseImpliesNotTrueStrong(r,s,e1);\n              assert IsTrueStrong(r,s,e2);\n              assert EffectsInvariant(effs2);\n            }\n          }\n        case _ =>\n          var (bt2, effs2) := TC.inferBoolType(e2,effs).value;\n          assert Typesafe(e2,effs,Type.Bool(bt2));\n          assert IsSafe(r,s,e2,Type.Bool(bt2)) && GuardedEffectsInvariant(e2,effs2) by {\n            Sound(e2,Type.Bool(bt2),effs);\n          }\n          match bt2 {\n            case True =>\n              assert IsTrue(r,s,e2);\n              assert IsSafe(r,s,e1,Type.Bool(AnyBool)) by {\n                SubtyCompat(Type.Bool(bt1),Type.Bool(AnyBool));\n                SemSubtyTransport(r,s,e1,Type.Bool(bt1),Type.Bool(AnyBool));\n              }\n              assert IsTrue(r,s,Or(e1,e2)) by { OrRShortSafe(r,s,e1,e2); }\n              assert IsSafe(r,s,Or(e1,e2),t) by {\n                SubtyCompat(Type.Bool(True),t);\n                SemSubtyTransport(r,s,Or(e1,e2),Type.Bool(True),t);\n              }\n            case False =>\n              assert IsFalse(r,s,e2);\n              assert IsSafe(r,s,Or(e1,e2),t) by {\n                OrLRetSafe(r,s,e1,e2,Type.Bool(bt1));\n                SubtyCompat(Type.Bool(bt1),t);\n                SemSubtyTransport(r,s,Or(e1,e2),Type.Bool(bt1),t);\n              }\n              assert GuardedEffectsInvariant(Or(e1,e2),effs1) by {\n                if IsTrueStrong(r,s,Or(e1,e2)) {\n                  OrTrueStrong(r,s,e1,e2);\n                  FalseImpliesNotTrueStrong(r,s,e2);\n                  assert IsTrueStrong(r,s,e1);\n                  assert EffectsInvariant(effs1);\n                }\n              }\n            case _ =>\n              assert IsSafe(r,s,e1,Type.Bool(AnyBool)) by {\n                SubtyCompat(Type.Bool(bt1),Type.Bool(AnyBool));\n                SemSubtyTransport(r,s,e1,Type.Bool(bt1),Type.Bool(AnyBool));\n              }\n              assert IsSafe(r,s,e2,Type.Bool(AnyBool)) by {\n                SubtyCompat(Type.Bool(bt2),Type.Bool(AnyBool));\n                SemSubtyTransport(r,s,e2,Type.Bool(bt2),Type.Bool(AnyBool));\n              }\n              assert IsSafe(r,s,Or(e1,e2),Type.Bool(AnyBool)) by { OrSafe(r,s,e1,e2); }\n              assert IsSafe(r,s,Or(e1,e2),t) by {\n                SubtyCompat(t',t);\n                SemSubtyTransport(r,s,Or(e1,e2),t',t);\n              }\n              assert GuardedEffectsInvariant(Or(e1,e2),effs1.intersect(effs2)) by {\n                if IsTrueStrong(r,s,Or(e1,e2)) {\n                  OrTrueStrong(r,s,e1,e2);\n                  if IsTrueStrong(r,s,e1) {\n                    assert EffectsInvariant(effs1);\n                    EffectsInvariantIntersectL(effs1,effs2);\n                  } else {\n                    assert IsTrueStrong(r,s,e2);\n                    assert EffectsInvariant(effs2);\n                    EffectsInvariantIntersectR(effs1,effs2);\n                  }\n                }\n              }\n          }\n      }\n    }\n",
        "method_without_assertion_content": "    lemma SoundOr(e1: Expr, e2: Expr, t: Type, effs: Effects)\n      decreases Or(e1,e2) , 0\n      requires WellFormedRequestAndStore()\n      requires EffectsInvariant(effs)\n      requires Typesafe(Or(e1,e2),effs,t)\n      ensures IsSafe(r,s,Or(e1,e2),t)\n      ensures GuardedEffectsInvariant(Or(e1,e2),getEffects(Or(e1,e2),effs))\n    {\n      var t' :| getType(Or(e1,e2),effs) == t' && subty(t',t,ValidationMode.Permissive);\n            var (bt1, effs1) := TC.inferBoolType(e1,effs).value;\n      assert Typesafe(e1,effs,Type.Bool(bt1));\n      assert IsSafe(r,s,e1,Type.Bool(bt1)) && GuardedEffectsInvariant(e1,effs1) by {\n        Sound(e1,Type.Bool(bt1),effs);\n      }\n      assert GuardedEffectsInvariant(Or(e1,e2),Effects.empty()) by {\n        EmptyEffectsInvariant();\n      }\n      match bt1 {\n        case True =>\n          assert IsTrue(r,s,e1);\n          assert IsSafe(r,s,Or(e1,e2),t') by { OrLShortSafe(r,s,e1,e2); }\n          assert IsSafe(r,s,Or(e1,e2),t) by {\n            SubtyCompat(t',t);\n            SemSubtyTransport(r,s,Or(e1,e2),t',t);\n          }\n        case False =>\n          assert IsFalse(r,s,e1);\n          var (bt2, effs2) := TC.inferBoolType(e2,effs).value;\n          assert Typesafe(e2,effs,Type.Bool(bt2));\n          assert IsSafe(r,s,e2,Type.Bool(bt2)) && GuardedEffectsInvariant(e2,effs2) by {\n            Sound(e2,Type.Bool(bt2),effs);\n          }\n          assert SemanticSubty(Type.Bool(bt2),Type.Bool(AnyBool)) by {\n            assert subty(Type.Bool(bt2),Type.Bool(AnyBool),ValidationMode.Permissive);\n            SubtyCompat(Type.Bool(bt2),Type.Bool(AnyBool));\n          }\n          assert IsSafe(r,s,Or(e1,e2),Type.Bool(bt2)) by { OrRRetSafe(r,s,e1,e2,Type.Bool(bt2)); }\n          assert IsSafe(r,s,Or(e1,e2),t) by {\n            SubtyCompat(t',t);\n            SemSubtyTransport(r,s,Or(e1,e2),t',t);\n          }\n          assert GuardedEffectsInvariant(Or(e1,e2),effs2) by {\n            if IsTrueStrong(r,s,Or(e1,e2)) {\n              OrTrueStrong(r,s,e1,e2);\n              FalseImpliesNotTrueStrong(r,s,e1);\n              assert IsTrueStrong(r,s,e2);\n              assert EffectsInvariant(effs2);\n            }\n          }\n        case _ =>\n          var (bt2, effs2) := TC.inferBoolType(e2,effs).value;\n          assert Typesafe(e2,effs,Type.Bool(bt2));\n          assert IsSafe(r,s,e2,Type.Bool(bt2)) && GuardedEffectsInvariant(e2,effs2) by {\n            Sound(e2,Type.Bool(bt2),effs);\n          }\n          match bt2 {\n            case True =>\n              assert IsTrue(r,s,e2);\n              assert IsSafe(r,s,e1,Type.Bool(AnyBool)) by {\n                SubtyCompat(Type.Bool(bt1),Type.Bool(AnyBool));\n                SemSubtyTransport(r,s,e1,Type.Bool(bt1),Type.Bool(AnyBool));\n              }\n              assert IsTrue(r,s,Or(e1,e2)) by { OrRShortSafe(r,s,e1,e2); }\n              assert IsSafe(r,s,Or(e1,e2),t) by {\n                SubtyCompat(Type.Bool(True),t);\n                SemSubtyTransport(r,s,Or(e1,e2),Type.Bool(True),t);\n              }\n            case False =>\n              assert IsFalse(r,s,e2);\n              assert IsSafe(r,s,Or(e1,e2),t) by {\n                OrLRetSafe(r,s,e1,e2,Type.Bool(bt1));\n                SubtyCompat(Type.Bool(bt1),t);\n                SemSubtyTransport(r,s,Or(e1,e2),Type.Bool(bt1),t);\n              }\n              assert GuardedEffectsInvariant(Or(e1,e2),effs1) by {\n                if IsTrueStrong(r,s,Or(e1,e2)) {\n                  OrTrueStrong(r,s,e1,e2);\n                  FalseImpliesNotTrueStrong(r,s,e2);\n                  assert IsTrueStrong(r,s,e1);\n                  assert EffectsInvariant(effs1);\n                }\n              }\n            case _ =>\n              assert IsSafe(r,s,e1,Type.Bool(AnyBool)) by {\n                SubtyCompat(Type.Bool(bt1),Type.Bool(AnyBool));\n                SemSubtyTransport(r,s,e1,Type.Bool(bt1),Type.Bool(AnyBool));\n              }\n              assert IsSafe(r,s,e2,Type.Bool(AnyBool)) by {\n                SubtyCompat(Type.Bool(bt2),Type.Bool(AnyBool));\n                SemSubtyTransport(r,s,e2,Type.Bool(bt2),Type.Bool(AnyBool));\n              }\n              assert IsSafe(r,s,Or(e1,e2),Type.Bool(AnyBool)) by { OrSafe(r,s,e1,e2); }\n              assert IsSafe(r,s,Or(e1,e2),t) by {\n                SubtyCompat(t',t);\n                SemSubtyTransport(r,s,Or(e1,e2),t',t);\n              }\n              assert GuardedEffectsInvariant(Or(e1,e2),effs1.intersect(effs2)) by {\n                if IsTrueStrong(r,s,Or(e1,e2)) {\n                  OrTrueStrong(r,s,e1,e2);\n                  if IsTrueStrong(r,s,e1) {\n                    assert EffectsInvariant(effs1);\n                    EffectsInvariantIntersectL(effs1,effs2);\n                  } else {\n                    assert IsTrueStrong(r,s,e2);\n                    assert EffectsInvariant(effs2);\n                    EffectsInvariantIntersectR(effs1,effs2);\n                  }\n                }\n              }\n          }\n      }\n    }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "46",
        "method_filepath": "./cedar-dafny/validation/thm/model.dfy",
        "method_without_assertion_filename": "OrTrueStrong_fix_46.dfy",
        "method_name": "OrTrueStrong",
        "method_content": "  lemma OrTrueStrong(r: Request, s: EntityStore, e1: Expr, e2: Expr)\n    requires IsTrueStrong(r,s,Or(e1,e2))\n    ensures IsTrueStrong(r,s,e1) || IsTrueStrong(r,s,e2)\n  {\n    reveal IsSafeStrong();\n    reveal IsSafe();\n    assert Evaluator(r,s).interpretShortcircuit(Or(e1,e2),e1,e2,true) == base.Ok(Value.Bool(true));\n  }\n",
        "method_without_assertion_content": "  lemma OrTrueStrong(r: Request, s: EntityStore, e1: Expr, e2: Expr)\n    requires IsTrueStrong(r,s,Or(e1,e2))\n    ensures IsTrueStrong(r,s,e1) || IsTrueStrong(r,s,e2)\n  {\n    reveal IsSafeStrong();\n    reveal IsSafe();\n      }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "67",
        "method_filepath": "./cedar-dafny/validation/thm/model.dfy",
        "method_without_assertion_filename": "SubtyCompatMatchPointwise_fix_67.dfy",
        "method_name": "SubtyCompatMatchPointwise",
        "method_content": "  lemma SubtyCompatMatchPointwise(t: Type, t': Type, v: Value)\n    requires subty(t,t',ValidationMode.Permissive)\n    requires InstanceOfType(v,t)\n    ensures InstanceOfType(v,t')\n    decreases t\n  {\n    match (t,t',v) {\n      case (Never,_,_) =>\n      case (String,String,_) =>\n      case (Int,Int,_) =>\n      case (Bool(b1),Bool(b2),_) =>\n      case (Set(t1),Set(t2),Set(s)) =>\n        assert forall v' | v' in s :: InstanceOfType(v',t2) by {\n          forall v': Value | v' in s\n            ensures InstanceOfType(v',t2)\n          {\n            assert InstanceOfType(v',t1);\n            SubtyCompatMatchPointwise(t1,t2,v');\n          }\n        }\n      case (Record(rt1),Record(rt2),Record(rv)) =>\n        assert forall k | k in rt2.attrs && k in rv :: InstanceOfType(rv[k],rt2.attrs[k].ty) by {\n          forall k: Attr | k in rt2.attrs && k in rv\n            ensures InstanceOfType(rv[k],rt2.attrs[k].ty)\n          {\n            assert InstanceOfType(rv[k],rt1.attrs[k].ty);\n            assert subtyAttrType(rt1.attrs[k],rt2.attrs[k],ValidationMode.Permissive);\n            SubtyCompatMatchPointwise(rt1.attrs[k].ty,rt2.attrs[k].ty,rv[k]);\n          }\n        }\n        assert forall k | k in rt2.attrs && rt2.attrs[k].isRequired :: k in rv by {\n          forall k | k in rt2.attrs && rt2.attrs[k].isRequired\n            ensures k in rv\n          {\n            assert subtyAttrType(rt1.attrs[k],rt2.attrs[k],ValidationMode.Permissive);\n          }\n        }\n      case (Entity(e1),Entity(e2),_) =>\n      case (Extension(e1),Extension(e2),_) =>\n    }\n  }\n",
        "method_without_assertion_content": "  lemma SubtyCompatMatchPointwise(t: Type, t': Type, v: Value)\n    requires subty(t,t',ValidationMode.Permissive)\n    requires InstanceOfType(v,t)\n    ensures InstanceOfType(v,t')\n    decreases t\n  {\n    match (t,t',v) {\n      case (Never,_,_) =>\n      case (String,String,_) =>\n      case (Int,Int,_) =>\n      case (Bool(b1),Bool(b2),_) =>\n      case (Set(t1),Set(t2),Set(s)) =>\n        assert forall v' | v' in s :: InstanceOfType(v',t2) by {\n          forall v': Value | v' in s\n            ensures InstanceOfType(v',t2)\n          {\n            assert InstanceOfType(v',t1);\n            SubtyCompatMatchPointwise(t1,t2,v');\n          }\n        }\n      case (Record(rt1),Record(rt2),Record(rv)) =>\n        assert forall k | k in rt2.attrs && k in rv :: InstanceOfType(rv[k],rt2.attrs[k].ty) by {\n          forall k: Attr | k in rt2.attrs && k in rv\n            ensures InstanceOfType(rv[k],rt2.attrs[k].ty)\n          {\n            assert InstanceOfType(rv[k],rt1.attrs[k].ty);\n                        SubtyCompatMatchPointwise(rt1.attrs[k].ty,rt2.attrs[k].ty,rv[k]);\n          }\n        }\n        assert forall k | k in rt2.attrs && rt2.attrs[k].isRequired :: k in rv by {\n          forall k | k in rt2.attrs && rt2.attrs[k].isRequired\n            ensures k in rv\n          {\n            assert subtyAttrType(rt1.attrs[k],rt2.attrs[k],ValidationMode.Permissive);\n          }\n        }\n      case (Entity(e1),Entity(e2),_) =>\n      case (Extension(e1),Extension(e2),_) =>\n    }\n  }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "888",
        "method_filepath": "./cedar-dafny/def/ext/decimal.dfy",
        "method_without_assertion_filename": "ParseDigitsAndDot_fix_888.dfy",
        "method_name": "ParseDigitsAndDot",
        "method_content": "  lemma ParseDigitsAndDot(s1: string, s2: string)\n    requires |s1| > 0\n    requires forall i | 0 <= i < |s1| :: '0' <= s1[i] <= '9'\n    ensures ParseDecStr(s1+\".\"+s2).Some? && ParseDecStr(s1+\".\"+s2).value.0 == s1 && ParseDecStr(s1+\".\"+s2).value.1 == \".\"+s2\n  {\n    if |s1| == 1 {\n      assert (s1+\".\"+s2)[1..] == \".\"+s2;\n      assert ParseDecStr(\".\"+s2).None?;\n    } else {\n      ParseDecAll(s1);\n      ParseDigitsAndDot(s1[1..],s2);\n      assert s1+\".\"+s2 == [s1[0]]+(s1[1..]+\".\"+s2);\n    }\n  }\n",
        "method_without_assertion_content": "  lemma ParseDigitsAndDot(s1: string, s2: string)\n    requires |s1| > 0\n    requires forall i | 0 <= i < |s1| :: '0' <= s1[i] <= '9'\n    ensures ParseDecStr(s1+\".\"+s2).Some? && ParseDecStr(s1+\".\"+s2).value.0 == s1 && ParseDecStr(s1+\".\"+s2).value.1 == \".\"+s2\n  {\n    if |s1| == 1 {\n      assert (s1+\".\"+s2)[1..] == \".\"+s2;\n          } else {\n      ParseDecAll(s1);\n      ParseDigitsAndDot(s1[1..],s2);\n      assert s1+\".\"+s2 == [s1[0]]+(s1[1..]+\".\"+s2);\n    }\n  }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "58",
        "method_filepath": "./cedar-dafny/validation/thm/model.dfy",
        "method_without_assertion_filename": "AndSafe_fix_58.dfy",
        "method_name": "AndSafe",
        "method_content": "  lemma AndSafe(r: Request, s: EntityStore, e: Expr, e': Expr)\n    requires IsSafe(r,s,e,Type.Bool(AnyBool))\n    requires IsSafe(r,s,e',Type.Bool(AnyBool))\n    ensures IsSafe(r,s,And(e,e'),Type.Bool(AnyBool))\n  {\n    reveal IsSafe();\n    if Evaluate(e,r,s).Ok? && Evaluate(e',r,s).Ok? {\n      assert Evaluator(r,s).interpretShortcircuit(And(e,e'),e,e',false).Ok?;\n      assert Evaluate(And(e,e'),r,s).Ok?;\n    } else {\n      if Evaluate(e,r,s).Err? {\n        assert Evaluator(r,s).interpretShortcircuit(And(e,e'),e,e',false) == Evaluate(e,r,s);\n        assert Evaluate(And(e,e'),r,s) == Evaluate(e,r,s);\n      } else {\n        assert Evaluate(e',r,s).Err?;\n        var b :| Evaluate(e,r,s) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n        if b {\n          assert Evaluator(r,s).interpretShortcircuit(And(e,e'),e,e',false) == Evaluate(e',r,s);\n          assert Evaluate(And(e,e'),r,s) == Evaluate(e',r,s);\n        } else {\n          assert Evaluator(r,s).interpretShortcircuit(And(e,e'),e,e',false) == base.Ok(Value.Primitive(Primitive.Bool(false)));\n          assert Evaluate(And(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(false)));\n        }\n      }\n    }\n  }\n",
        "method_without_assertion_content": "  lemma AndSafe(r: Request, s: EntityStore, e: Expr, e': Expr)\n    requires IsSafe(r,s,e,Type.Bool(AnyBool))\n    requires IsSafe(r,s,e',Type.Bool(AnyBool))\n    ensures IsSafe(r,s,And(e,e'),Type.Bool(AnyBool))\n  {\n    reveal IsSafe();\n    if Evaluate(e,r,s).Ok? && Evaluate(e',r,s).Ok? {\n      assert Evaluator(r,s).interpretShortcircuit(And(e,e'),e,e',false).Ok?;\n      assert Evaluate(And(e,e'),r,s).Ok?;\n    } else {\n      if Evaluate(e,r,s).Err? {\n                assert Evaluate(And(e,e'),r,s) == Evaluate(e,r,s);\n      } else {\n        assert Evaluate(e',r,s).Err?;\n        var b :| Evaluate(e,r,s) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n        if b {\n          assert Evaluator(r,s).interpretShortcircuit(And(e,e'),e,e',false) == Evaluate(e',r,s);\n          assert Evaluate(And(e,e'),r,s) == Evaluate(e',r,s);\n        } else {\n          assert Evaluator(r,s).interpretShortcircuit(And(e,e'),e,e',false) == base.Ok(Value.Primitive(Primitive.Bool(false)));\n          assert Evaluate(And(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(false)));\n        }\n      }\n    }\n  }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "77",
        "method_filepath": "./cedar-dafny/validation/thm/model.dfy",
        "method_without_assertion_filename": "AndLRetSafe_fix_77.dfy",
        "method_name": "AndLRetSafe",
        "method_content": "  lemma AndLRetSafe(r: Request, s: EntityStore, e: Expr, e': Expr, t: Type)\n    requires IsSafe(r,s,e,t)\n    requires IsTrue(r,s,e')\n    requires SemanticSubty(t,Type.Bool(AnyBool))\n    ensures IsSafe(r,s,And(e,e'),t)\n  {\n    reveal IsSafe();\n    if Evaluate(e,r,s).Ok? && Evaluate(e',r,s).Ok? {\n      assert Evaluate(e',r,s) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n      var v :| Evaluate(e,r,s) == base.Ok(v) && InstanceOfType(v,t);\n      assert InstanceOfType(v,Type.Bool(AnyBool)) by {\n        SemSubtyTransportVal(t,Type.Bool(AnyBool),v);\n      }\n      var b :| v == Value.Primitive(Primitive.Bool(b));\n      assert Evaluator(r,s).interpretShortcircuit(And(e,e'),e,e',false) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n      assert Evaluate(And(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n    } else {\n      if Evaluate(e,r,s).Err? {\n        assert Evaluator(r,s).interpretShortcircuit(And(e,e'),e,e',false) == Evaluate(e,r,s);\n        assert Evaluate(And(e,e'),r,s) == Evaluate(e,r,s);\n      } else {\n        assert Evaluate(e',r,s).Err?;\n        var b :| Evaluate(e,r,s) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n        if b {\n          assert Evaluator(r,s).interpretShortcircuit(And(e,e'),e,e',false) == Evaluate(e',r,s);\n          assert Evaluate(And(e,e'),r,s) == Evaluate(e',r,s);\n        } else {\n          assert Evaluator(r,s).interpretShortcircuit(And(e,e'),e,e',false) == base.Ok(Value.Primitive(Primitive.Bool(false)));\n          assert Evaluate(And(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(false)));\n        }\n      }\n    }\n  }\n",
        "method_without_assertion_content": "  lemma AndLRetSafe(r: Request, s: EntityStore, e: Expr, e': Expr, t: Type)\n    requires IsSafe(r,s,e,t)\n    requires IsTrue(r,s,e')\n    requires SemanticSubty(t,Type.Bool(AnyBool))\n    ensures IsSafe(r,s,And(e,e'),t)\n  {\n    reveal IsSafe();\n    if Evaluate(e,r,s).Ok? && Evaluate(e',r,s).Ok? {\n      assert Evaluate(e',r,s) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n      var v :| Evaluate(e,r,s) == base.Ok(v) && InstanceOfType(v,t);\n      assert InstanceOfType(v,Type.Bool(AnyBool)) by {\n        SemSubtyTransportVal(t,Type.Bool(AnyBool),v);\n      }\n      var b :| v == Value.Primitive(Primitive.Bool(b));\n      assert Evaluator(r,s).interpretShortcircuit(And(e,e'),e,e',false) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n      assert Evaluate(And(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n    } else {\n      if Evaluate(e,r,s).Err? {\n        assert Evaluator(r,s).interpretShortcircuit(And(e,e'),e,e',false) == Evaluate(e,r,s);\n        assert Evaluate(And(e,e'),r,s) == Evaluate(e,r,s);\n      } else {\n        assert Evaluate(e',r,s).Err?;\n        var b :| Evaluate(e,r,s) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n        if b {\n          assert Evaluator(r,s).interpretShortcircuit(And(e,e'),e,e',false) == Evaluate(e',r,s);\n          assert Evaluate(And(e,e'),r,s) == Evaluate(e',r,s);\n        } else {\n                    assert Evaluate(And(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(false)));\n        }\n      }\n    }\n  }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "756",
        "method_filepath": "./cedar-dafny/validation/thm/soundness.dfy",
        "method_without_assertion_filename": "SoundIf_fix_756.dfy",
        "method_name": "SoundIf",
        "method_content": "    lemma SoundIf(e: Expr, e1: Expr, e2: Expr, t: Type, effs: Effects)\n      decreases If(e,e1,e2) , 0\n      requires WellFormedRequestAndStore()\n      requires EffectsInvariant(effs)\n      requires Typesafe(If(e,e1,e2),effs,t)\n      ensures IsSafe(r,s,If(e,e1,e2),t)\n      ensures GuardedEffectsInvariant(If(e,e1,e2),getEffects(If(e,e1,e2),effs))\n    {\n      var t' :| getType(If(e,e1,e2),effs) == t' && subty(t',t,ValidationMode.Permissive);\n      assert TC.inferIf(e,e1,e2,effs).Ok?;\n      var (bt, effs1) := TC.inferBoolType(e,effs).value;\n      assert IsSafe(r,s,e,Type.Bool(bt)) && GuardedEffectsInvariant(e,effs1) by {\n        assert getType(e,effs) == Type.Bool(bt);\n        assert subty(Type.Bool(bt),Type.Bool(bt),ValidationMode.Permissive);\n        assert Typesafe(e,effs,Type.Bool(bt));\n        Sound(e,Type.Bool(bt),effs);\n      }\n      match bt {\n        case True =>\n          assert IsTrue(r,s,e);\n          var (t1,effs2) := TC.infer(e1,effs.union(effs1)).value;\n          assert Typesafe(e1,effs.union(effs1),t1) by { SubtyRefl(t1); }\n          if IsTrueStrong(r,s,e) {\n            assert EffectsInvariant(effs1);\n            assert IsSafe(r,s,e1,t1) && GuardedEffectsInvariant(e1,effs2) by {\n              EffectsInvariantUnion(effs,effs1);\n              Sound(e1,t1,effs.union(effs1));\n            }\n            assert IsSafe(r,s,If(e,e1,e2),t') by { IteTrueSafe(r,s,e,e1,e2,t'); }\n            assert IsSafe(r,s,If(e,e1,e2),t) by {\n              SubtyCompat(t',t);\n              SemSubtyTransport(r,s,If(e,e1,e2),t',t);\n            }\n            assert GuardedEffectsInvariant(If(e,e1,e2),effs1.union(effs2)) by {\n              if IsTrueStrong(r,s,If(e,e1,e2)) {\n                IteTrueStrongTrue(r,s,e,e1,e2);\n                assert EffectsInvariant(effs2);\n                EffectsInvariantUnion(effs1,effs2);\n              }\n            }\n          } else {\n            assert IsSafe(r,s,If(e,e1,e2),t) by {\n              IteError(r,s,e,e1,e2,Type.Bool(True),t);\n            }\n            assert GuardedEffectsInvariant(If(e,e1,e2),effs1.union(effs2)) by {\n              IteError(r,s,e,e1,e2,Type.Bool(True),Type.Bool(True));\n              assert !IsTrueStrong(r,s,If(e,e1,e2));\n            }\n          }\n        case False =>\n          assert IsFalse(r,s,e);\n          var (t2,effs2) := TC.infer(e2,effs).value;\n          assert Typesafe(e2,effs,t2) by { SubtyRefl(t2); }\n          assert IsSafe(r,s,e2,t2) && GuardedEffectsInvariant(e2,effs2) by {\n            Sound(e2,t2,effs);\n          }\n          assert IsSafe(r,s,If(e,e1,e2),t') by { IteFalseSafe(r,s,e,e1,e2,t'); }\n          assert IsSafe(r,s,If(e,e1,e2),t) by {\n            SubtyCompat(t',t);\n            SemSubtyTransport(r,s,If(e,e1,e2),t',t);\n          }\n          assert GuardedEffectsInvariant(If(e,e1,e2),effs2) by {\n            if IsTrueStrong(r,s,If(e,e1,e2)) {\n              IteTrueStrongFalse(r,s,e,e1,e2);\n              assert EffectsInvariant(effs2);\n            }\n          }\n        case AnyBool =>\n          var (t1,effs2) := TC.infer(e1,effs.union(effs1)).value;\n          var (t2,effs3) := TC.infer(e2,effs).value;\n          assert Typesafe(e1,effs.union(effs1),t1) by { SubtyRefl(t1); }\n          assert Typesafe(e2,effs,t2) by { SubtyRefl(t2); }\n          assert t' == lubOpt(t1,t2,ValidationMode.Permissive).value;\n          assert subty(t1,t',ValidationMode.Permissive) && subty(t2,t',ValidationMode.Permissive) by { LubIsUB(t1,t2,t',ValidationMode.Permissive); }\n          if IsSafeStrong(r,s,e,Type.Bool(bt)) {\n            if IsTrue(r,s,e) {\n              // `e` evaluates to true\n              IsTrueImpliesIsTrueStrong(r,s,e,Type.Bool(bt));\n              assert IsTrueStrong(r,s,e);\n              assert EffectsInvariant(effs1);\n              assert IsSafe(r,s,e1,t1) && GuardedEffectsInvariant(e1,effs2) by {\n                EffectsInvariantUnion(effs,effs1);\n                Sound(e1,t1,effs.union(effs1));\n              }\n              assert IsSafe(r,s,If(e,e1,e2),t1) by { IteTrueSafe(r,s,e,e1,e2,t1); }\n              assert IsSafe(r,s,If(e,e1,e2),t) by {\n                SubtyCompat(t1,t');\n                SubtyCompat(t',t);\n                SemSubtyTransport(r,s,If(e,e1,e2),t1,t);\n              }\n              assert GuardedEffectsInvariant(If(e,e1,e2),effs1.union(effs2)) by {\n                if IsTrueStrong(r,s,If(e,e1,e2)) {\n                  IteTrueStrongTrue(r,s,e,e1,e2);\n                  EffectsInvariantUnion(effs1,effs2);\n                }\n              }\n              assert GuardedEffectsInvariant(If(e,e1,e2),effs1.union(effs2).intersect(effs3)) by {\n                if IsTrueStrong(r,s,If(e,e1,e2)) {\n                  EffectsInvariantIntersectL(effs1.union(effs2),effs3);\n                }\n              }\n            } else {\n              // `e` evaluates to false\n              NotTrueImpliesFalse(r,s,e,bt);\n              assert IsFalse(r,s,e);\n              assert IsSafe(r,s,e2,t2) && GuardedEffectsInvariant(e2,effs3) by {\n                Sound(e2,t2,effs);\n              }\n              assert IsSafe(r,s,If(e,e1,e2),t2) by { IteFalseSafe(r,s,e,e1,e2,t2); }\n              assert IsSafe(r,s,If(e,e1,e2),t) by {\n                SubtyCompat(t2,t');\n                SubtyCompat(t',t);\n                SemSubtyTransport(r,s,If(e,e1,e2),t2,t);\n              }\n              assert GuardedEffectsInvariant(If(e,e1,e2),effs3) by {\n                if IsTrueStrong(r,s,If(e,e1,e2)) {\n                  IteTrueStrongFalse(r,s,e,e1,e2);\n                }\n              }\n              assert GuardedEffectsInvariant(If(e,e1,e2),effs1.union(effs2).intersect(effs3)) by {\n                if IsTrueStrong(r,s,If(e,e1,e2)) {\n                  EffectsInvariantIntersectR(effs1.union(effs2),effs3);\n                }\n              }\n            }\n          } else {\n            // `e` produces an error\n            assert IsSafe(r,s,If(e,e1,e2),t) by {\n              IteError(r,s,e,e1,e2,Type.Bool(bt),t);\n            }\n            assert GuardedEffectsInvariant(If(e,e1,e2),effs1.union(effs2).intersect(effs3)) by {\n              IteError(r,s,e,e1,e2,Type.Bool(bt),Type.Bool(True));\n              assert !IsTrueStrong(r,s,If(e,e1,e2));\n            }\n          }\n      }\n    }\n",
        "method_without_assertion_content": "    lemma SoundIf(e: Expr, e1: Expr, e2: Expr, t: Type, effs: Effects)\n      decreases If(e,e1,e2) , 0\n      requires WellFormedRequestAndStore()\n      requires EffectsInvariant(effs)\n      requires Typesafe(If(e,e1,e2),effs,t)\n      ensures IsSafe(r,s,If(e,e1,e2),t)\n      ensures GuardedEffectsInvariant(If(e,e1,e2),getEffects(If(e,e1,e2),effs))\n    {\n      var t' :| getType(If(e,e1,e2),effs) == t' && subty(t',t,ValidationMode.Permissive);\n            var (bt, effs1) := TC.inferBoolType(e,effs).value;\n      assert IsSafe(r,s,e,Type.Bool(bt)) && GuardedEffectsInvariant(e,effs1) by {\n        assert getType(e,effs) == Type.Bool(bt);\n        assert subty(Type.Bool(bt),Type.Bool(bt),ValidationMode.Permissive);\n        assert Typesafe(e,effs,Type.Bool(bt));\n        Sound(e,Type.Bool(bt),effs);\n      }\n      match bt {\n        case True =>\n          assert IsTrue(r,s,e);\n          var (t1,effs2) := TC.infer(e1,effs.union(effs1)).value;\n          assert Typesafe(e1,effs.union(effs1),t1) by { SubtyRefl(t1); }\n          if IsTrueStrong(r,s,e) {\n            assert EffectsInvariant(effs1);\n            assert IsSafe(r,s,e1,t1) && GuardedEffectsInvariant(e1,effs2) by {\n              EffectsInvariantUnion(effs,effs1);\n              Sound(e1,t1,effs.union(effs1));\n            }\n            assert IsSafe(r,s,If(e,e1,e2),t') by { IteTrueSafe(r,s,e,e1,e2,t'); }\n            assert IsSafe(r,s,If(e,e1,e2),t) by {\n              SubtyCompat(t',t);\n              SemSubtyTransport(r,s,If(e,e1,e2),t',t);\n            }\n            assert GuardedEffectsInvariant(If(e,e1,e2),effs1.union(effs2)) by {\n              if IsTrueStrong(r,s,If(e,e1,e2)) {\n                IteTrueStrongTrue(r,s,e,e1,e2);\n                assert EffectsInvariant(effs2);\n                EffectsInvariantUnion(effs1,effs2);\n              }\n            }\n          } else {\n            assert IsSafe(r,s,If(e,e1,e2),t) by {\n              IteError(r,s,e,e1,e2,Type.Bool(True),t);\n            }\n            assert GuardedEffectsInvariant(If(e,e1,e2),effs1.union(effs2)) by {\n              IteError(r,s,e,e1,e2,Type.Bool(True),Type.Bool(True));\n              assert !IsTrueStrong(r,s,If(e,e1,e2));\n            }\n          }\n        case False =>\n          assert IsFalse(r,s,e);\n          var (t2,effs2) := TC.infer(e2,effs).value;\n          assert Typesafe(e2,effs,t2) by { SubtyRefl(t2); }\n          assert IsSafe(r,s,e2,t2) && GuardedEffectsInvariant(e2,effs2) by {\n            Sound(e2,t2,effs);\n          }\n          assert IsSafe(r,s,If(e,e1,e2),t') by { IteFalseSafe(r,s,e,e1,e2,t'); }\n          assert IsSafe(r,s,If(e,e1,e2),t) by {\n            SubtyCompat(t',t);\n            SemSubtyTransport(r,s,If(e,e1,e2),t',t);\n          }\n          assert GuardedEffectsInvariant(If(e,e1,e2),effs2) by {\n            if IsTrueStrong(r,s,If(e,e1,e2)) {\n              IteTrueStrongFalse(r,s,e,e1,e2);\n              assert EffectsInvariant(effs2);\n            }\n          }\n        case AnyBool =>\n          var (t1,effs2) := TC.infer(e1,effs.union(effs1)).value;\n          var (t2,effs3) := TC.infer(e2,effs).value;\n          assert Typesafe(e1,effs.union(effs1),t1) by { SubtyRefl(t1); }\n          assert Typesafe(e2,effs,t2) by { SubtyRefl(t2); }\n          assert t' == lubOpt(t1,t2,ValidationMode.Permissive).value;\n          assert subty(t1,t',ValidationMode.Permissive) && subty(t2,t',ValidationMode.Permissive) by { LubIsUB(t1,t2,t',ValidationMode.Permissive); }\n          if IsSafeStrong(r,s,e,Type.Bool(bt)) {\n            if IsTrue(r,s,e) {\n              // `e` evaluates to true\n              IsTrueImpliesIsTrueStrong(r,s,e,Type.Bool(bt));\n              assert IsTrueStrong(r,s,e);\n              assert EffectsInvariant(effs1);\n              assert IsSafe(r,s,e1,t1) && GuardedEffectsInvariant(e1,effs2) by {\n                EffectsInvariantUnion(effs,effs1);\n                Sound(e1,t1,effs.union(effs1));\n              }\n              assert IsSafe(r,s,If(e,e1,e2),t1) by { IteTrueSafe(r,s,e,e1,e2,t1); }\n              assert IsSafe(r,s,If(e,e1,e2),t) by {\n                SubtyCompat(t1,t');\n                SubtyCompat(t',t);\n                SemSubtyTransport(r,s,If(e,e1,e2),t1,t);\n              }\n              assert GuardedEffectsInvariant(If(e,e1,e2),effs1.union(effs2)) by {\n                if IsTrueStrong(r,s,If(e,e1,e2)) {\n                  IteTrueStrongTrue(r,s,e,e1,e2);\n                  EffectsInvariantUnion(effs1,effs2);\n                }\n              }\n              assert GuardedEffectsInvariant(If(e,e1,e2),effs1.union(effs2).intersect(effs3)) by {\n                if IsTrueStrong(r,s,If(e,e1,e2)) {\n                  EffectsInvariantIntersectL(effs1.union(effs2),effs3);\n                }\n              }\n            } else {\n              // `e` evaluates to false\n              NotTrueImpliesFalse(r,s,e,bt);\n              assert IsFalse(r,s,e);\n              assert IsSafe(r,s,e2,t2) && GuardedEffectsInvariant(e2,effs3) by {\n                Sound(e2,t2,effs);\n              }\n              assert IsSafe(r,s,If(e,e1,e2),t2) by { IteFalseSafe(r,s,e,e1,e2,t2); }\n              assert IsSafe(r,s,If(e,e1,e2),t) by {\n                SubtyCompat(t2,t');\n                SubtyCompat(t',t);\n                SemSubtyTransport(r,s,If(e,e1,e2),t2,t);\n              }\n              assert GuardedEffectsInvariant(If(e,e1,e2),effs3) by {\n                if IsTrueStrong(r,s,If(e,e1,e2)) {\n                  IteTrueStrongFalse(r,s,e,e1,e2);\n                }\n              }\n              assert GuardedEffectsInvariant(If(e,e1,e2),effs1.union(effs2).intersect(effs3)) by {\n                if IsTrueStrong(r,s,If(e,e1,e2)) {\n                  EffectsInvariantIntersectR(effs1.union(effs2),effs3);\n                }\n              }\n            }\n          } else {\n            // `e` produces an error\n            assert IsSafe(r,s,If(e,e1,e2),t) by {\n              IteError(r,s,e,e1,e2,Type.Bool(bt),t);\n            }\n            assert GuardedEffectsInvariant(If(e,e1,e2),effs1.union(effs2).intersect(effs3)) by {\n              IteError(r,s,e,e1,e2,Type.Bool(bt),Type.Bool(True));\n              assert !IsTrueStrong(r,s,If(e,e1,e2));\n            }\n          }\n      }\n    }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "799",
        "method_filepath": "./cedar-dafny/validation/thm/soundness.dfy",
        "method_without_assertion_filename": "SoundIneq_fix_799.dfy",
        "method_name": "SoundIneq",
        "method_content": "    lemma SoundIneq(op: BinaryOp, e1: Expr, e2: Expr, t: Type, effs: Effects)\n      decreases BinaryApp(op,e1,e2) , 0\n      requires op == Less || op == BinaryOp.LessEq\n      requires WellFormedRequestAndStore()\n      requires EffectsInvariant(effs)\n      requires Typesafe(BinaryApp(op,e1,e2),effs,t)\n      ensures IsSafe(r,s,BinaryApp(op,e1,e2),t)\n      ensures getEffects(BinaryApp(op,e1,e2),effs) == Effects.empty()\n    {\n      var t' :| getType(BinaryApp(op,e1,e2),effs) == t' && subty(t',t,ValidationMode.Permissive);\n      assert TC.inferIneq(op,e1,e2,effs) == types.Ok(Type.Bool(AnyBool));\n      assert TC.ensureIntType(e1,effs).Ok?;\n      assert Typesafe(e1,effs,Type.Int);\n      assert TC.ensureIntType(e2,effs).Ok?;\n      assert Typesafe(e2,effs,Type.Int);\n      assert IsSafe(r,s,e1,Type.Int) by { Sound(e1,Type.Int,effs); }\n      assert IsSafe(r,s,e2,Type.Int) by { Sound(e2,Type.Int,effs); }\n      assert IsSafe(r,s,BinaryApp(op,e1,e2),t') by { IneqSafe(r,s,op,e1,e2); }\n      assert IsSafe(r,s,BinaryApp(op,e1,e2),t) by {\n        SubtyCompat(t',t);\n        SemSubtyTransport(r,s,BinaryApp(op,e1,e2),t',t);\n      }\n    }\n",
        "method_without_assertion_content": "    lemma SoundIneq(op: BinaryOp, e1: Expr, e2: Expr, t: Type, effs: Effects)\n      decreases BinaryApp(op,e1,e2) , 0\n      requires op == Less || op == BinaryOp.LessEq\n      requires WellFormedRequestAndStore()\n      requires EffectsInvariant(effs)\n      requires Typesafe(BinaryApp(op,e1,e2),effs,t)\n      ensures IsSafe(r,s,BinaryApp(op,e1,e2),t)\n      ensures getEffects(BinaryApp(op,e1,e2),effs) == Effects.empty()\n    {\n      var t' :| getType(BinaryApp(op,e1,e2),effs) == t' && subty(t',t,ValidationMode.Permissive);\n      assert TC.inferIneq(op,e1,e2,effs) == types.Ok(Type.Bool(AnyBool));\n      assert TC.ensureIntType(e1,effs).Ok?;\n      assert Typesafe(e1,effs,Type.Int);\n            assert Typesafe(e2,effs,Type.Int);\n      assert IsSafe(r,s,e1,Type.Int) by { Sound(e1,Type.Int,effs); }\n      assert IsSafe(r,s,e2,Type.Int) by { Sound(e2,Type.Int,effs); }\n      assert IsSafe(r,s,BinaryApp(op,e1,e2),t') by { IneqSafe(r,s,op,e1,e2); }\n      assert IsSafe(r,s,BinaryApp(op,e1,e2),t) by {\n        SubtyCompat(t',t);\n        SemSubtyTransport(r,s,BinaryApp(op,e1,e2),t',t);\n      }\n    }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "49",
        "method_filepath": "./cedar-dafny/validation/thm/model.dfy",
        "method_without_assertion_filename": "OrSafe_fix_49.dfy",
        "method_name": "OrSafe",
        "method_content": "  lemma OrSafe(r: Request, s: EntityStore, e: Expr, e': Expr)\n    requires IsSafe(r,s,e,Type.Bool(AnyBool))\n    requires IsSafe(r,s,e',Type.Bool(AnyBool))\n    ensures IsSafe(r,s,Or(e,e'),Type.Bool(AnyBool))\n  {\n    reveal IsSafe();\n    if Evaluate(e,r,s).Ok? && Evaluate(e',r,s).Ok? {\n      assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true).Ok?;\n      assert Evaluate(Or(e,e'),r,s).Ok?;\n    } else {\n      if Evaluate(e,r,s).Err? {\n        assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == Evaluate(e,r,s);\n        assert Evaluate(Or(e,e'),r,s) == Evaluate(e,r,s);\n      } else {\n        assert Evaluate(e',r,s).Err?;\n        var b :| Evaluate(e,r,s) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n        if b {\n          assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n          assert Evaluate(Or(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n        } else {\n          assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == Evaluate(e',r,s);\n          assert Evaluate(Or(e,e'),r,s) == Evaluate(e',r,s);\n        }\n      }\n    }\n  }\n",
        "method_without_assertion_content": "  lemma OrSafe(r: Request, s: EntityStore, e: Expr, e': Expr)\n    requires IsSafe(r,s,e,Type.Bool(AnyBool))\n    requires IsSafe(r,s,e',Type.Bool(AnyBool))\n    ensures IsSafe(r,s,Or(e,e'),Type.Bool(AnyBool))\n  {\n    reveal IsSafe();\n    if Evaluate(e,r,s).Ok? && Evaluate(e',r,s).Ok? {\n      assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true).Ok?;\n      assert Evaluate(Or(e,e'),r,s).Ok?;\n    } else {\n      if Evaluate(e,r,s).Err? {\n                assert Evaluate(Or(e,e'),r,s) == Evaluate(e,r,s);\n      } else {\n        assert Evaluate(e',r,s).Err?;\n        var b :| Evaluate(e,r,s) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n        if b {\n          assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n          assert Evaluate(Or(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n        } else {\n          assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == Evaluate(e',r,s);\n          assert Evaluate(Or(e,e'),r,s) == Evaluate(e',r,s);\n        }\n      }\n    }\n  }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "92",
        "method_filepath": "./cedar-dafny/validation/thm/model.dfy",
        "method_without_assertion_filename": "OrRRetSafe_fix_92.dfy",
        "method_name": "OrRRetSafe",
        "method_content": "  lemma OrRRetSafe(r: Request, s: EntityStore, e: Expr, e': Expr, t: Type)\n    requires IsFalse(r,s,e)\n    requires IsSafe(r,s,e',t)\n    requires SemanticSubty(t,Type.Bool(AnyBool))\n    ensures IsSafe(r,s,Or(e,e'),t)\n  {\n    reveal IsSafe();\n    if Evaluate(e,r,s).Ok? && Evaluate(e',r,s).Ok? {\n      assert Evaluate(e,r,s) == base.Ok(Value.Primitive(Primitive.Bool(false)));\n      var v :| Evaluate(e',r,s) == base.Ok(v) && InstanceOfType(v,t);\n      assert InstanceOfType(v,Type.Bool(AnyBool)) by {\n        SemSubtyTransportVal(t,Type.Bool(AnyBool),v);\n      }\n      var b :| v == Value.Primitive(Primitive.Bool(b));\n      assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n      assert Evaluate(Or(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n      assert IsSafe(r,s,e',Type.Bool(AnyBool)) by {\n        SemSubtyTransport(r,s,e',t,Type.Bool(AnyBool));\n      }\n    } else {\n      if Evaluate(e,r,s).Err? {\n        assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == Evaluate(e,r,s);\n        assert Evaluate(Or(e,e'),r,s) == Evaluate(e,r,s);\n      } else {\n        assert Evaluate(e',r,s).Err?;\n        var b :| Evaluate(e,r,s) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n        if b {\n          assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n          assert Evaluate(Or(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n        } else {\n          assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == Evaluate(e',r,s);\n          assert Evaluate(Or(e,e'),r,s) == Evaluate(e',r,s);\n        }\n      }\n    }\n  }\n",
        "method_without_assertion_content": "  lemma OrRRetSafe(r: Request, s: EntityStore, e: Expr, e': Expr, t: Type)\n    requires IsFalse(r,s,e)\n    requires IsSafe(r,s,e',t)\n    requires SemanticSubty(t,Type.Bool(AnyBool))\n    ensures IsSafe(r,s,Or(e,e'),t)\n  {\n    reveal IsSafe();\n    if Evaluate(e,r,s).Ok? && Evaluate(e',r,s).Ok? {\n      assert Evaluate(e,r,s) == base.Ok(Value.Primitive(Primitive.Bool(false)));\n      var v :| Evaluate(e',r,s) == base.Ok(v) && InstanceOfType(v,t);\n      assert InstanceOfType(v,Type.Bool(AnyBool)) by {\n        SemSubtyTransportVal(t,Type.Bool(AnyBool),v);\n      }\n      var b :| v == Value.Primitive(Primitive.Bool(b));\n            assert Evaluate(Or(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n      assert IsSafe(r,s,e',Type.Bool(AnyBool)) by {\n        SemSubtyTransport(r,s,e',t,Type.Bool(AnyBool));\n      }\n    } else {\n      if Evaluate(e,r,s).Err? {\n        assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == Evaluate(e,r,s);\n        assert Evaluate(Or(e,e'),r,s) == Evaluate(e,r,s);\n      } else {\n        assert Evaluate(e',r,s).Err?;\n        var b :| Evaluate(e,r,s) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n        if b {\n          assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n          assert Evaluate(Or(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n        } else {\n          assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == Evaluate(e',r,s);\n          assert Evaluate(Or(e,e'),r,s) == Evaluate(e',r,s);\n        }\n      }\n    }\n  }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "791",
        "method_filepath": "./cedar-dafny/validation/thm/soundness.dfy",
        "method_without_assertion_filename": "SoundArith_fix_791.dfy",
        "method_name": "SoundArith",
        "method_content": "    lemma SoundArith(op: BinaryOp, e1: Expr, e2: Expr, t: Type, effs: Effects)\n      decreases BinaryApp(op,e1,e2) , 0\n      requires op == Add || op == Sub\n      requires WellFormedRequestAndStore()\n      requires EffectsInvariant(effs)\n      requires Typesafe(BinaryApp(op,e1,e2),effs,t)\n      ensures IsSafe(r,s,BinaryApp(op,e1,e2),t)\n      ensures getEffects(BinaryApp(op,e1,e2),effs) == Effects.empty()\n    {\n      var t' :| getType(BinaryApp(op,e1,e2),effs) == t' && subty(t',t,ValidationMode.Permissive);\n      assert TC.inferArith2(op,e1,e2,effs) == types.Ok(Type.Int);\n      assert TC.ensureIntType(e1,effs).Ok?;\n      assert Typesafe(e1,effs,Type.Int);\n      assert TC.ensureIntType(e2,effs).Ok?;\n      assert Typesafe(e2,effs,Type.Int);\n      assert IsSafe(r,s,e1,Type.Int) by { Sound(e1,Type.Int,effs); }\n      assert IsSafe(r,s,e2,Type.Int) by { Sound(e2,Type.Int,effs); }\n      assert IsSafe(r,s,BinaryApp(op,e1,e2),t') by { ArithSafe(r,s,op,e1,e2); }\n      assert IsSafe(r,s,BinaryApp(op,e1,e2),t) by {\n        SubtyCompat(t',t);\n        SemSubtyTransport(r,s,BinaryApp(op,e1,e2),t',t);\n      }\n    }\n",
        "method_without_assertion_content": "    lemma SoundArith(op: BinaryOp, e1: Expr, e2: Expr, t: Type, effs: Effects)\n      decreases BinaryApp(op,e1,e2) , 0\n      requires op == Add || op == Sub\n      requires WellFormedRequestAndStore()\n      requires EffectsInvariant(effs)\n      requires Typesafe(BinaryApp(op,e1,e2),effs,t)\n      ensures IsSafe(r,s,BinaryApp(op,e1,e2),t)\n      ensures getEffects(BinaryApp(op,e1,e2),effs) == Effects.empty()\n    {\n      var t' :| getType(BinaryApp(op,e1,e2),effs) == t' && subty(t',t,ValidationMode.Permissive);\n      assert TC.inferArith2(op,e1,e2,effs) == types.Ok(Type.Int);\n      assert TC.ensureIntType(e1,effs).Ok?;\n      assert Typesafe(e1,effs,Type.Int);\n            assert Typesafe(e2,effs,Type.Int);\n      assert IsSafe(r,s,e1,Type.Int) by { Sound(e1,Type.Int,effs); }\n      assert IsSafe(r,s,e2,Type.Int) by { Sound(e2,Type.Int,effs); }\n      assert IsSafe(r,s,BinaryApp(op,e1,e2),t') by { ArithSafe(r,s,op,e1,e2); }\n      assert IsSafe(r,s,BinaryApp(op,e1,e2),t) by {\n        SubtyCompat(t',t);\n        SemSubtyTransport(r,s,BinaryApp(op,e1,e2),t',t);\n      }\n    }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "873",
        "method_filepath": "./cedar-dafny/thm/eval/basic.dfy",
        "method_without_assertion_filename": "RecordSemanticsOkAttrs_fix_873.dfy",
        "method_name": "RecordSemanticsOkAttrs",
        "method_content": "  lemma RecordSemanticsOkAttrs(es: seq<(Attr, Expr)>, E: Evaluator)\n    requires E.interpretRecord(es).Ok?\n    ensures E.interpretRecord(es).value.Keys == set e | e in es :: e.0\n  {\n    if es != [] {\n      RecordSemanticsOkAttrs(es[1..], E);\n      var rec' := E.interpretRecord(es[1..]).value;\n      if es[0].0 in rec'.Keys {\n        assert E.interpretRecord(es).value == rec';\n        assert (set e | e in es :: e.0) == (set e | e in es[1..] :: e.0);\n      } else {\n        assert E.interpretRecord(es).value == rec'[es[0].0 := E.interpret(es[0].1).value];\n        assert (set e | e in es :: e.0) == (set e | e in es[1..] :: e.0) + {es[0].0};\n      }\n    }\n  }\n",
        "method_without_assertion_content": "  lemma RecordSemanticsOkAttrs(es: seq<(Attr, Expr)>, E: Evaluator)\n    requires E.interpretRecord(es).Ok?\n    ensures E.interpretRecord(es).value.Keys == set e | e in es :: e.0\n  {\n    if es != [] {\n      RecordSemanticsOkAttrs(es[1..], E);\n      var rec' := E.interpretRecord(es[1..]).value;\n      if es[0].0 in rec'.Keys {\n        assert E.interpretRecord(es).value == rec';\n        assert (set e | e in es :: e.0) == (set e | e in es[1..] :: e.0);\n      } else {\n        assert E.interpretRecord(es).value == rec'[es[0].0 := E.interpret(es[0].1).value];\n              }\n    }\n  }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "45",
        "method_filepath": "./cedar-dafny/validation/thm/model.dfy",
        "method_without_assertion_filename": "AndTrueStrong_fix_45.dfy",
        "method_name": "AndTrueStrong",
        "method_content": "  lemma AndTrueStrong(r: Request, s: EntityStore, e1: Expr, e2: Expr)\n    requires IsTrue(r,s,e1)\n    requires IsTrueStrong(r,s,And(e1,e2))\n    ensures IsTrueStrong(r,s,e2)\n  {\n    reveal IsSafeStrong();\n    reveal IsSafe();\n    assert Evaluator(r,s).interpretShortcircuit(And(e1,e2),e1,e2,false) == base.Ok(Value.Bool(true));\n  }\n",
        "method_without_assertion_content": "  lemma AndTrueStrong(r: Request, s: EntityStore, e1: Expr, e2: Expr)\n    requires IsTrue(r,s,e1)\n    requires IsTrueStrong(r,s,And(e1,e2))\n    ensures IsTrueStrong(r,s,e2)\n  {\n    reveal IsSafeStrong();\n    reveal IsSafe();\n      }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "750",
        "method_filepath": "./cedar-dafny/validation/thm/soundness.dfy",
        "method_without_assertion_filename": "SoundLike_fix_750.dfy",
        "method_name": "SoundLike",
        "method_content": "    lemma SoundLike(e: Expr, p: Pattern, t: Type, effs: Effects)\n      decreases UnaryApp(Like(p),e) , 0\n      requires WellFormedRequestAndStore()\n      requires EffectsInvariant(effs)\n      requires Typesafe(UnaryApp(Like(p),e),effs,t)\n      ensures IsSafe(r,s,UnaryApp(Like(p),e),t)\n      ensures getEffects(UnaryApp(Like(p),e),effs) == Effects.empty()\n    {\n      var t' :| getType(UnaryApp(Like(p),e),effs) == t' && subty(t',t,ValidationMode.Permissive);\n      assert TC.inferLike(p,e,effs) == types.Ok(Type.Bool(AnyBool));\n      assert TC.ensureStringType(e,effs).Ok?;\n      assert Typesafe(e,effs,Type.String);\n      assert IsSafe(r,s,e,Type.String) by { Sound(e,Type.String,effs); }\n      assert IsSafe(r,s,UnaryApp(Like(p),e),t') by { LikeSafe(r,s,e,p); }\n      assert IsSafe(r,s,UnaryApp(Like(p),e),t) by {\n        SubtyCompat(t',t);\n        SemSubtyTransport(r,s,UnaryApp(Like(p),e),t',t);\n      }\n    }\n",
        "method_without_assertion_content": "    lemma SoundLike(e: Expr, p: Pattern, t: Type, effs: Effects)\n      decreases UnaryApp(Like(p),e) , 0\n      requires WellFormedRequestAndStore()\n      requires EffectsInvariant(effs)\n      requires Typesafe(UnaryApp(Like(p),e),effs,t)\n      ensures IsSafe(r,s,UnaryApp(Like(p),e),t)\n      ensures getEffects(UnaryApp(Like(p),e),effs) == Effects.empty()\n    {\n      var t' :| getType(UnaryApp(Like(p),e),effs) == t' && subty(t',t,ValidationMode.Permissive);\n            assert TC.ensureStringType(e,effs).Ok?;\n      assert Typesafe(e,effs,Type.String);\n      assert IsSafe(r,s,e,Type.String) by { Sound(e,Type.String,effs); }\n      assert IsSafe(r,s,UnaryApp(Like(p),e),t') by { LikeSafe(r,s,e,p); }\n      assert IsSafe(r,s,UnaryApp(Like(p),e),t) by {\n        SubtyCompat(t',t);\n        SemSubtyTransport(r,s,UnaryApp(Like(p),e),t',t);\n      }\n    }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "820",
        "method_filepath": "./cedar-dafny/validation/thm/soundness.dfy",
        "method_without_assertion_filename": "SoundInSetMemberFalse_fix_820.dfy",
        "method_name": "SoundInSetMemberFalse",
        "method_content": "    lemma SoundInSetMemberFalse(e1: Expr, ei2s: seq<Expr>, i: nat, effs: Effects)\n      decreases BinaryApp(BinaryOp.In,e1,Expr.Set(ei2s)) , 0 , Expr.Set(ei2s) , 0\n      requires WellFormedRequestAndStore()\n      requires EffectsInvariant(effs)\n      requires WellTyped(BinaryApp(BinaryOp.In,e1,Expr.Set(ei2s)),effs)\n      requires getType(BinaryApp(BinaryOp.In,e1,Expr.Set(ei2s)),effs) == Type.Bool(False)\n      requires !reqty.isUnspecifiedVar(e1)\n      requires 0 <= i < |ei2s|\n      ensures IsFalse(r,s,BinaryApp(BinaryOp.In,e1,ei2s[i]))\n    {\n      // Reestablishing things we had at the call site in `SoundIn`.\n      var e2 := Expr.Set(ei2s);\n\n      assert TC.inferIn(BinaryApp(BinaryOp.In,e1,e2),e1,e2,effs) == types.Ok(Type.Bool(False));\n\n      assert TC.ensureEntityType(e1,effs).Ok?;\n      var t1 := getType(e1,effs);\n\n      var euids2 :- assert TC.tryGetEUIDs(e2);\n      var ets2 := set u <- euids2 :: u.ty;\n\n      // New proof.\n      var u2 :- assert TC.tryGetEUID(ei2s[i]);\n      assert u2 in euids2;\n      match e1 {\n        case Var(v1) =>\n          var et1 :- assert TC.getPrincipalOrResource(v1);\n          assert t1 == Type.Entity(EntityLUB({et1}));\n          assert IsSafe(r,s,Var(v1),t1) by { Sound(e1,t1,effs); }\n          assert !ets.possibleDescendantOf(et1,u2.ty);\n          reveal WellFormedRequestAndStore();\n          InSingleFalseEntityTypeAndLiteral(r,s,e1,et1,u2);\n        case PrimitiveLit(EntityUID(u1)) =>\n          if isAction(u1.ty) {\n            assert !acts.descendantOfSet(u1,euids2);\n            assert !acts.descendantOf(u1,u2);\n          } else {\n            assert !ets.possibleDescendantOfSet(u1.ty,ets2);\n            assert !ets.possibleDescendantOf(u1.ty,u2.ty);\n          }\n          reveal WellFormedRequestAndStore();\n          InSingleFalseLiterals(r,s,u1,u2);\n      }\n    }\n",
        "method_without_assertion_content": "    lemma SoundInSetMemberFalse(e1: Expr, ei2s: seq<Expr>, i: nat, effs: Effects)\n      decreases BinaryApp(BinaryOp.In,e1,Expr.Set(ei2s)) , 0 , Expr.Set(ei2s) , 0\n      requires WellFormedRequestAndStore()\n      requires EffectsInvariant(effs)\n      requires WellTyped(BinaryApp(BinaryOp.In,e1,Expr.Set(ei2s)),effs)\n      requires getType(BinaryApp(BinaryOp.In,e1,Expr.Set(ei2s)),effs) == Type.Bool(False)\n      requires !reqty.isUnspecifiedVar(e1)\n      requires 0 <= i < |ei2s|\n      ensures IsFalse(r,s,BinaryApp(BinaryOp.In,e1,ei2s[i]))\n    {\n      // Reestablishing things we had at the call site in `SoundIn`.\n      var e2 := Expr.Set(ei2s);\n\n      assert TC.inferIn(BinaryApp(BinaryOp.In,e1,e2),e1,e2,effs) == types.Ok(Type.Bool(False));\n\n      assert TC.ensureEntityType(e1,effs).Ok?;\n      var t1 := getType(e1,effs);\n\n      var euids2 :- assert TC.tryGetEUIDs(e2);\n      var ets2 := set u <- euids2 :: u.ty;\n\n      // New proof.\n      var u2 :- assert TC.tryGetEUID(ei2s[i]);\n      assert u2 in euids2;\n      match e1 {\n        case Var(v1) =>\n          var et1 :- assert TC.getPrincipalOrResource(v1);\n          assert t1 == Type.Entity(EntityLUB({et1}));\n          assert IsSafe(r,s,Var(v1),t1) by { Sound(e1,t1,effs); }\n          assert !ets.possibleDescendantOf(et1,u2.ty);\n          reveal WellFormedRequestAndStore();\n          InSingleFalseEntityTypeAndLiteral(r,s,e1,et1,u2);\n        case PrimitiveLit(EntityUID(u1)) =>\n          if isAction(u1.ty) {\n            assert !acts.descendantOfSet(u1,euids2);\n            assert !acts.descendantOf(u1,u2);\n          } else {\n            assert !ets.possibleDescendantOfSet(u1.ty,ets2);\n                      }\n          reveal WellFormedRequestAndStore();\n          InSingleFalseLiterals(r,s,u1,u2);\n      }\n    }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "862",
        "method_filepath": "./cedar-dafny/validation/thm/strict_soundness.dfy",
        "method_without_assertion_filename": "StrictIn_fix_862.dfy",
        "method_name": "StrictIn",
        "method_content": "    lemma StrictIn(e1: Expr, e2: Expr, effs: Effects)\n      decreases BinaryApp(BinaryOp.In, e1, e2), 0\n      requires S_TC.infer(BinaryApp(BinaryOp.In, e1, e2), effs).Ok?\n      ensures P_TC.infer(BinaryApp(BinaryOp.In, e1, e2), effs) == S_TC.infer(BinaryApp(BinaryOp.In, e1, e2), effs)\n    {\n      assert S_TC.ensureEntityType(e1,effs).Ok?;\n      assert P_TC.ensureEntityType(e1,effs).Ok? by { StrictTypecheckingIsStrict(e1, effs); }\n\n      assert S_TC.ensureEntitySetType(e2,effs).Ok?;\n      assert P_TC.ensureEntitySetType(e2,effs).Ok? by { StrictTypecheckingIsStrict(e2, effs); }\n\n      var (t2, effs') := S_TC.infer(e2,effs).value;\n      assert P_TC.infer(e2, effs) == Ok((t2, effs')) by { StrictTypecheckingIsStrict(e2, effs); }\n    }\n",
        "method_without_assertion_content": "    lemma StrictIn(e1: Expr, e2: Expr, effs: Effects)\n      decreases BinaryApp(BinaryOp.In, e1, e2), 0\n      requires S_TC.infer(BinaryApp(BinaryOp.In, e1, e2), effs).Ok?\n      ensures P_TC.infer(BinaryApp(BinaryOp.In, e1, e2), effs) == S_TC.infer(BinaryApp(BinaryOp.In, e1, e2), effs)\n    {\n            assert P_TC.ensureEntityType(e1,effs).Ok? by { StrictTypecheckingIsStrict(e1, effs); }\n\n      assert S_TC.ensureEntitySetType(e2,effs).Ok?;\n      assert P_TC.ensureEntitySetType(e2,effs).Ok? by { StrictTypecheckingIsStrict(e2, effs); }\n\n      var (t2, effs') := S_TC.infer(e2,effs).value;\n      assert P_TC.infer(e2, effs) == Ok((t2, effs')) by { StrictTypecheckingIsStrict(e2, effs); }\n    }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "801",
        "method_filepath": "./cedar-dafny/validation/thm/soundness.dfy",
        "method_without_assertion_filename": "SoundMulBy_fix_801.dfy",
        "method_name": "SoundMulBy",
        "method_content": "    lemma SoundMulBy(i: int, e: Expr, t: Type, effs: Effects)\n      decreases UnaryApp(MulBy(i),e) , 0\n      requires WellFormedRequestAndStore()\n      requires EffectsInvariant(effs)\n      requires Typesafe(UnaryApp(MulBy(i),e),effs,t)\n      ensures IsSafe(r,s,UnaryApp(MulBy(i),e),t)\n      ensures getEffects(UnaryApp(MulBy(i),e),effs) == Effects.empty()\n    {\n      var t' :| getType(UnaryApp(MulBy(i),e),effs) == t' && subty(t',t,ValidationMode.Permissive);\n      assert TC.inferArith1(MulBy(i),e,effs) == types.Ok(Type.Int);\n      assert TC.ensureIntType(e,effs).Ok?;\n      assert Typesafe(e,effs,Type.Int);\n      assert IsSafe(r,s,e,Type.Int) by { Sound(e,Type.Int,effs); }\n      assert IsSafe(r,s,UnaryApp(MulBy(i),e),t') by { MulBySafe(r,s,e,i); }\n      assert IsSafe(r,s,UnaryApp(MulBy(i),e),t) by {\n        SubtyCompat(t',t);\n        SemSubtyTransport(r,s,UnaryApp(MulBy(i),e),t',t);\n      }\n    }\n",
        "method_without_assertion_content": "    lemma SoundMulBy(i: int, e: Expr, t: Type, effs: Effects)\n      decreases UnaryApp(MulBy(i),e) , 0\n      requires WellFormedRequestAndStore()\n      requires EffectsInvariant(effs)\n      requires Typesafe(UnaryApp(MulBy(i),e),effs,t)\n      ensures IsSafe(r,s,UnaryApp(MulBy(i),e),t)\n      ensures getEffects(UnaryApp(MulBy(i),e),effs) == Effects.empty()\n    {\n      var t' :| getType(UnaryApp(MulBy(i),e),effs) == t' && subty(t',t,ValidationMode.Permissive);\n            assert TC.ensureIntType(e,effs).Ok?;\n      assert Typesafe(e,effs,Type.Int);\n      assert IsSafe(r,s,e,Type.Int) by { Sound(e,Type.Int,effs); }\n      assert IsSafe(r,s,UnaryApp(MulBy(i),e),t') by { MulBySafe(r,s,e,i); }\n      assert IsSafe(r,s,UnaryApp(MulBy(i),e),t) by {\n        SubtyCompat(t',t);\n        SemSubtyTransport(r,s,UnaryApp(MulBy(i),e),t',t);\n      }\n    }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "883",
        "method_filepath": "./cedar-dafny/def/util.dfy",
        "method_without_assertion_filename": "SeqAddInequality_fix_883.dfy",
        "method_name": "SeqAddInequality",
        "method_content": "  lemma SeqAddInequality<T>(s1: seq<T>, t1: T, s2: seq<T>, t2: T)\n    requires s1 != s2 || t1 != t2\n    ensures s1 + [t1] != s2 + [t2]\n  {\n    if s1 == s2 {\n      assert t1 != t2;\n      var len := |s1|;\n      assert (s1 + [t1])[len] != (s2 + [t2])[len];\n    } else if |s1| == |s2| {\n      var i :| 0 <= i < |s1| && s1[i] != s2[i];\n      assert (s1 + [t1])[i] != (s2 + [t2])[i];\n    } else {\n      assert |s1 + [t1]| != |s2 + [t2]|;\n    }\n  }\n",
        "method_without_assertion_content": "  lemma SeqAddInequality<T>(s1: seq<T>, t1: T, s2: seq<T>, t2: T)\n    requires s1 != s2 || t1 != t2\n    ensures s1 + [t1] != s2 + [t2]\n  {\n    if s1 == s2 {\n      assert t1 != t2;\n      var len := |s1|;\n      assert (s1 + [t1])[len] != (s2 + [t2])[len];\n    } else if |s1| == |s2| {\n      var i :| 0 <= i < |s1| && s1[i] != s2[i];\n          } else {\n      assert |s1 + [t1]| != |s2 + [t2]|;\n    }\n  }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "802",
        "method_filepath": "./cedar-dafny/validation/thm/soundness.dfy",
        "method_without_assertion_filename": "SoundMulBy_fix_802.dfy",
        "method_name": "SoundMulBy",
        "method_content": "    lemma SoundMulBy(i: int, e: Expr, t: Type, effs: Effects)\n      decreases UnaryApp(MulBy(i),e) , 0\n      requires WellFormedRequestAndStore()\n      requires EffectsInvariant(effs)\n      requires Typesafe(UnaryApp(MulBy(i),e),effs,t)\n      ensures IsSafe(r,s,UnaryApp(MulBy(i),e),t)\n      ensures getEffects(UnaryApp(MulBy(i),e),effs) == Effects.empty()\n    {\n      var t' :| getType(UnaryApp(MulBy(i),e),effs) == t' && subty(t',t,ValidationMode.Permissive);\n      assert TC.inferArith1(MulBy(i),e,effs) == types.Ok(Type.Int);\n      assert TC.ensureIntType(e,effs).Ok?;\n      assert Typesafe(e,effs,Type.Int);\n      assert IsSafe(r,s,e,Type.Int) by { Sound(e,Type.Int,effs); }\n      assert IsSafe(r,s,UnaryApp(MulBy(i),e),t') by { MulBySafe(r,s,e,i); }\n      assert IsSafe(r,s,UnaryApp(MulBy(i),e),t) by {\n        SubtyCompat(t',t);\n        SemSubtyTransport(r,s,UnaryApp(MulBy(i),e),t',t);\n      }\n    }\n",
        "method_without_assertion_content": "    lemma SoundMulBy(i: int, e: Expr, t: Type, effs: Effects)\n      decreases UnaryApp(MulBy(i),e) , 0\n      requires WellFormedRequestAndStore()\n      requires EffectsInvariant(effs)\n      requires Typesafe(UnaryApp(MulBy(i),e),effs,t)\n      ensures IsSafe(r,s,UnaryApp(MulBy(i),e),t)\n      ensures getEffects(UnaryApp(MulBy(i),e),effs) == Effects.empty()\n    {\n      var t' :| getType(UnaryApp(MulBy(i),e),effs) == t' && subty(t',t,ValidationMode.Permissive);\n      assert TC.inferArith1(MulBy(i),e,effs) == types.Ok(Type.Int);\n            assert Typesafe(e,effs,Type.Int);\n      assert IsSafe(r,s,e,Type.Int) by { Sound(e,Type.Int,effs); }\n      assert IsSafe(r,s,UnaryApp(MulBy(i),e),t') by { MulBySafe(r,s,e,i); }\n      assert IsSafe(r,s,UnaryApp(MulBy(i),e),t) by {\n        SubtyCompat(t',t);\n        SemSubtyTransport(r,s,UnaryApp(MulBy(i),e),t',t);\n      }\n    }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "890",
        "method_filepath": "./cedar-dafny/def/ext/ipaddr.dfy",
        "method_without_assertion_filename": "CountDCLast_fix_890.dfy",
        "method_name": "CountDCLast",
        "method_content": "  lemma CountDCLast(s: seq<numV6>)\n    ensures countDC(wrapNumSegs(s)+[DC]) == 1\n  {\n    if |s| == 0 {\n\n    } else {\n      assert wrapNumSegs(s)+[DC] == wrapNumSegs([s[0]]) + (wrapNumSegs(s[1..]) + [DC]);\n    }\n  }\n",
        "method_without_assertion_content": "  lemma CountDCLast(s: seq<numV6>)\n    ensures countDC(wrapNumSegs(s)+[DC]) == 1\n  {\n    if |s| == 0 {\n\n    } else {\n          }\n  }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "99",
        "method_filepath": "./cedar-dafny/validation/thm/model.dfy",
        "method_without_assertion_filename": "OrRRetSafe_fix_99.dfy",
        "method_name": "OrRRetSafe",
        "method_content": "  lemma OrRRetSafe(r: Request, s: EntityStore, e: Expr, e': Expr, t: Type)\n    requires IsFalse(r,s,e)\n    requires IsSafe(r,s,e',t)\n    requires SemanticSubty(t,Type.Bool(AnyBool))\n    ensures IsSafe(r,s,Or(e,e'),t)\n  {\n    reveal IsSafe();\n    if Evaluate(e,r,s).Ok? && Evaluate(e',r,s).Ok? {\n      assert Evaluate(e,r,s) == base.Ok(Value.Primitive(Primitive.Bool(false)));\n      var v :| Evaluate(e',r,s) == base.Ok(v) && InstanceOfType(v,t);\n      assert InstanceOfType(v,Type.Bool(AnyBool)) by {\n        SemSubtyTransportVal(t,Type.Bool(AnyBool),v);\n      }\n      var b :| v == Value.Primitive(Primitive.Bool(b));\n      assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n      assert Evaluate(Or(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n      assert IsSafe(r,s,e',Type.Bool(AnyBool)) by {\n        SemSubtyTransport(r,s,e',t,Type.Bool(AnyBool));\n      }\n    } else {\n      if Evaluate(e,r,s).Err? {\n        assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == Evaluate(e,r,s);\n        assert Evaluate(Or(e,e'),r,s) == Evaluate(e,r,s);\n      } else {\n        assert Evaluate(e',r,s).Err?;\n        var b :| Evaluate(e,r,s) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n        if b {\n          assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n          assert Evaluate(Or(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n        } else {\n          assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == Evaluate(e',r,s);\n          assert Evaluate(Or(e,e'),r,s) == Evaluate(e',r,s);\n        }\n      }\n    }\n  }\n",
        "method_without_assertion_content": "  lemma OrRRetSafe(r: Request, s: EntityStore, e: Expr, e': Expr, t: Type)\n    requires IsFalse(r,s,e)\n    requires IsSafe(r,s,e',t)\n    requires SemanticSubty(t,Type.Bool(AnyBool))\n    ensures IsSafe(r,s,Or(e,e'),t)\n  {\n    reveal IsSafe();\n    if Evaluate(e,r,s).Ok? && Evaluate(e',r,s).Ok? {\n      assert Evaluate(e,r,s) == base.Ok(Value.Primitive(Primitive.Bool(false)));\n      var v :| Evaluate(e',r,s) == base.Ok(v) && InstanceOfType(v,t);\n      assert InstanceOfType(v,Type.Bool(AnyBool)) by {\n        SemSubtyTransportVal(t,Type.Bool(AnyBool),v);\n      }\n      var b :| v == Value.Primitive(Primitive.Bool(b));\n      assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n      assert Evaluate(Or(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n      assert IsSafe(r,s,e',Type.Bool(AnyBool)) by {\n        SemSubtyTransport(r,s,e',t,Type.Bool(AnyBool));\n      }\n    } else {\n      if Evaluate(e,r,s).Err? {\n        assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == Evaluate(e,r,s);\n        assert Evaluate(Or(e,e'),r,s) == Evaluate(e,r,s);\n      } else {\n        assert Evaluate(e',r,s).Err?;\n        var b :| Evaluate(e,r,s) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n        if b {\n          assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n          assert Evaluate(Or(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n        } else {\n                    assert Evaluate(Or(e,e'),r,s) == Evaluate(e',r,s);\n        }\n      }\n    }\n  }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "852",
        "method_filepath": "./cedar-dafny/validation/thm/strict_inf_strict.dfy",
        "method_without_assertion_filename": "StrictGetAttr_fix_852.dfy",
        "method_name": "StrictGetAttr",
        "method_content": "    lemma StrictGetAttr(e: Expr, l: Attr, effs:Effects)\n      decreases GetAttr(e, l), 0\n      requires strictEnvironment()\n      requires S_TC.infer(GetAttr(e, l), effs).Ok?\n      ensures S_TC.infer(GetAttr(e, l), effs).value.0.isStrictType()\n    {\n      assert S_TC.inferRecordEntityType(e,effs).Ok?;\n      StrictTypeInf(e, effs);\n    }\n",
        "method_without_assertion_content": "    lemma StrictGetAttr(e: Expr, l: Attr, effs:Effects)\n      decreases GetAttr(e, l), 0\n      requires strictEnvironment()\n      requires S_TC.infer(GetAttr(e, l), effs).Ok?\n      ensures S_TC.infer(GetAttr(e, l), effs).value.0.isStrictType()\n    {\n            StrictTypeInf(e, effs);\n    }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "37",
        "method_filepath": "./cedar-dafny/validation/thm/model.dfy",
        "method_without_assertion_filename": "EqEntityDiffSafe_fix_37.dfy",
        "method_name": "EqEntityDiffSafe",
        "method_content": "  lemma EqEntityDiffSafe(r: Request, s: EntityStore, E: EntityUID, E': EntityUID)\n    requires E != E'\n    ensures IsFalse(r,s,Expr.BinaryApp(BinaryOp.Eq,PrimitiveLit(Primitive.EntityUID(E)),PrimitiveLit(Primitive.EntityUID(E'))))\n  {\n    reveal IsSafe();\n    var e := Expr.BinaryApp(BinaryOp.Eq,PrimitiveLit(Primitive.EntityUID(E)),PrimitiveLit(Primitive.EntityUID(E')));\n    assert Evaluator(r,s).interpret(e) == base.Ok(Value.Primitive(Primitive.Bool(false)));\n  }\n",
        "method_without_assertion_content": "  lemma EqEntityDiffSafe(r: Request, s: EntityStore, E: EntityUID, E': EntityUID)\n    requires E != E'\n    ensures IsFalse(r,s,Expr.BinaryApp(BinaryOp.Eq,PrimitiveLit(Primitive.EntityUID(E)),PrimitiveLit(Primitive.EntityUID(E'))))\n  {\n    reveal IsSafe();\n    var e := Expr.BinaryApp(BinaryOp.Eq,PrimitiveLit(Primitive.EntityUID(E)),PrimitiveLit(Primitive.EntityUID(E')));\n      }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "4",
        "method_filepath": "./cedar-dafny/validation/subtyping.dfy",
        "method_without_assertion_filename": "StrictTypeLub_fix_4.dfy",
        "method_name": "StrictTypeLub",
        "method_content": "  lemma StrictTypeLub(t1: Type, t2: Type)\n    requires t1.isStrictType() || t1 == Never\n    requires t2.isStrictType() || t2 == Never\n    requires t1 != Never || t2 != Never\n    requires LubDefined(t1, t2, ValidationMode.Strict)\n    ensures lub(t1, t2, ValidationMode.Strict).isStrictType()\n  {\n    match (t1,t2) {\n      case (Never,_) =>\n      case (_,Never) =>\n      case (Int,Int) =>\n      case (String,String) =>\n      case (Bool(b1),Bool(b2)) =>\n      case (Entity(e1),Entity(e2)) => assert e1 == e1.union(e2);\n      case (Set(t1'),Set(t2')) => StrictTypeLub(t1', t2');\n      case (Record(rt1),Record(rt2)) => {\n        var strict_attrs :=\n          map k | k in rt1.attrs.Keys && k in rt2.attrs.Keys && lubOpt(rt1.attrs[k].ty, rt2.attrs[k].ty, ValidationMode.Strict).Ok? ::\n            lubAttrType(rt1.attrs[k], rt2.attrs[k], ValidationMode.Strict);\n        assert strict_attrs == lubRecordType(rt1, rt2, ValidationMode.Strict).value.attrs;\n\n        forall k | k in strict_attrs.Keys\n          ensures strict_attrs[k].ty.isStrictType()\n        {\n          StrictTypeLub(rt1.attrs[k].ty, rt2.attrs[k].ty);\n        }\n      }\n      case (Extension(n1),Extension(n2)) =>\n    }\n  }\n",
        "method_without_assertion_content": "  lemma StrictTypeLub(t1: Type, t2: Type)\n    requires t1.isStrictType() || t1 == Never\n    requires t2.isStrictType() || t2 == Never\n    requires t1 != Never || t2 != Never\n    requires LubDefined(t1, t2, ValidationMode.Strict)\n    ensures lub(t1, t2, ValidationMode.Strict).isStrictType()\n  {\n    match (t1,t2) {\n      case (Never,_) =>\n      case (_,Never) =>\n      case (Int,Int) =>\n      case (String,String) =>\n      case (Bool(b1),Bool(b2)) =>\n      case (Entity(e1),Entity(e2)) => assert e1 == e1.union(e2);\n      case (Set(t1'),Set(t2')) => StrictTypeLub(t1', t2');\n      case (Record(rt1),Record(rt2)) => {\n        var strict_attrs :=\n          map k | k in rt1.attrs.Keys && k in rt2.attrs.Keys && lubOpt(rt1.attrs[k].ty, rt2.attrs[k].ty, ValidationMode.Strict).Ok? ::\n            lubAttrType(rt1.attrs[k], rt2.attrs[k], ValidationMode.Strict);\n        \n        forall k | k in strict_attrs.Keys\n          ensures strict_attrs[k].ty.isStrictType()\n        {\n          StrictTypeLub(rt1.attrs[k].ty, rt2.attrs[k].ty);\n        }\n      }\n      case (Extension(n1),Extension(n2)) =>\n    }\n  }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "855",
        "method_filepath": "./cedar-dafny/validation/thm/strict_soundness.dfy",
        "method_without_assertion_filename": "StrictGetLubRecordType_fix_855.dfy",
        "method_name": "StrictGetLubRecordType",
        "method_content": "    lemma StrictGetLubRecordType(lub: EntityLUB)\n      requires ets.getLubRecordType(lub, ValidationMode.Strict).Ok?\n      ensures ets.getLubRecordType(lub, ValidationMode.Permissive) == ets.getLubRecordType(lub, ValidationMode.Strict)\n    {\n      if lub.AnyEntity? || exists et <- lub.tys :: isAction(et) {\n        assert ets.getLubRecordType(lub, ValidationMode.Permissive).Ok?;\n      } else {\n        assert forall et <- lub.tys :: et in ets.types;\n        def.util.EntityTypeLeqIsTotalOrder();\n        var lubSeq := def.util.SetToSortedSeq(lub.tys,def.util.EntityTypeLeq);\n        var s := seq (|lubSeq|, i requires 0 <= i < |lubSeq| => ets.types[lubSeq[i]]);\n        assert s != [];\n        assert lubRecordTypeSeq(s, ValidationMode.Strict) == lubRecordTypeSeq(s, ValidationMode.Permissive) by {\n          assert ets.getLubRecordType(lub, ValidationMode.Strict).Ok?;\n          StrictLubRecordTypeSeq(s);\n        }\n      }\n    }\n",
        "method_without_assertion_content": "    lemma StrictGetLubRecordType(lub: EntityLUB)\n      requires ets.getLubRecordType(lub, ValidationMode.Strict).Ok?\n      ensures ets.getLubRecordType(lub, ValidationMode.Permissive) == ets.getLubRecordType(lub, ValidationMode.Strict)\n    {\n      if lub.AnyEntity? || exists et <- lub.tys :: isAction(et) {\n        assert ets.getLubRecordType(lub, ValidationMode.Permissive).Ok?;\n      } else {\n                def.util.EntityTypeLeqIsTotalOrder();\n        var lubSeq := def.util.SetToSortedSeq(lub.tys,def.util.EntityTypeLeq);\n        var s := seq (|lubSeq|, i requires 0 <= i < |lubSeq| => ets.types[lubSeq[i]]);\n        assert s != [];\n        assert lubRecordTypeSeq(s, ValidationMode.Strict) == lubRecordTypeSeq(s, ValidationMode.Permissive) by {\n          assert ets.getLubRecordType(lub, ValidationMode.Strict).Ok?;\n          StrictLubRecordTypeSeq(s);\n        }\n      }\n    }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "5",
        "method_filepath": "./cedar-dafny/validation/subtyping.dfy",
        "method_without_assertion_filename": "LubUndefUbUndef_fix_5.dfy",
        "method_name": "LubUndefUbUndef",
        "method_content": "  lemma LubUndefUbUndef(t1 : Type, t2 : Type, t : Type, m: ValidationMode)\n    requires !LubDefined(t1, t2, m)\n    ensures !subty(t1, t, m) || !subty(t2, t, m)\n  {\n    match t {\n      case Never =>\n      case Int =>\n      case String =>\n      case Bool(b) =>\n      case Entity(e) =>\n      case Set(e) => {\n        if t1.Set? && t2.Set? {\n          LubUndefUbUndef(t1.ty, t2.ty, e, m);\n        }\n      }\n      case Record(rt) => {\n        match (t1, t2) {\n          case (Record(rt1), Record(rt2)) => {\n            if m.isStrict() {\n              assert lubRecordType(rt1, rt2, ValidationMode.Strict).Err?;\n\n              if exists k | k in rt1.attrs.Keys && k in rt2.attrs.Keys :: !LubDefined(rt1.attrs[k].ty, rt2.attrs[k].ty, m) {\n                var k :| k in rt1.attrs.Keys && k in rt2.attrs.Keys && !LubDefined(rt1.attrs[k].ty, rt2.attrs[k].ty, m);\n                if k in rt.attrs.Keys {\n                  assert (exists k' | k' in rt.attrs.Keys && k' in rt1.attrs.Keys :: !subtyAttrType(rt1.attrs[k'], rt.attrs[k'], m)) ||\n                         (exists k' | k' in rt.attrs.Keys && k' in rt2.attrs.Keys :: !subtyAttrType(rt2.attrs[k'], rt.attrs[k'], m));\n                }\n              }\n            } else {\n              assert lubRecordType(rt1, rt2, ValidationMode.Permissive).Ok?;\n            }\n          }\n          case _ =>\n        }\n      }\n      case Extension(e) =>\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LubUndefUbUndef(t1 : Type, t2 : Type, t : Type, m: ValidationMode)\n    requires !LubDefined(t1, t2, m)\n    ensures !subty(t1, t, m) || !subty(t2, t, m)\n  {\n    match t {\n      case Never =>\n      case Int =>\n      case String =>\n      case Bool(b) =>\n      case Entity(e) =>\n      case Set(e) => {\n        if t1.Set? && t2.Set? {\n          LubUndefUbUndef(t1.ty, t2.ty, e, m);\n        }\n      }\n      case Record(rt) => {\n        match (t1, t2) {\n          case (Record(rt1), Record(rt2)) => {\n            if m.isStrict() {\n              \n              if exists k | k in rt1.attrs.Keys && k in rt2.attrs.Keys :: !LubDefined(rt1.attrs[k].ty, rt2.attrs[k].ty, m) {\n                var k :| k in rt1.attrs.Keys && k in rt2.attrs.Keys && !LubDefined(rt1.attrs[k].ty, rt2.attrs[k].ty, m);\n                if k in rt.attrs.Keys {\n                  assert (exists k' | k' in rt.attrs.Keys && k' in rt1.attrs.Keys :: !subtyAttrType(rt1.attrs[k'], rt.attrs[k'], m)) ||\n                         (exists k' | k' in rt.attrs.Keys && k' in rt2.attrs.Keys :: !subtyAttrType(rt2.attrs[k'], rt.attrs[k'], m));\n                }\n              }\n            } else {\n              assert lubRecordType(rt1, rt2, ValidationMode.Permissive).Ok?;\n            }\n          }\n          case _ =>\n        }\n      }\n      case Extension(e) =>\n    }\n  }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "743",
        "method_filepath": "./cedar-dafny/validation/thm/soundness.dfy",
        "method_without_assertion_filename": "SoundNot_fix_743.dfy",
        "method_name": "SoundNot",
        "method_content": "    lemma SoundNot(e: Expr, t: Type, effs: Effects)\n      decreases UnaryApp(Not,e) , 0\n      requires WellFormedRequestAndStore()\n      requires EffectsInvariant(effs)\n      requires Typesafe(UnaryApp(Not,e),effs,t)\n      ensures IsSafe(r,s,UnaryApp(Not,e),t)\n      ensures getEffects(UnaryApp(Not,e),effs) == Effects.empty()\n    {\n      var t' :| getType(UnaryApp(Not,e),effs) == t' && subty(t',t,ValidationMode.Permissive);\n      assert TC.inferNot(e,effs).Ok?;\n      var (bt,_) := TC.inferBoolType(e,effs).value;\n      assert t' == Type.Bool(bt.not());\n      assert Typesafe(e,effs,Type.Bool(bt)) by { SubtyRefl(Type.Bool(bt)); }\n      assert IsSafe(r,s,e,Type.Bool(bt)) by { Sound(e,Type.Bool(bt),effs); }\n      assert IsSafe(r,s,UnaryApp(Not,e),t') by {\n        match bt {\n          case AnyBool => NotSafe(r,s,e);\n          case True => NotTrueSafe(r,s,e);\n          case False => NotFalseSafe(r,s,e);\n        }\n      }\n      assert IsSafe(r,s,UnaryApp(Not,e),t) by {\n        SubtyCompat(t',t);\n        SemSubtyTransport(r,s,UnaryApp(Not,e),t',t);\n      }\n    }\n",
        "method_without_assertion_content": "    lemma SoundNot(e: Expr, t: Type, effs: Effects)\n      decreases UnaryApp(Not,e) , 0\n      requires WellFormedRequestAndStore()\n      requires EffectsInvariant(effs)\n      requires Typesafe(UnaryApp(Not,e),effs,t)\n      ensures IsSafe(r,s,UnaryApp(Not,e),t)\n      ensures getEffects(UnaryApp(Not,e),effs) == Effects.empty()\n    {\n      var t' :| getType(UnaryApp(Not,e),effs) == t' && subty(t',t,ValidationMode.Permissive);\n            var (bt,_) := TC.inferBoolType(e,effs).value;\n      assert t' == Type.Bool(bt.not());\n      assert Typesafe(e,effs,Type.Bool(bt)) by { SubtyRefl(Type.Bool(bt)); }\n      assert IsSafe(r,s,e,Type.Bool(bt)) by { Sound(e,Type.Bool(bt),effs); }\n      assert IsSafe(r,s,UnaryApp(Not,e),t') by {\n        match bt {\n          case AnyBool => NotSafe(r,s,e);\n          case True => NotTrueSafe(r,s,e);\n          case False => NotFalseSafe(r,s,e);\n        }\n      }\n      assert IsSafe(r,s,UnaryApp(Not,e),t) by {\n        SubtyCompat(t',t);\n        SemSubtyTransport(r,s,UnaryApp(Not,e),t',t);\n      }\n    }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "27",
        "method_filepath": "./cedar-dafny/validation/thm/model.dfy",
        "method_without_assertion_filename": "OrLShortSafe_fix_27.dfy",
        "method_name": "OrLShortSafe",
        "method_content": "  lemma OrLShortSafe(r: Request, s: EntityStore, e: Expr, e': Expr)\n    requires IsTrue(r,s,e)\n    ensures IsTrue(r,s,Or(e,e'))\n  {\n    reveal IsSafe();\n    if Evaluate(e,r,s).Ok? {\n      assert Evaluate(e,r,s) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n      assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n      assert Evaluate(Or(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n    } else {\n      assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == Evaluate(e,r,s);\n      assert Evaluate(Or(e,e'),r,s) == Evaluate(e,r,s);\n    }\n  }\n",
        "method_without_assertion_content": "  lemma OrLShortSafe(r: Request, s: EntityStore, e: Expr, e': Expr)\n    requires IsTrue(r,s,e)\n    ensures IsTrue(r,s,Or(e,e'))\n  {\n    reveal IsSafe();\n    if Evaluate(e,r,s).Ok? {\n      assert Evaluate(e,r,s) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n      assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n      assert Evaluate(Or(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n    } else {\n            assert Evaluate(Or(e,e'),r,s) == Evaluate(e,r,s);\n    }\n  }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "809",
        "method_filepath": "./cedar-dafny/validation/thm/soundness.dfy",
        "method_without_assertion_filename": "SoundInSetMemberFalse_fix_809.dfy",
        "method_name": "SoundInSetMemberFalse",
        "method_content": "    lemma SoundInSetMemberFalse(e1: Expr, ei2s: seq<Expr>, i: nat, effs: Effects)\n      decreases BinaryApp(BinaryOp.In,e1,Expr.Set(ei2s)) , 0 , Expr.Set(ei2s) , 0\n      requires WellFormedRequestAndStore()\n      requires EffectsInvariant(effs)\n      requires WellTyped(BinaryApp(BinaryOp.In,e1,Expr.Set(ei2s)),effs)\n      requires getType(BinaryApp(BinaryOp.In,e1,Expr.Set(ei2s)),effs) == Type.Bool(False)\n      requires !reqty.isUnspecifiedVar(e1)\n      requires 0 <= i < |ei2s|\n      ensures IsFalse(r,s,BinaryApp(BinaryOp.In,e1,ei2s[i]))\n    {\n      // Reestablishing things we had at the call site in `SoundIn`.\n      var e2 := Expr.Set(ei2s);\n\n      assert TC.inferIn(BinaryApp(BinaryOp.In,e1,e2),e1,e2,effs) == types.Ok(Type.Bool(False));\n\n      assert TC.ensureEntityType(e1,effs).Ok?;\n      var t1 := getType(e1,effs);\n\n      var euids2 :- assert TC.tryGetEUIDs(e2);\n      var ets2 := set u <- euids2 :: u.ty;\n\n      // New proof.\n      var u2 :- assert TC.tryGetEUID(ei2s[i]);\n      assert u2 in euids2;\n      match e1 {\n        case Var(v1) =>\n          var et1 :- assert TC.getPrincipalOrResource(v1);\n          assert t1 == Type.Entity(EntityLUB({et1}));\n          assert IsSafe(r,s,Var(v1),t1) by { Sound(e1,t1,effs); }\n          assert !ets.possibleDescendantOf(et1,u2.ty);\n          reveal WellFormedRequestAndStore();\n          InSingleFalseEntityTypeAndLiteral(r,s,e1,et1,u2);\n        case PrimitiveLit(EntityUID(u1)) =>\n          if isAction(u1.ty) {\n            assert !acts.descendantOfSet(u1,euids2);\n            assert !acts.descendantOf(u1,u2);\n          } else {\n            assert !ets.possibleDescendantOfSet(u1.ty,ets2);\n            assert !ets.possibleDescendantOf(u1.ty,u2.ty);\n          }\n          reveal WellFormedRequestAndStore();\n          InSingleFalseLiterals(r,s,u1,u2);\n      }\n    }\n",
        "method_without_assertion_content": "    lemma SoundInSetMemberFalse(e1: Expr, ei2s: seq<Expr>, i: nat, effs: Effects)\n      decreases BinaryApp(BinaryOp.In,e1,Expr.Set(ei2s)) , 0 , Expr.Set(ei2s) , 0\n      requires WellFormedRequestAndStore()\n      requires EffectsInvariant(effs)\n      requires WellTyped(BinaryApp(BinaryOp.In,e1,Expr.Set(ei2s)),effs)\n      requires getType(BinaryApp(BinaryOp.In,e1,Expr.Set(ei2s)),effs) == Type.Bool(False)\n      requires !reqty.isUnspecifiedVar(e1)\n      requires 0 <= i < |ei2s|\n      ensures IsFalse(r,s,BinaryApp(BinaryOp.In,e1,ei2s[i]))\n    {\n      // Reestablishing things we had at the call site in `SoundIn`.\n      var e2 := Expr.Set(ei2s);\n\n      \n      assert TC.ensureEntityType(e1,effs).Ok?;\n      var t1 := getType(e1,effs);\n\n      var euids2 :- assert TC.tryGetEUIDs(e2);\n      var ets2 := set u <- euids2 :: u.ty;\n\n      // New proof.\n      var u2 :- assert TC.tryGetEUID(ei2s[i]);\n      assert u2 in euids2;\n      match e1 {\n        case Var(v1) =>\n          var et1 :- assert TC.getPrincipalOrResource(v1);\n          assert t1 == Type.Entity(EntityLUB({et1}));\n          assert IsSafe(r,s,Var(v1),t1) by { Sound(e1,t1,effs); }\n          assert !ets.possibleDescendantOf(et1,u2.ty);\n          reveal WellFormedRequestAndStore();\n          InSingleFalseEntityTypeAndLiteral(r,s,e1,et1,u2);\n        case PrimitiveLit(EntityUID(u1)) =>\n          if isAction(u1.ty) {\n            assert !acts.descendantOfSet(u1,euids2);\n            assert !acts.descendantOf(u1,u2);\n          } else {\n            assert !ets.possibleDescendantOfSet(u1.ty,ets2);\n            assert !ets.possibleDescendantOf(u1.ty,u2.ty);\n          }\n          reveal WellFormedRequestAndStore();\n          InSingleFalseLiterals(r,s,u1,u2);\n      }\n    }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "102",
        "method_filepath": "./cedar-dafny/validation/thm/model.dfy",
        "method_without_assertion_filename": "OrRShortSafe_fix_102.dfy",
        "method_name": "OrRShortSafe",
        "method_content": "  lemma OrRShortSafe(r: Request, s: EntityStore, e: Expr, e': Expr)\n    requires IsSafe(r,s,e,Type.Bool(AnyBool))\n    requires IsTrue(r,s,e')\n    ensures IsTrue(r,s,Or(e,e'))\n  {\n    reveal IsSafe();\n    if Evaluate(e,r,s).Ok? && Evaluate(e',r,s).Ok? {\n      assert Evaluate(e',r,s) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n      assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n      assert Evaluate(Or(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n    } else {\n      if Evaluate(e,r,s).Err? {\n        assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == Evaluate(e,r,s);\n        assert Evaluate(Or(e,e'),r,s) == Evaluate(e,r,s);\n      } else {\n        assert Evaluate(e',r,s).Err?;\n        var b :| Evaluate(e,r,s) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n        if b {\n          assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n          assert Evaluate(Or(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n        } else {\n          assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == Evaluate(e',r,s);\n          assert Evaluate(Or(e,e'),r,s) == Evaluate(e',r,s);\n        }\n      }\n    }\n  }\n",
        "method_without_assertion_content": "  lemma OrRShortSafe(r: Request, s: EntityStore, e: Expr, e': Expr)\n    requires IsSafe(r,s,e,Type.Bool(AnyBool))\n    requires IsTrue(r,s,e')\n    ensures IsTrue(r,s,Or(e,e'))\n  {\n    reveal IsSafe();\n    if Evaluate(e,r,s).Ok? && Evaluate(e',r,s).Ok? {\n      assert Evaluate(e',r,s) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n            assert Evaluate(Or(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n    } else {\n      if Evaluate(e,r,s).Err? {\n        assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == Evaluate(e,r,s);\n        assert Evaluate(Or(e,e'),r,s) == Evaluate(e,r,s);\n      } else {\n        assert Evaluate(e',r,s).Err?;\n        var b :| Evaluate(e,r,s) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n        if b {\n          assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n          assert Evaluate(Or(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n        } else {\n          assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == Evaluate(e',r,s);\n          assert Evaluate(Or(e,e'),r,s) == Evaluate(e',r,s);\n        }\n      }\n    }\n  }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "54",
        "method_filepath": "./cedar-dafny/validation/thm/model.dfy",
        "method_without_assertion_filename": "OrSafe_fix_54.dfy",
        "method_name": "OrSafe",
        "method_content": "  lemma OrSafe(r: Request, s: EntityStore, e: Expr, e': Expr)\n    requires IsSafe(r,s,e,Type.Bool(AnyBool))\n    requires IsSafe(r,s,e',Type.Bool(AnyBool))\n    ensures IsSafe(r,s,Or(e,e'),Type.Bool(AnyBool))\n  {\n    reveal IsSafe();\n    if Evaluate(e,r,s).Ok? && Evaluate(e',r,s).Ok? {\n      assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true).Ok?;\n      assert Evaluate(Or(e,e'),r,s).Ok?;\n    } else {\n      if Evaluate(e,r,s).Err? {\n        assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == Evaluate(e,r,s);\n        assert Evaluate(Or(e,e'),r,s) == Evaluate(e,r,s);\n      } else {\n        assert Evaluate(e',r,s).Err?;\n        var b :| Evaluate(e,r,s) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n        if b {\n          assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n          assert Evaluate(Or(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n        } else {\n          assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == Evaluate(e',r,s);\n          assert Evaluate(Or(e,e'),r,s) == Evaluate(e',r,s);\n        }\n      }\n    }\n  }\n",
        "method_without_assertion_content": "  lemma OrSafe(r: Request, s: EntityStore, e: Expr, e': Expr)\n    requires IsSafe(r,s,e,Type.Bool(AnyBool))\n    requires IsSafe(r,s,e',Type.Bool(AnyBool))\n    ensures IsSafe(r,s,Or(e,e'),Type.Bool(AnyBool))\n  {\n    reveal IsSafe();\n    if Evaluate(e,r,s).Ok? && Evaluate(e',r,s).Ok? {\n      assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true).Ok?;\n      assert Evaluate(Or(e,e'),r,s).Ok?;\n    } else {\n      if Evaluate(e,r,s).Err? {\n        assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == Evaluate(e,r,s);\n        assert Evaluate(Or(e,e'),r,s) == Evaluate(e,r,s);\n      } else {\n        assert Evaluate(e',r,s).Err?;\n        var b :| Evaluate(e,r,s) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n        if b {\n          assert Evaluator(r,s).interpretShortcircuit(Or(e,e'),e,e',true) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n          assert Evaluate(Or(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n        } else {\n                    assert Evaluate(Or(e,e'),r,s) == Evaluate(e',r,s);\n        }\n      }\n    }\n  }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "33",
        "method_filepath": "./cedar-dafny/validation/thm/model.dfy",
        "method_without_assertion_filename": "AndLShortSafe_fix_33.dfy",
        "method_name": "AndLShortSafe",
        "method_content": "  lemma AndLShortSafe(r: Request, s: EntityStore, e: Expr, e': Expr)\n    requires IsFalse(r,s,e)\n    ensures IsFalse(r,s,And(e,e'))\n  {\n    reveal IsSafe();\n    if Evaluate(e,r,s).Ok? {\n      assert Evaluate(e,r,s) == base.Ok(Value.Primitive(Primitive.Bool(false)));\n      assert Evaluator(r,s).interpretShortcircuit(And(e,e'),e,e',false) == base.Ok(Value.Primitive(Primitive.Bool(false)));\n      assert Evaluate(And(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(false)));\n    } else {\n      assert Evaluator(r,s).interpretShortcircuit(And(e,e'),e,e',false) == Evaluate(e,r,s);\n      assert Evaluate(And(e,e'),r,s) == Evaluate(e,r,s);\n    }\n  }\n",
        "method_without_assertion_content": "  lemma AndLShortSafe(r: Request, s: EntityStore, e: Expr, e': Expr)\n    requires IsFalse(r,s,e)\n    ensures IsFalse(r,s,And(e,e'))\n  {\n    reveal IsSafe();\n    if Evaluate(e,r,s).Ok? {\n      assert Evaluate(e,r,s) == base.Ok(Value.Primitive(Primitive.Bool(false)));\n            assert Evaluate(And(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(false)));\n    } else {\n      assert Evaluator(r,s).interpretShortcircuit(And(e,e'),e,e',false) == Evaluate(e,r,s);\n      assert Evaluate(And(e,e'),r,s) == Evaluate(e,r,s);\n    }\n  }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "789",
        "method_filepath": "./cedar-dafny/validation/thm/soundness.dfy",
        "method_without_assertion_filename": "SoundArith_fix_789.dfy",
        "method_name": "SoundArith",
        "method_content": "    lemma SoundArith(op: BinaryOp, e1: Expr, e2: Expr, t: Type, effs: Effects)\n      decreases BinaryApp(op,e1,e2) , 0\n      requires op == Add || op == Sub\n      requires WellFormedRequestAndStore()\n      requires EffectsInvariant(effs)\n      requires Typesafe(BinaryApp(op,e1,e2),effs,t)\n      ensures IsSafe(r,s,BinaryApp(op,e1,e2),t)\n      ensures getEffects(BinaryApp(op,e1,e2),effs) == Effects.empty()\n    {\n      var t' :| getType(BinaryApp(op,e1,e2),effs) == t' && subty(t',t,ValidationMode.Permissive);\n      assert TC.inferArith2(op,e1,e2,effs) == types.Ok(Type.Int);\n      assert TC.ensureIntType(e1,effs).Ok?;\n      assert Typesafe(e1,effs,Type.Int);\n      assert TC.ensureIntType(e2,effs).Ok?;\n      assert Typesafe(e2,effs,Type.Int);\n      assert IsSafe(r,s,e1,Type.Int) by { Sound(e1,Type.Int,effs); }\n      assert IsSafe(r,s,e2,Type.Int) by { Sound(e2,Type.Int,effs); }\n      assert IsSafe(r,s,BinaryApp(op,e1,e2),t') by { ArithSafe(r,s,op,e1,e2); }\n      assert IsSafe(r,s,BinaryApp(op,e1,e2),t) by {\n        SubtyCompat(t',t);\n        SemSubtyTransport(r,s,BinaryApp(op,e1,e2),t',t);\n      }\n    }\n",
        "method_without_assertion_content": "    lemma SoundArith(op: BinaryOp, e1: Expr, e2: Expr, t: Type, effs: Effects)\n      decreases BinaryApp(op,e1,e2) , 0\n      requires op == Add || op == Sub\n      requires WellFormedRequestAndStore()\n      requires EffectsInvariant(effs)\n      requires Typesafe(BinaryApp(op,e1,e2),effs,t)\n      ensures IsSafe(r,s,BinaryApp(op,e1,e2),t)\n      ensures getEffects(BinaryApp(op,e1,e2),effs) == Effects.empty()\n    {\n      var t' :| getType(BinaryApp(op,e1,e2),effs) == t' && subty(t',t,ValidationMode.Permissive);\n      assert TC.inferArith2(op,e1,e2,effs) == types.Ok(Type.Int);\n            assert Typesafe(e1,effs,Type.Int);\n      assert TC.ensureIntType(e2,effs).Ok?;\n      assert Typesafe(e2,effs,Type.Int);\n      assert IsSafe(r,s,e1,Type.Int) by { Sound(e1,Type.Int,effs); }\n      assert IsSafe(r,s,e2,Type.Int) by { Sound(e2,Type.Int,effs); }\n      assert IsSafe(r,s,BinaryApp(op,e1,e2),t') by { ArithSafe(r,s,op,e1,e2); }\n      assert IsSafe(r,s,BinaryApp(op,e1,e2),t) by {\n        SubtyCompat(t',t);\n        SemSubtyTransport(r,s,BinaryApp(op,e1,e2),t',t);\n      }\n    }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "19",
        "method_filepath": "./cedar-dafny/validation/subtyping.dfy",
        "method_without_assertion_filename": "StrictLubIsStrict_fix_19.dfy",
        "method_name": "StrictLubIsStrict",
        "method_content": "  lemma StrictLubIsStrict(t1: Type, t2: Type)\n    requires LubDefined(t1, t2, ValidationMode.Strict)\n    ensures lubOpt(t1, t2, ValidationMode.Permissive) == lubOpt(t1, t2, ValidationMode.Strict)\n  {\n    match (t1,t2) {\n      case (Never,_) =>\n      case (_,Never) =>\n      case (Int,Int) =>\n      case (String,String) =>\n      case (Bool(b1),Bool(b2)) =>\n      case (Entity(e1),Entity(e2)) =>\n      case (Set(t1'),Set(t2')) =>\n      case (Record(rt1),Record(rt2)) => {\n        assert lubRecordType(rt1, rt2, ValidationMode.Strict).Ok?;\n        assert lubRecordType(rt1, rt2, ValidationMode.Permissive).Ok?;\n\n        var strict_attrs :=\n          map k | k in rt1.attrs.Keys && k in rt2.attrs.Keys && lubOpt(rt1.attrs[k].ty, rt2.attrs[k].ty, ValidationMode.Strict).Ok? ::\n            lubAttrType(rt1.attrs[k], rt2.attrs[k], ValidationMode.Strict);\n        assert strict_attrs == lubRecordType(rt1, rt2, ValidationMode.Strict).value.attrs;\n\n        var permissive_attrs :=\n          map k | k in rt1.attrs.Keys && k in rt2.attrs.Keys && lubOpt(rt1.attrs[k].ty, rt2.attrs[k].ty, ValidationMode.Permissive).Ok? ::\n            lubAttrType(rt1.attrs[k], rt2.attrs[k], ValidationMode.Permissive);\n        assert permissive_attrs == lubRecordType(rt1, rt2, ValidationMode.Permissive).value.attrs;\n\n        assert permissive_attrs == strict_attrs;\n      }\n      case (Extension(n1),Extension(n2)) =>\n    }\n  }\n",
        "method_without_assertion_content": "  lemma StrictLubIsStrict(t1: Type, t2: Type)\n    requires LubDefined(t1, t2, ValidationMode.Strict)\n    ensures lubOpt(t1, t2, ValidationMode.Permissive) == lubOpt(t1, t2, ValidationMode.Strict)\n  {\n    match (t1,t2) {\n      case (Never,_) =>\n      case (_,Never) =>\n      case (Int,Int) =>\n      case (String,String) =>\n      case (Bool(b1),Bool(b2)) =>\n      case (Entity(e1),Entity(e2)) =>\n      case (Set(t1'),Set(t2')) =>\n      case (Record(rt1),Record(rt2)) => {\n        assert lubRecordType(rt1, rt2, ValidationMode.Strict).Ok?;\n        assert lubRecordType(rt1, rt2, ValidationMode.Permissive).Ok?;\n\n        var strict_attrs :=\n          map k | k in rt1.attrs.Keys && k in rt2.attrs.Keys && lubOpt(rt1.attrs[k].ty, rt2.attrs[k].ty, ValidationMode.Strict).Ok? ::\n            lubAttrType(rt1.attrs[k], rt2.attrs[k], ValidationMode.Strict);\n        assert strict_attrs == lubRecordType(rt1, rt2, ValidationMode.Strict).value.attrs;\n\n        var permissive_attrs :=\n          map k | k in rt1.attrs.Keys && k in rt2.attrs.Keys && lubOpt(rt1.attrs[k].ty, rt2.attrs[k].ty, ValidationMode.Permissive).Ok? ::\n            lubAttrType(rt1.attrs[k], rt2.attrs[k], ValidationMode.Permissive);\n        assert permissive_attrs == lubRecordType(rt1, rt2, ValidationMode.Permissive).value.attrs;\n\n              }\n      case (Extension(n1),Extension(n2)) =>\n    }\n  }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "771",
        "method_filepath": "./cedar-dafny/validation/thm/soundness.dfy",
        "method_without_assertion_filename": "SoundContains_fix_771.dfy",
        "method_name": "SoundContains",
        "method_content": "    lemma SoundContainsAnyAll(op: BinaryOp, e1: Expr, e2: Expr, t: Type, effs: Effects)\n      decreases BinaryApp(op,e1,e2) , 0\n      requires op == ContainsAny || op == ContainsAll\n      requires WellFormedRequestAndStore()\n      requires EffectsInvariant(effs)\n      requires Typesafe(BinaryApp(op,e1,e2),effs,t)\n      ensures IsSafe(r,s,BinaryApp(op,e1,e2),t)\n      ensures getEffects(BinaryApp(op,e1,e2),effs) == Effects.empty()\n    {\n      var t' :| getType(BinaryApp(op,e1,e2),effs) == t' && subty(t',t,ValidationMode.Permissive);\n      assert TC.inferContainsAnyAll(op,e1,e2,effs) == types.Ok(t');\n      var t1 := TC.inferSetType(e1,effs).value;\n      var t2 := TC.inferSetType(e2,effs).value;\n      assert Typesafe(e1,effs,Type.Set(t1)) by { SubtyRefl(Type.Set(t1)); }\n      assert Typesafe(e2,effs,Type.Set(t2)) by { SubtyRefl(Type.Set(t2)); }\n      assert IsSafe(r,s,e1,Type.Set(t1)) by { Sound(e1,Type.Set(t1),effs); }\n      assert IsSafe(r,s,e2,Type.Set(t2)) by { Sound(e2,Type.Set(t2),effs); }\n      assert IsSafe(r,s,BinaryApp(op,e1,e2),t') by { ContainsAnyAllSafe(r,s,op,e1,e2,t1,t2); }\n      assert IsSafe(r,s,BinaryApp(op,e1,e2),t) by {\n        SubtyCompat(t',t);\n        SemSubtyTransport(r,s,BinaryApp(op,e1,e2),t',t);\n      }\n    }\n",
        "method_without_assertion_content": "    lemma SoundContainsAnyAll(op: BinaryOp, e1: Expr, e2: Expr, t: Type, effs: Effects)\n      decreases BinaryApp(op,e1,e2) , 0\n      requires op == ContainsAny || op == ContainsAll\n      requires WellFormedRequestAndStore()\n      requires EffectsInvariant(effs)\n      requires Typesafe(BinaryApp(op,e1,e2),effs,t)\n      ensures IsSafe(r,s,BinaryApp(op,e1,e2),t)\n      ensures getEffects(BinaryApp(op,e1,e2),effs) == Effects.empty()\n    {\n      var t' :| getType(BinaryApp(op,e1,e2),effs) == t' && subty(t',t,ValidationMode.Permissive);\n            var t1 := TC.inferSetType(e1,effs).value;\n      var t2 := TC.inferSetType(e2,effs).value;\n      assert Typesafe(e1,effs,Type.Set(t1)) by { SubtyRefl(Type.Set(t1)); }\n      assert Typesafe(e2,effs,Type.Set(t2)) by { SubtyRefl(Type.Set(t2)); }\n      assert IsSafe(r,s,e1,Type.Set(t1)) by { Sound(e1,Type.Set(t1),effs); }\n      assert IsSafe(r,s,e2,Type.Set(t2)) by { Sound(e2,Type.Set(t2),effs); }\n      assert IsSafe(r,s,BinaryApp(op,e1,e2),t') by { ContainsAnyAllSafe(r,s,op,e1,e2,t1,t2); }\n      assert IsSafe(r,s,BinaryApp(op,e1,e2),t) by {\n        SubtyCompat(t',t);\n        SemSubtyTransport(r,s,BinaryApp(op,e1,e2),t',t);\n      }\n    }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "838",
        "method_filepath": "./cedar-dafny/validation/thm/soundness.dfy",
        "method_without_assertion_filename": "SoundHasAttr_fix_838.dfy",
        "method_name": "SoundHasAttr",
        "method_content": "    lemma SoundHasAttr(e: Expr, k: Attr, t: Type, effs: Effects)\n      decreases HasAttr(e,k) , 0\n      requires WellFormedRequestAndStore()\n      requires EffectsInvariant(effs)\n      requires Typesafe(HasAttr(e,k),effs,t)\n      ensures IsSafe(r,s,HasAttr(e,k),t)\n      ensures GuardedEffectsInvariant(HasAttr(e,k),getEffects(HasAttr(e,k),effs))\n    {\n      var t' :| getType(HasAttr(e,k),effs) == t' && subty(t',t,ValidationMode.Permissive);\n      assert TC.inferHasAttr(e,k,effs).Ok?;\n      var ret := TC.inferRecordEntityType(e,effs).value;\n      assert GuardedEffectsInvariant(HasAttr(e,k),Effects.empty()) by {\n        EmptyEffectsInvariant();\n      }\n      match ret {\n        case Record(rt) => {\n          assert Typesafe(e,effs,Type.Record(rt)) by { SubtyRefl(Type.Record(rt)); }\n          assert IsSafe(r,s,e,Type.Record(rt)) by { Sound(e,Type.Record(rt),effs); }\n          if k in rt.attrs {\n            if rt.attrs[k].isRequired {\n              assert IsSafe(r,s,e,Type.Record(RecordType(map[k := rt.attrs[k]], OpenAttributes))) by {\n                SubtyRefl(rt.attrs[k].ty);\n                assert subtyRecordType(rt,RecordType(map[k := rt.attrs[k]], OpenAttributes),ValidationMode.Permissive);\n                assert subty(Type.Record(rt),Type.Record(RecordType(map[k := rt.attrs[k]], OpenAttributes)),ValidationMode.Permissive);\n                SubtyCompat(Type.Record(rt),Type.Record(RecordType(map[k := rt.attrs[k]], OpenAttributes)));\n                SemSubtyTransport(r,s,e,Type.Record(rt),Type.Record(RecordType(map[k := rt.attrs[k]], OpenAttributes)));\n              }\n              assert IsSafe(r,s,HasAttr(e,k),t') by { RecordHasRequiredTrueSafe(r,s,e,k,rt.attrs[k]); }\n            } else if effs.contains(e,k) {\n              assert IsSafe(r,s,HasAttr(e,k),t') by {\n                reveal EffectsInvariant();\n              }\n            } else {\n              assert IsSafe(r,s,e,Type.Record(RecordType(map[], OpenAttributes))) by {\n                assert subty(Type.Record(rt),Type.Record(RecordType(map[], OpenAttributes)),ValidationMode.Permissive);\n                SubtyCompat(Type.Record(rt),Type.Record(RecordType(map[], OpenAttributes)));\n                SemSubtyTransport(r,s,e,Type.Record(rt),Type.Record(RecordType(map[], OpenAttributes)));\n              }\n              assert IsSafe(r,s,HasAttr(e,k),t') by { RecordHasOpenRecSafe(r,s,e,k); }\n              assert GuardedEffectsInvariant(HasAttr(e,k),Effects.singleton(e,k)) by {\n                if IsTrueStrong(r,s,HasAttr(e,k)) {\n                  IsTrueStrongImpliesIsTrue(r,s,HasAttr(e,k));\n                  reveal EffectsInvariant();\n                }\n              }\n            }\n          } else if rt.isOpen() {\n            assert IsSafe(r,s,e,Type.Record(RecordType(map[], OpenAttributes))) by {\n              assert subty(Type.Record(rt),Type.Record(RecordType(map[], OpenAttributes)),ValidationMode.Permissive);\n              SubtyCompat(Type.Record(rt),Type.Record(RecordType(map[], OpenAttributes)));\n              SemSubtyTransport(r,s,e,Type.Record(rt),Type.Record(RecordType(map[], OpenAttributes)));\n            }\n            assert IsSafe(r,s,HasAttr(e,k),t') by { RecordHasOpenRecSafe(r,s,e,k); }\n          } else {\n            assert IsSafe(r,s,HasAttr(e,k),t') by { RecordHasClosedRecFalseSafe(r,s,e,k, rt); }\n          }\n        }\n        case Entity(et) => {\n          assert Typesafe(e,effs,Type.Entity(et)) by { SubtyRefl(Type.Entity(et)); }\n          assert IsSafe(r,s,e,Type.Entity(et)) by { Sound(e,Type.Entity(et),effs); }\n          if !ets.isAttrPossible(et,k) {\n            reveal WellFormedRequestAndStore();\n            EntityHasImpossibleFalseSafe(r,s,e,k,et);\n          } else {\n            var m := ets.getLubRecordType(et,ValidationMode.Permissive).value;\n            if k in m.attrs {\n              if effs.contains(e,k) {\n                assert IsSafe(r,s,HasAttr(e,k),t') by {\n                  reveal EffectsInvariant();\n                }\n              } else {\n                assert IsSafe(r,s,e,Type.Entity(AnyEntity)) by {\n                  SubtyCompat(Type.Entity(et),Type.Entity(AnyEntity));\n                  SemSubtyTransport(r,s,e,Type.Entity(et),Type.Entity(AnyEntity));\n                }\n                assert IsSafe(r,s,HasAttr(e,k),t') by { EntityHasOpenSafe(r,s,e,k); }\n                assert GuardedEffectsInvariant(HasAttr(e,k),Effects.singleton(e,k)) by {\n                  if IsTrueStrong(r,s,HasAttr(e,k)) {\n                    IsTrueStrongImpliesIsTrue(r,s,HasAttr(e,k));\n                    reveal EffectsInvariant();\n                  }\n                }\n              }\n            } else {\n              PossibleAttrNotInLubAttrImpliesOpen(et, k, m);\n              assert IsSafe(r,s,e,Type.Entity(AnyEntity)) by {\n                SubtyCompat(Type.Entity(et),Type.Entity(AnyEntity));\n                SemSubtyTransport(r,s,e,Type.Entity(et),Type.Entity(AnyEntity));\n              }\n              assert IsSafe(r,s,HasAttr(e,k),t') by { EntityHasOpenSafe(r,s,e,k); }\n            }\n          }\n        }\n      }\n      assert IsSafe(r,s,HasAttr(e,k),t) by {\n        SubtyCompat(t',t);\n        SemSubtyTransport(r,s,HasAttr(e,k),t',t);\n      }\n    }\n",
        "method_without_assertion_content": "    lemma SoundHasAttr(e: Expr, k: Attr, t: Type, effs: Effects)\n      decreases HasAttr(e,k) , 0\n      requires WellFormedRequestAndStore()\n      requires EffectsInvariant(effs)\n      requires Typesafe(HasAttr(e,k),effs,t)\n      ensures IsSafe(r,s,HasAttr(e,k),t)\n      ensures GuardedEffectsInvariant(HasAttr(e,k),getEffects(HasAttr(e,k),effs))\n    {\n      var t' :| getType(HasAttr(e,k),effs) == t' && subty(t',t,ValidationMode.Permissive);\n            var ret := TC.inferRecordEntityType(e,effs).value;\n      assert GuardedEffectsInvariant(HasAttr(e,k),Effects.empty()) by {\n        EmptyEffectsInvariant();\n      }\n      match ret {\n        case Record(rt) => {\n          assert Typesafe(e,effs,Type.Record(rt)) by { SubtyRefl(Type.Record(rt)); }\n          assert IsSafe(r,s,e,Type.Record(rt)) by { Sound(e,Type.Record(rt),effs); }\n          if k in rt.attrs {\n            if rt.attrs[k].isRequired {\n              assert IsSafe(r,s,e,Type.Record(RecordType(map[k := rt.attrs[k]], OpenAttributes))) by {\n                SubtyRefl(rt.attrs[k].ty);\n                assert subtyRecordType(rt,RecordType(map[k := rt.attrs[k]], OpenAttributes),ValidationMode.Permissive);\n                assert subty(Type.Record(rt),Type.Record(RecordType(map[k := rt.attrs[k]], OpenAttributes)),ValidationMode.Permissive);\n                SubtyCompat(Type.Record(rt),Type.Record(RecordType(map[k := rt.attrs[k]], OpenAttributes)));\n                SemSubtyTransport(r,s,e,Type.Record(rt),Type.Record(RecordType(map[k := rt.attrs[k]], OpenAttributes)));\n              }\n              assert IsSafe(r,s,HasAttr(e,k),t') by { RecordHasRequiredTrueSafe(r,s,e,k,rt.attrs[k]); }\n            } else if effs.contains(e,k) {\n              assert IsSafe(r,s,HasAttr(e,k),t') by {\n                reveal EffectsInvariant();\n              }\n            } else {\n              assert IsSafe(r,s,e,Type.Record(RecordType(map[], OpenAttributes))) by {\n                assert subty(Type.Record(rt),Type.Record(RecordType(map[], OpenAttributes)),ValidationMode.Permissive);\n                SubtyCompat(Type.Record(rt),Type.Record(RecordType(map[], OpenAttributes)));\n                SemSubtyTransport(r,s,e,Type.Record(rt),Type.Record(RecordType(map[], OpenAttributes)));\n              }\n              assert IsSafe(r,s,HasAttr(e,k),t') by { RecordHasOpenRecSafe(r,s,e,k); }\n              assert GuardedEffectsInvariant(HasAttr(e,k),Effects.singleton(e,k)) by {\n                if IsTrueStrong(r,s,HasAttr(e,k)) {\n                  IsTrueStrongImpliesIsTrue(r,s,HasAttr(e,k));\n                  reveal EffectsInvariant();\n                }\n              }\n            }\n          } else if rt.isOpen() {\n            assert IsSafe(r,s,e,Type.Record(RecordType(map[], OpenAttributes))) by {\n              assert subty(Type.Record(rt),Type.Record(RecordType(map[], OpenAttributes)),ValidationMode.Permissive);\n              SubtyCompat(Type.Record(rt),Type.Record(RecordType(map[], OpenAttributes)));\n              SemSubtyTransport(r,s,e,Type.Record(rt),Type.Record(RecordType(map[], OpenAttributes)));\n            }\n            assert IsSafe(r,s,HasAttr(e,k),t') by { RecordHasOpenRecSafe(r,s,e,k); }\n          } else {\n            assert IsSafe(r,s,HasAttr(e,k),t') by { RecordHasClosedRecFalseSafe(r,s,e,k, rt); }\n          }\n        }\n        case Entity(et) => {\n          assert Typesafe(e,effs,Type.Entity(et)) by { SubtyRefl(Type.Entity(et)); }\n          assert IsSafe(r,s,e,Type.Entity(et)) by { Sound(e,Type.Entity(et),effs); }\n          if !ets.isAttrPossible(et,k) {\n            reveal WellFormedRequestAndStore();\n            EntityHasImpossibleFalseSafe(r,s,e,k,et);\n          } else {\n            var m := ets.getLubRecordType(et,ValidationMode.Permissive).value;\n            if k in m.attrs {\n              if effs.contains(e,k) {\n                assert IsSafe(r,s,HasAttr(e,k),t') by {\n                  reveal EffectsInvariant();\n                }\n              } else {\n                assert IsSafe(r,s,e,Type.Entity(AnyEntity)) by {\n                  SubtyCompat(Type.Entity(et),Type.Entity(AnyEntity));\n                  SemSubtyTransport(r,s,e,Type.Entity(et),Type.Entity(AnyEntity));\n                }\n                assert IsSafe(r,s,HasAttr(e,k),t') by { EntityHasOpenSafe(r,s,e,k); }\n                assert GuardedEffectsInvariant(HasAttr(e,k),Effects.singleton(e,k)) by {\n                  if IsTrueStrong(r,s,HasAttr(e,k)) {\n                    IsTrueStrongImpliesIsTrue(r,s,HasAttr(e,k));\n                    reveal EffectsInvariant();\n                  }\n                }\n              }\n            } else {\n              PossibleAttrNotInLubAttrImpliesOpen(et, k, m);\n              assert IsSafe(r,s,e,Type.Entity(AnyEntity)) by {\n                SubtyCompat(Type.Entity(et),Type.Entity(AnyEntity));\n                SemSubtyTransport(r,s,e,Type.Entity(et),Type.Entity(AnyEntity));\n              }\n              assert IsSafe(r,s,HasAttr(e,k),t') by { EntityHasOpenSafe(r,s,e,k); }\n            }\n          }\n        }\n      }\n      assert IsSafe(r,s,HasAttr(e,k),t) by {\n        SubtyCompat(t',t);\n        SemSubtyTransport(r,s,HasAttr(e,k),t',t);\n      }\n    }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "72",
        "method_filepath": "./cedar-dafny/validation/thm/model.dfy",
        "method_without_assertion_filename": "AndLRetSafe_fix_72.dfy",
        "method_name": "AndLRetSafe",
        "method_content": "  lemma AndLRetSafe(r: Request, s: EntityStore, e: Expr, e': Expr, t: Type)\n    requires IsSafe(r,s,e,t)\n    requires IsTrue(r,s,e')\n    requires SemanticSubty(t,Type.Bool(AnyBool))\n    ensures IsSafe(r,s,And(e,e'),t)\n  {\n    reveal IsSafe();\n    if Evaluate(e,r,s).Ok? && Evaluate(e',r,s).Ok? {\n      assert Evaluate(e',r,s) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n      var v :| Evaluate(e,r,s) == base.Ok(v) && InstanceOfType(v,t);\n      assert InstanceOfType(v,Type.Bool(AnyBool)) by {\n        SemSubtyTransportVal(t,Type.Bool(AnyBool),v);\n      }\n      var b :| v == Value.Primitive(Primitive.Bool(b));\n      assert Evaluator(r,s).interpretShortcircuit(And(e,e'),e,e',false) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n      assert Evaluate(And(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n    } else {\n      if Evaluate(e,r,s).Err? {\n        assert Evaluator(r,s).interpretShortcircuit(And(e,e'),e,e',false) == Evaluate(e,r,s);\n        assert Evaluate(And(e,e'),r,s) == Evaluate(e,r,s);\n      } else {\n        assert Evaluate(e',r,s).Err?;\n        var b :| Evaluate(e,r,s) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n        if b {\n          assert Evaluator(r,s).interpretShortcircuit(And(e,e'),e,e',false) == Evaluate(e',r,s);\n          assert Evaluate(And(e,e'),r,s) == Evaluate(e',r,s);\n        } else {\n          assert Evaluator(r,s).interpretShortcircuit(And(e,e'),e,e',false) == base.Ok(Value.Primitive(Primitive.Bool(false)));\n          assert Evaluate(And(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(false)));\n        }\n      }\n    }\n  }\n",
        "method_without_assertion_content": "  lemma AndLRetSafe(r: Request, s: EntityStore, e: Expr, e': Expr, t: Type)\n    requires IsSafe(r,s,e,t)\n    requires IsTrue(r,s,e')\n    requires SemanticSubty(t,Type.Bool(AnyBool))\n    ensures IsSafe(r,s,And(e,e'),t)\n  {\n    reveal IsSafe();\n    if Evaluate(e,r,s).Ok? && Evaluate(e',r,s).Ok? {\n      assert Evaluate(e',r,s) == base.Ok(Value.Primitive(Primitive.Bool(true)));\n      var v :| Evaluate(e,r,s) == base.Ok(v) && InstanceOfType(v,t);\n      assert InstanceOfType(v,Type.Bool(AnyBool)) by {\n        SemSubtyTransportVal(t,Type.Bool(AnyBool),v);\n      }\n      var b :| v == Value.Primitive(Primitive.Bool(b));\n      assert Evaluator(r,s).interpretShortcircuit(And(e,e'),e,e',false) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n      assert Evaluate(And(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n    } else {\n      if Evaluate(e,r,s).Err? {\n                assert Evaluate(And(e,e'),r,s) == Evaluate(e,r,s);\n      } else {\n        assert Evaluate(e',r,s).Err?;\n        var b :| Evaluate(e,r,s) == base.Ok(Value.Primitive(Primitive.Bool(b)));\n        if b {\n          assert Evaluator(r,s).interpretShortcircuit(And(e,e'),e,e',false) == Evaluate(e',r,s);\n          assert Evaluate(And(e,e'),r,s) == Evaluate(e',r,s);\n        } else {\n          assert Evaluator(r,s).interpretShortcircuit(And(e,e'),e,e',false) == base.Ok(Value.Primitive(Primitive.Bool(false)));\n          assert Evaluate(And(e,e'),r,s) == base.Ok(Value.Primitive(Primitive.Bool(false)));\n        }\n      }\n    }\n  }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "731",
        "method_filepath": "./cedar-dafny/validation/thm/soundness.dfy",
        "method_without_assertion_filename": "TypesafeCallSemantics_fix_731.dfy",
        "method_name": "TypesafeCallSemantics",
        "method_content": "    lemma TypesafeCallSemantics(name: base.Name, es: seq<Expr>, effs: Effects, t: Type)\n      requires Typesafe(Call(name,es),effs,t)\n      ensures name in extFunTypes\n      ensures |extFunTypes[name].args| == |es|\n      ensures forall i | 0 <= i < |es| :: Typesafe(es[i],effs,extFunTypes[name].args[i])\n      ensures extFunTypes[name].ret == t\n    {\n      assert TC.inferCall(Call(name,es),name,es,effs).Ok?;\n      InferCallArgsSound(Call(name,es),name,es,extFunTypes[name].args,effs);\n\n      assert extFunTypes[name].check.Some? ==> extFunTypes[name].check.value(es).Ok?;\n      assert forall i | 0 <= i < |es| :: Typesafe(es[i],effs,extFunTypes[name].args[i]);\n      assert extFunTypes[name].ret == t;\n    }\n",
        "method_without_assertion_content": "    lemma TypesafeCallSemantics(name: base.Name, es: seq<Expr>, effs: Effects, t: Type)\n      requires Typesafe(Call(name,es),effs,t)\n      ensures name in extFunTypes\n      ensures |extFunTypes[name].args| == |es|\n      ensures forall i | 0 <= i < |es| :: Typesafe(es[i],effs,extFunTypes[name].args[i])\n      ensures extFunTypes[name].ret == t\n    {\n            InferCallArgsSound(Call(name,es),name,es,extFunTypes[name].args,effs);\n\n      assert extFunTypes[name].check.Some? ==> extFunTypes[name].check.value(es).Ok?;\n      assert forall i | 0 <= i < |es| :: Typesafe(es[i],effs,extFunTypes[name].args[i]);\n      assert extFunTypes[name].ret == t;\n    }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "810",
        "method_filepath": "./cedar-dafny/validation/thm/soundness.dfy",
        "method_without_assertion_filename": "SoundInSetMemberFalse_fix_810.dfy",
        "method_name": "SoundInSetMemberFalse",
        "method_content": "    lemma SoundInSetMemberFalse(e1: Expr, ei2s: seq<Expr>, i: nat, effs: Effects)\n      decreases BinaryApp(BinaryOp.In,e1,Expr.Set(ei2s)) , 0 , Expr.Set(ei2s) , 0\n      requires WellFormedRequestAndStore()\n      requires EffectsInvariant(effs)\n      requires WellTyped(BinaryApp(BinaryOp.In,e1,Expr.Set(ei2s)),effs)\n      requires getType(BinaryApp(BinaryOp.In,e1,Expr.Set(ei2s)),effs) == Type.Bool(False)\n      requires !reqty.isUnspecifiedVar(e1)\n      requires 0 <= i < |ei2s|\n      ensures IsFalse(r,s,BinaryApp(BinaryOp.In,e1,ei2s[i]))\n    {\n      // Reestablishing things we had at the call site in `SoundIn`.\n      var e2 := Expr.Set(ei2s);\n\n      assert TC.inferIn(BinaryApp(BinaryOp.In,e1,e2),e1,e2,effs) == types.Ok(Type.Bool(False));\n\n      assert TC.ensureEntityType(e1,effs).Ok?;\n      var t1 := getType(e1,effs);\n\n      var euids2 :- assert TC.tryGetEUIDs(e2);\n      var ets2 := set u <- euids2 :: u.ty;\n\n      // New proof.\n      var u2 :- assert TC.tryGetEUID(ei2s[i]);\n      assert u2 in euids2;\n      match e1 {\n        case Var(v1) =>\n          var et1 :- assert TC.getPrincipalOrResource(v1);\n          assert t1 == Type.Entity(EntityLUB({et1}));\n          assert IsSafe(r,s,Var(v1),t1) by { Sound(e1,t1,effs); }\n          assert !ets.possibleDescendantOf(et1,u2.ty);\n          reveal WellFormedRequestAndStore();\n          InSingleFalseEntityTypeAndLiteral(r,s,e1,et1,u2);\n        case PrimitiveLit(EntityUID(u1)) =>\n          if isAction(u1.ty) {\n            assert !acts.descendantOfSet(u1,euids2);\n            assert !acts.descendantOf(u1,u2);\n          } else {\n            assert !ets.possibleDescendantOfSet(u1.ty,ets2);\n            assert !ets.possibleDescendantOf(u1.ty,u2.ty);\n          }\n          reveal WellFormedRequestAndStore();\n          InSingleFalseLiterals(r,s,u1,u2);\n      }\n    }\n",
        "method_without_assertion_content": "    lemma SoundInSetMemberFalse(e1: Expr, ei2s: seq<Expr>, i: nat, effs: Effects)\n      decreases BinaryApp(BinaryOp.In,e1,Expr.Set(ei2s)) , 0 , Expr.Set(ei2s) , 0\n      requires WellFormedRequestAndStore()\n      requires EffectsInvariant(effs)\n      requires WellTyped(BinaryApp(BinaryOp.In,e1,Expr.Set(ei2s)),effs)\n      requires getType(BinaryApp(BinaryOp.In,e1,Expr.Set(ei2s)),effs) == Type.Bool(False)\n      requires !reqty.isUnspecifiedVar(e1)\n      requires 0 <= i < |ei2s|\n      ensures IsFalse(r,s,BinaryApp(BinaryOp.In,e1,ei2s[i]))\n    {\n      // Reestablishing things we had at the call site in `SoundIn`.\n      var e2 := Expr.Set(ei2s);\n\n      assert TC.inferIn(BinaryApp(BinaryOp.In,e1,e2),e1,e2,effs) == types.Ok(Type.Bool(False));\n\n            var t1 := getType(e1,effs);\n\n      var euids2 :- assert TC.tryGetEUIDs(e2);\n      var ets2 := set u <- euids2 :: u.ty;\n\n      // New proof.\n      var u2 :- assert TC.tryGetEUID(ei2s[i]);\n      assert u2 in euids2;\n      match e1 {\n        case Var(v1) =>\n          var et1 :- assert TC.getPrincipalOrResource(v1);\n          assert t1 == Type.Entity(EntityLUB({et1}));\n          assert IsSafe(r,s,Var(v1),t1) by { Sound(e1,t1,effs); }\n          assert !ets.possibleDescendantOf(et1,u2.ty);\n          reveal WellFormedRequestAndStore();\n          InSingleFalseEntityTypeAndLiteral(r,s,e1,et1,u2);\n        case PrimitiveLit(EntityUID(u1)) =>\n          if isAction(u1.ty) {\n            assert !acts.descendantOfSet(u1,euids2);\n            assert !acts.descendantOf(u1,u2);\n          } else {\n            assert !ets.possibleDescendantOfSet(u1.ty,ets2);\n            assert !ets.possibleDescendantOf(u1.ty,u2.ty);\n          }\n          reveal WellFormedRequestAndStore();\n          InSingleFalseLiterals(r,s,u1,u2);\n      }\n    }\n"
    },
    {
        "benchmark_name": "cedar",
        "index": "7",
        "method_filepath": "./cedar-dafny/validation/subtyping.dfy",
        "method_without_assertion_filename": "LubIsUB_fix_7.dfy",
        "method_name": "LubIsUB",
        "method_content": "  lemma LubIsUB(t1: Type, t2: Type, t: Type, m: ValidationMode)\n    requires lubOpt(t1,t2,m) == Ok(t)\n    ensures subty(t1,t,m)\n    ensures subty(t2,t,m)\n  {\n    match (t1,t2,t) {\n      case (Never,_,_) => assert t2 == t; SubtyRefl(t);\n      case (_,Never,_) => assert t1 == t; SubtyRefl(t);\n      case (Int,Int,Int) =>\n      case (String,String,String) =>\n      case(Bool(b1),Bool(b2),Bool(bt)) =>\n      case (Entity(e1),Entity(e2),Entity(e)) =>\n      case (Set(t1'),Set(t2'),Set(t')) => LubIsUB(t1',t2',t',m);\n      case(Record(rt1'),Record(rt2'),Record(rt')) =>\n        assert rt'.attrs.Keys <= rt1'.attrs.Keys;\n        assert rt'.attrs.Keys <= rt2'.attrs.Keys;\n        assert subty(Type.Record(rt1'),Type.Record(rt'),m) by {\n          forall k | k in rt'.attrs.Keys\n            ensures subtyAttrType(rt1'.attrs[k],rt'.attrs[k],m)\n          {\n            assert rt'.attrs[k] == lubAttrType(rt1'.attrs[k],rt2'.attrs[k],m);\n            assert lubOpt(rt1'.attrs[k].ty,rt2'.attrs[k].ty,m) == Ok(rt'.attrs[k].ty);\n            LubIsUB(rt1'.attrs[k].ty,rt2'.attrs[k].ty,rt'.attrs[k].ty,m);\n          }\n        }\n        assert subty(Type.Record(rt2'),Type.Record(rt'),m) by {\n          forall k | k in rt'.attrs.Keys\n            ensures subtyAttrType(rt2'.attrs[k],rt'.attrs[k],m)\n          {\n            assert rt'.attrs[k] == lubAttrType(rt1'.attrs[k],rt2'.attrs[k],m);\n            assert lubOpt(rt1'.attrs[k].ty,rt2'.attrs[k].ty,m) == Ok(rt'.attrs[k].ty);\n            LubIsUB(rt1'.attrs[k].ty,rt2'.attrs[k].ty,rt'.attrs[k].ty,m);\n          }\n        }\n      case (Extension(n1),Extension(n2),Extension(n)) =>\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LubIsUB(t1: Type, t2: Type, t: Type, m: ValidationMode)\n    requires lubOpt(t1,t2,m) == Ok(t)\n    ensures subty(t1,t,m)\n    ensures subty(t2,t,m)\n  {\n    match (t1,t2,t) {\n      case (Never,_,_) =>       case (_,Never,_) => assert t1 == t; SubtyRefl(t);\n      case (Int,Int,Int) =>\n      case (String,String,String) =>\n      case(Bool(b1),Bool(b2),Bool(bt)) =>\n      case (Entity(e1),Entity(e2),Entity(e)) =>\n      case (Set(t1'),Set(t2'),Set(t')) => LubIsUB(t1',t2',t',m);\n      case(Record(rt1'),Record(rt2'),Record(rt')) =>\n        assert rt'.attrs.Keys <= rt1'.attrs.Keys;\n        assert rt'.attrs.Keys <= rt2'.attrs.Keys;\n        assert subty(Type.Record(rt1'),Type.Record(rt'),m) by {\n          forall k | k in rt'.attrs.Keys\n            ensures subtyAttrType(rt1'.attrs[k],rt'.attrs[k],m)\n          {\n            assert rt'.attrs[k] == lubAttrType(rt1'.attrs[k],rt2'.attrs[k],m);\n            assert lubOpt(rt1'.attrs[k].ty,rt2'.attrs[k].ty,m) == Ok(rt'.attrs[k].ty);\n            LubIsUB(rt1'.attrs[k].ty,rt2'.attrs[k].ty,rt'.attrs[k].ty,m);\n          }\n        }\n        assert subty(Type.Record(rt2'),Type.Record(rt'),m) by {\n          forall k | k in rt'.attrs.Keys\n            ensures subtyAttrType(rt2'.attrs[k],rt'.attrs[k],m)\n          {\n            assert rt'.attrs[k] == lubAttrType(rt1'.attrs[k],rt2'.attrs[k],m);\n            assert lubOpt(rt1'.attrs[k].ty,rt2'.attrs[k].ty,m) == Ok(rt'.attrs[k].ty);\n            LubIsUB(rt1'.attrs[k].ty,rt2'.attrs[k].ty,rt'.attrs[k].ty,m);\n          }\n        }\n      case (Extension(n1),Extension(n2),Extension(n)) =>\n    }\n  }\n"
    },
    {
        "benchmark_name": "vmc",
        "index": "1",
        "method_filepath": "./src/Math/Helper.dfy",
        "method_without_assertion_filename": "DivModAddDenominator_fix_1.dfy",
        "method_name": "DivModAddDenominator",
        "method_content": "  lemma DivModAddDenominator(n: nat, m: nat)\n    requires m > 0\n    ensures (n + m) / m == n / m + 1\n    ensures (n + m) % m == n % m\n  {\n    var zp := (n + m) / m - n / m - 1;\n    assert 0 == m * zp + ((n + m) % m) - (n % m);\n  }\n",
        "method_without_assertion_content": "  lemma DivModAddDenominator(n: nat, m: nat)\n    requires m > 0\n    ensures (n + m) / m == n / m + 1\n    ensures (n + m) % m == n % m\n  {\n    var zp := (n + m) / m - n / m - 1;\n  }\n"
    },
    {
        "benchmark_name": "vmc",
        "index": "4",
        "method_filepath": "./src/Math/Rationals.dfy",
        "method_without_assertion_filename": "FloorIsCorrect_fix_4.dfy",
        "method_name": "FloorIsCorrect",
        "method_content": "  lemma FloorIsCorrect(r: Rational)\n    ensures Floor(r) == ToReal(r).Floor\n  {\n    var floor := r.numer / r.denom;\n    var multiple := floor * r.denom;\n    assert r.numer == multiple + r.numer % r.denom;\n    var nextMultiple := multiple + r.denom;\n    assert Floor(r) as real <= ToReal(r);\n    assert ToReal(r) < Floor(r) as real + 1.0 by {\n      assert r.numer < nextMultiple;\n      calc {\n        ToReal(r);\n      ==\n        r.numer as real / r.denom as real;\n      < { DivStrictlyMonotonic(r.denom as real, r.numer as real, nextMultiple as real); }\n        nextMultiple as real / r.denom as real;\n      ==\n        (floor + 1) as real;\n      ==\n        Floor(r) as real + 1.0;\n      }\n    }\n  }\n",
        "method_without_assertion_content": "  lemma FloorIsCorrect(r: Rational)\n    ensures Floor(r) == ToReal(r).Floor\n  {\n    var floor := r.numer / r.denom;\n    var multiple := floor * r.denom;\n    assert r.numer == multiple + r.numer % r.denom;\n    var nextMultiple := multiple + r.denom;\n        assert ToReal(r) < Floor(r) as real + 1.0 by {\n      assert r.numer < nextMultiple;\n      calc {\n        ToReal(r);\n      ==\n        r.numer as real / r.denom as real;\n      < { DivStrictlyMonotonic(r.denom as real, r.numer as real, nextMultiple as real); }\n        nextMultiple as real / r.denom as real;\n      ==\n        (floor + 1) as real;\n      ==\n        Floor(r) as real + 1.0;\n      }\n    }\n  }\n"
    },
    {
        "benchmark_name": "vmc",
        "index": "5",
        "method_filepath": "./src/Math/Rationals.dfy",
        "method_without_assertion_filename": "FloorIsCorrect_fix_5.dfy",
        "method_name": "FloorIsCorrect",
        "method_content": "  lemma FloorIsCorrect(r: Rational)\n    ensures Floor(r) == ToReal(r).Floor\n  {\n    var floor := r.numer / r.denom;\n    var multiple := floor * r.denom;\n    assert r.numer == multiple + r.numer % r.denom;\n    var nextMultiple := multiple + r.denom;\n    assert Floor(r) as real <= ToReal(r);\n    assert ToReal(r) < Floor(r) as real + 1.0 by {\n      assert r.numer < nextMultiple;\n      calc {\n        ToReal(r);\n      ==\n        r.numer as real / r.denom as real;\n      < { DivStrictlyMonotonic(r.denom as real, r.numer as real, nextMultiple as real); }\n        nextMultiple as real / r.denom as real;\n      ==\n        (floor + 1) as real;\n      ==\n        Floor(r) as real + 1.0;\n      }\n    }\n  }\n",
        "method_without_assertion_content": "  lemma FloorIsCorrect(r: Rational)\n    ensures Floor(r) == ToReal(r).Floor\n  {\n    var floor := r.numer / r.denom;\n    var multiple := floor * r.denom;\n    assert r.numer == multiple + r.numer % r.denom;\n    var nextMultiple := multiple + r.denom;\n    assert Floor(r) as real <= ToReal(r);\n    assert ToReal(r) < Floor(r) as real + 1.0 by {\n            calc {\n        ToReal(r);\n      ==\n        r.numer as real / r.denom as real;\n      < { DivStrictlyMonotonic(r.denom as real, r.numer as real, nextMultiple as real); }\n        nextMultiple as real / r.denom as real;\n      ==\n        (floor + 1) as real;\n      ==\n        Floor(r) as real + 1.0;\n      }\n    }\n  }\n"
    },
    {
        "benchmark_name": "vmc",
        "index": "6",
        "method_filepath": "./src/Math/Measures.dfy",
        "method_without_assertion_filename": "PosCountAddImpliesAdd_fix_6.dfy",
        "method_name": "PosCountAddImpliesAdd",
        "method_content": "  lemma PosCountAddImpliesAdd<T(!new)>(eventSpace: iset<iset<T>>, Prob: iset<T> -> real)\n    requires IsSigmaAlgebra(eventSpace)\n    requires IsPositive(eventSpace, Prob)\n    requires IsCountablyAdditive(eventSpace, Prob)\n    ensures IsAdditive(eventSpace, Prob)\n  {\n    forall e1, e2 | e1 in eventSpace && e2 in eventSpace && e1 * e2 == iset{} ensures Prob(e1) + Prob(e2) == Prob(e1 + e2) {\n      var f : nat -> iset<T> := (n: nat) => if n == 0 then e1 else if n == 1 then e2 else iset{};\n      assert CountableUnion(f) == e1 + e2;\n      assert CountableSum((n: nat) => Prob(f(n))) == Prob(e1) + Prob(e2) by {\n        assert CountableSum((n: nat) => Prob(f(n)), 2) == 0.0 by {\n          CountableSumOfZeroesIsZero((n: nat) => Prob(f(n)), 2);\n        }\n        calc {\n          CountableSum((n: nat) => Prob(f(n)))\n       ==\n          Prob(f(0)) + CountableSum((n: nat) => Prob(f(n)), 1)\n       ==\n          Prob(f(0)) + Prob(f(1)) + CountableSum((n: nat) => Prob(f(n)), 2)\n       ==\n          Prob(e1) + Prob(e2) + CountableSum((n: nat) => Prob(f(n)), 2)\n       ==\n          Prob(e1) + Prob(e2);\n        }\n      }\n      assert Prob(CountableUnion(f)) == CountableSum((n: nat) => Prob(f(n))) by {\n        assert IsCountablyAdditive(eventSpace, Prob);\n      }\n      assert Prob(e1 + e2) == Prob(e1) + Prob(e2);\n    }\n  }\n",
        "method_without_assertion_content": "  lemma PosCountAddImpliesAdd<T(!new)>(eventSpace: iset<iset<T>>, Prob: iset<T> -> real)\n    requires IsSigmaAlgebra(eventSpace)\n    requires IsPositive(eventSpace, Prob)\n    requires IsCountablyAdditive(eventSpace, Prob)\n    ensures IsAdditive(eventSpace, Prob)\n  {\n    forall e1, e2 | e1 in eventSpace && e2 in eventSpace && e1 * e2 == iset{} ensures Prob(e1) + Prob(e2) == Prob(e1 + e2) {\n      var f : nat -> iset<T> := (n: nat) => if n == 0 then e1 else if n == 1 then e2 else iset{};\n            assert CountableSum((n: nat) => Prob(f(n))) == Prob(e1) + Prob(e2) by {\n        assert CountableSum((n: nat) => Prob(f(n)), 2) == 0.0 by {\n          CountableSumOfZeroesIsZero((n: nat) => Prob(f(n)), 2);\n        }\n        calc {\n          CountableSum((n: nat) => Prob(f(n)))\n       ==\n          Prob(f(0)) + CountableSum((n: nat) => Prob(f(n)), 1)\n       ==\n          Prob(f(0)) + Prob(f(1)) + CountableSum((n: nat) => Prob(f(n)), 2)\n       ==\n          Prob(e1) + Prob(e2) + CountableSum((n: nat) => Prob(f(n)), 2)\n       ==\n          Prob(e1) + Prob(e2);\n        }\n      }\n      assert Prob(CountableUnion(f)) == CountableSum((n: nat) => Prob(f(n))) by {\n        assert IsCountablyAdditive(eventSpace, Prob);\n      }\n      assert Prob(e1 + e2) == Prob(e1) + Prob(e2);\n    }\n  }\n"
    },
    {
        "benchmark_name": "vmc",
        "index": "11",
        "method_filepath": "./src/Math/Analysis/Limits.dfy",
        "method_without_assertion_filename": "LimitIsMultiplicative_fix_11.dfy",
        "method_name": "LimitIsMultiplicative",
        "method_content": "  lemma LimitIsMultiplicative(sequence1: nat -> real, limit1: real, sequence2: nat -> real, limit2: real)\n    requires ConvergesTo(sequence1, limit1)\n    requires ConvergesTo(sequence2, limit2)\n    ensures ConvergesTo(Sequences.Mul(sequence1, sequence2), limit1 * limit2)\n  {\n    var bound1 := BoundOfConvergentSequence(sequence1, limit1);\n    var bound2 := BoundOfConvergentSequence(sequence2, limit2);\n    var productSequence := Sequences.Mul(sequence1, sequence2);\n    var productLimit := limit1 * limit2;\n    forall epsilon: real | epsilon > 0.0 ensures ExistsCloseSuffix(productSequence, productLimit, epsilon) {\n      var epsilon1 := epsilon / 2.0 / RealArith.Max(RealArith.Abs(limit2), 1.0);\n      var epsilon2 := epsilon / 2.0 / RealArith.Max(bound1, 1.0);\n      assert ExistsCloseSuffix(sequence1, limit1, epsilon1);\n      var N1: nat :| SuffixIsClose(sequence1, limit1, epsilon1, N1);\n      assert ExistsCloseSuffix(sequence2, limit2, epsilon2);\n      var N2: nat :| SuffixIsClose(sequence2, limit2, epsilon2, N2);\n      var N: nat :| N >= N1 && N >= N2;\n      assert SuffixIsClose(productSequence, productLimit, epsilon, N) by {\n        forall n: nat | n >= N ensures RealArith.Dist(productSequence(n), productLimit) < epsilon {\n          var s1 := sequence1(n);\n          var s2 := sequence2(n);\n          calc {\n            RealArith.Dist(productSequence(n), productLimit);\n          == { assert productSequence(n) == sequence1(n) * sequence2(n) == s1 * s2; }\n            RealArith.Dist(s1 * s2, limit1 * limit2);\n          < { LimitIsMultiplicativeSuffixHelper(s1, limit1, s2, limit2, bound1, epsilon); }\n            epsilon;\n          }\n        }\n      }\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LimitIsMultiplicative(sequence1: nat -> real, limit1: real, sequence2: nat -> real, limit2: real)\n    requires ConvergesTo(sequence1, limit1)\n    requires ConvergesTo(sequence2, limit2)\n    ensures ConvergesTo(Sequences.Mul(sequence1, sequence2), limit1 * limit2)\n  {\n    var bound1 := BoundOfConvergentSequence(sequence1, limit1);\n    var bound2 := BoundOfConvergentSequence(sequence2, limit2);\n    var productSequence := Sequences.Mul(sequence1, sequence2);\n    var productLimit := limit1 * limit2;\n    forall epsilon: real | epsilon > 0.0 ensures ExistsCloseSuffix(productSequence, productLimit, epsilon) {\n      var epsilon1 := epsilon / 2.0 / RealArith.Max(RealArith.Abs(limit2), 1.0);\n      var epsilon2 := epsilon / 2.0 / RealArith.Max(bound1, 1.0);\n            var N1: nat :| SuffixIsClose(sequence1, limit1, epsilon1, N1);\n      assert ExistsCloseSuffix(sequence2, limit2, epsilon2);\n      var N2: nat :| SuffixIsClose(sequence2, limit2, epsilon2, N2);\n      var N: nat :| N >= N1 && N >= N2;\n      assert SuffixIsClose(productSequence, productLimit, epsilon, N) by {\n        forall n: nat | n >= N ensures RealArith.Dist(productSequence(n), productLimit) < epsilon {\n          var s1 := sequence1(n);\n          var s2 := sequence2(n);\n          calc {\n            RealArith.Dist(productSequence(n), productLimit);\n          == { assert productSequence(n) == sequence1(n) * sequence2(n) == s1 * s2; }\n            RealArith.Dist(s1 * s2, limit1 * limit2);\n          < { LimitIsMultiplicativeSuffixHelper(s1, limit1, s2, limit2, bound1, epsilon); }\n            epsilon;\n          }\n        }\n      }\n    }\n  }\n"
    },
    {
        "benchmark_name": "vmc",
        "index": "12",
        "method_filepath": "./src/Math/Analysis/Limits.dfy",
        "method_without_assertion_filename": "LimitIsMultiplicative_fix_12.dfy",
        "method_name": "LimitIsMultiplicative",
        "method_content": "  lemma LimitIsMultiplicative(sequence1: nat -> real, limit1: real, sequence2: nat -> real, limit2: real)\n    requires ConvergesTo(sequence1, limit1)\n    requires ConvergesTo(sequence2, limit2)\n    ensures ConvergesTo(Sequences.Mul(sequence1, sequence2), limit1 * limit2)\n  {\n    var bound1 := BoundOfConvergentSequence(sequence1, limit1);\n    var bound2 := BoundOfConvergentSequence(sequence2, limit2);\n    var productSequence := Sequences.Mul(sequence1, sequence2);\n    var productLimit := limit1 * limit2;\n    forall epsilon: real | epsilon > 0.0 ensures ExistsCloseSuffix(productSequence, productLimit, epsilon) {\n      var epsilon1 := epsilon / 2.0 / RealArith.Max(RealArith.Abs(limit2), 1.0);\n      var epsilon2 := epsilon / 2.0 / RealArith.Max(bound1, 1.0);\n      assert ExistsCloseSuffix(sequence1, limit1, epsilon1);\n      var N1: nat :| SuffixIsClose(sequence1, limit1, epsilon1, N1);\n      assert ExistsCloseSuffix(sequence2, limit2, epsilon2);\n      var N2: nat :| SuffixIsClose(sequence2, limit2, epsilon2, N2);\n      var N: nat :| N >= N1 && N >= N2;\n      assert SuffixIsClose(productSequence, productLimit, epsilon, N) by {\n        forall n: nat | n >= N ensures RealArith.Dist(productSequence(n), productLimit) < epsilon {\n          var s1 := sequence1(n);\n          var s2 := sequence2(n);\n          calc {\n            RealArith.Dist(productSequence(n), productLimit);\n          == { assert productSequence(n) == sequence1(n) * sequence2(n) == s1 * s2; }\n            RealArith.Dist(s1 * s2, limit1 * limit2);\n          < { LimitIsMultiplicativeSuffixHelper(s1, limit1, s2, limit2, bound1, epsilon); }\n            epsilon;\n          }\n        }\n      }\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LimitIsMultiplicative(sequence1: nat -> real, limit1: real, sequence2: nat -> real, limit2: real)\n    requires ConvergesTo(sequence1, limit1)\n    requires ConvergesTo(sequence2, limit2)\n    ensures ConvergesTo(Sequences.Mul(sequence1, sequence2), limit1 * limit2)\n  {\n    var bound1 := BoundOfConvergentSequence(sequence1, limit1);\n    var bound2 := BoundOfConvergentSequence(sequence2, limit2);\n    var productSequence := Sequences.Mul(sequence1, sequence2);\n    var productLimit := limit1 * limit2;\n    forall epsilon: real | epsilon > 0.0 ensures ExistsCloseSuffix(productSequence, productLimit, epsilon) {\n      var epsilon1 := epsilon / 2.0 / RealArith.Max(RealArith.Abs(limit2), 1.0);\n      var epsilon2 := epsilon / 2.0 / RealArith.Max(bound1, 1.0);\n      assert ExistsCloseSuffix(sequence1, limit1, epsilon1);\n      var N1: nat :| SuffixIsClose(sequence1, limit1, epsilon1, N1);\n            var N2: nat :| SuffixIsClose(sequence2, limit2, epsilon2, N2);\n      var N: nat :| N >= N1 && N >= N2;\n      assert SuffixIsClose(productSequence, productLimit, epsilon, N) by {\n        forall n: nat | n >= N ensures RealArith.Dist(productSequence(n), productLimit) < epsilon {\n          var s1 := sequence1(n);\n          var s2 := sequence2(n);\n          calc {\n            RealArith.Dist(productSequence(n), productLimit);\n          == { assert productSequence(n) == sequence1(n) * sequence2(n) == s1 * s2; }\n            RealArith.Dist(s1 * s2, limit1 * limit2);\n          < { LimitIsMultiplicativeSuffixHelper(s1, limit1, s2, limit2, bound1, epsilon); }\n            epsilon;\n          }\n        }\n      }\n    }\n  }\n"
    },
    {
        "benchmark_name": "vmc",
        "index": "14",
        "method_filepath": "./src/Math/Analysis/Limits.dfy",
        "method_without_assertion_filename": "LimitOfInverse_fix_14.dfy",
        "method_name": "LimitOfInverse",
        "method_content": "  lemma LimitOfInverse(sequence: nat -> real, limit: real)\n    requires forall n: nat :: sequence(n) != 0.0\n    requires limit != 0.0\n    requires ConvergesTo(sequence, limit)\n    ensures ConvergesTo(Sequences.Inverse(sequence), 1.0 / limit)\n  {\n    var invSeq := Sequences.Inverse(sequence);\n    var invLimit := 1.0 / limit;\n    forall epsilon: real | epsilon > 0.0 ensures ExistsCloseSuffix(invSeq, invLimit, epsilon) {\n      var limitSquared := limit * limit;\n      var epsilon' := RealArith.Min(RealArith.Abs(limit) / 2.0, (epsilon * limitSquared) / 2.0);\n      assert ExistsCloseSuffix(sequence, limit, epsilon');\n      var N: nat :| SuffixIsClose(sequence, limit, epsilon', N);\n      assert SuffixIsClose(invSeq, invLimit, epsilon, N) by {\n        forall n: nat | n >= N ensures RealArith.Dist(invSeq(n), invLimit) < epsilon {\n          var s := sequence(n);\n          calc {\n            RealArith.Dist(invSeq(n), invLimit);\n          == { assert invSeq(n) == 1.0 / s; }\n            RealArith.Dist(1.0 / s, 1.0 / limit);\n          == { LimitOfInverseHelper1(s, limit); }\n            RealArith.Dist(s, limit) / RealArith.Abs(limit) / RealArith.Abs(s);\n          <= { LimitOfInverseHelper2(s, limit); }\n            2.0 * RealArith.Dist(s, limit) / limitSquared;\n          < { RealArith.DivisionIsMonotonicStrict(2.0 * RealArith.Dist(s, limit), 2.0 * epsilon', limitSquared); }\n            2.0 * epsilon' / limitSquared;\n          <= { RealArith.DivisionIsMonotonic(2.0 * epsilon', 2.0 * (epsilon * limitSquared) / 2.0, limitSquared); }\n            2.0 * (epsilon * limitSquared) / 2.0 / limitSquared;\n          == { assert 2.0 * (epsilon * limitSquared) / 2.0 == epsilon * limitSquared; }\n            (epsilon * limitSquared) / limitSquared;\n          ==\n            epsilon;\n          }\n        }\n      }\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LimitOfInverse(sequence: nat -> real, limit: real)\n    requires forall n: nat :: sequence(n) != 0.0\n    requires limit != 0.0\n    requires ConvergesTo(sequence, limit)\n    ensures ConvergesTo(Sequences.Inverse(sequence), 1.0 / limit)\n  {\n    var invSeq := Sequences.Inverse(sequence);\n    var invLimit := 1.0 / limit;\n    forall epsilon: real | epsilon > 0.0 ensures ExistsCloseSuffix(invSeq, invLimit, epsilon) {\n      var limitSquared := limit * limit;\n      var epsilon' := RealArith.Min(RealArith.Abs(limit) / 2.0, (epsilon * limitSquared) / 2.0);\n            var N: nat :| SuffixIsClose(sequence, limit, epsilon', N);\n      assert SuffixIsClose(invSeq, invLimit, epsilon, N) by {\n        forall n: nat | n >= N ensures RealArith.Dist(invSeq(n), invLimit) < epsilon {\n          var s := sequence(n);\n          calc {\n            RealArith.Dist(invSeq(n), invLimit);\n          == { assert invSeq(n) == 1.0 / s; }\n            RealArith.Dist(1.0 / s, 1.0 / limit);\n          == { LimitOfInverseHelper1(s, limit); }\n            RealArith.Dist(s, limit) / RealArith.Abs(limit) / RealArith.Abs(s);\n          <= { LimitOfInverseHelper2(s, limit); }\n            2.0 * RealArith.Dist(s, limit) / limitSquared;\n          < { RealArith.DivisionIsMonotonicStrict(2.0 * RealArith.Dist(s, limit), 2.0 * epsilon', limitSquared); }\n            2.0 * epsilon' / limitSquared;\n          <= { RealArith.DivisionIsMonotonic(2.0 * epsilon', 2.0 * (epsilon * limitSquared) / 2.0, limitSquared); }\n            2.0 * (epsilon * limitSquared) / 2.0 / limitSquared;\n          == { assert 2.0 * (epsilon * limitSquared) / 2.0 == epsilon * limitSquared; }\n            (epsilon * limitSquared) / limitSquared;\n          ==\n            epsilon;\n          }\n        }\n      }\n    }\n  }\n"
    },
    {
        "benchmark_name": "vmc",
        "index": "15",
        "method_filepath": "./src/Math/Analysis/Limits.dfy",
        "method_without_assertion_filename": "ConstantSequenceConverges_fix_15.dfy",
        "method_name": "ConstantSequenceConverges",
        "method_content": "  lemma ConstantSequenceConverges(constant: real)\n    ensures ConvergesTo(Sequences.Constant(constant), constant)\n  {\n    forall epsilon: real | epsilon > 0.0 ensures ExistsCloseSuffix(Sequences.Constant(constant), constant, epsilon) {\n      assert SuffixIsClose(Sequences.Constant(constant), constant, epsilon, 0);\n    }\n  }\n",
        "method_without_assertion_content": "  lemma ConstantSequenceConverges(constant: real)\n    ensures ConvergesTo(Sequences.Constant(constant), constant)\n  {\n    forall epsilon: real | epsilon > 0.0 ensures ExistsCloseSuffix(Sequences.Constant(constant), constant, epsilon) {\n          }\n  }\n"
    },
    {
        "benchmark_name": "vmc",
        "index": "16",
        "method_filepath": "./src/Math/Analysis/Limits.dfy",
        "method_without_assertion_filename": "LimitIsUnique_fix_16.dfy",
        "method_name": "LimitIsUnique",
        "method_content": "  lemma LimitIsUnique(sequence: nat -> real, limit1: real, limit2: real)\n    requires ConvergesTo(sequence, limit1)\n    requires ConvergesTo(sequence, limit2)\n    ensures limit1 == limit2\n  {\n    if ConvergesTo(sequence, limit1) && ConvergesTo(sequence, limit2) && limit1 != limit2 {\n      var epsilon := RealArith.Dist(limit1, limit2) / 2.0;\n      assert ExistsCloseSuffix(sequence, limit1, epsilon);\n      var N1 : nat :| SuffixIsClose(sequence, limit1, epsilon, N1);\n      assert ExistsCloseSuffix(sequence, limit2, epsilon);\n      var N2 : nat :| SuffixIsClose(sequence, limit2, epsilon, N2);\n      var N : nat :| N >= N1 && N >= N2;\n      calc {\n        RealArith.Dist(limit1, limit2);\n      <= { RealArith.TriangleInequality(limit1, sequence(N), limit2); }\n        RealArith.Dist(limit1, sequence(N)) + RealArith.Dist(sequence(N), limit2);\n      <\n        epsilon + epsilon;\n      ==\n        epsilon * 2.0;\n      ==\n        RealArith.Dist(limit1, limit2);\n      }\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LimitIsUnique(sequence: nat -> real, limit1: real, limit2: real)\n    requires ConvergesTo(sequence, limit1)\n    requires ConvergesTo(sequence, limit2)\n    ensures limit1 == limit2\n  {\n    if ConvergesTo(sequence, limit1) && ConvergesTo(sequence, limit2) && limit1 != limit2 {\n      var epsilon := RealArith.Dist(limit1, limit2) / 2.0;\n            var N1 : nat :| SuffixIsClose(sequence, limit1, epsilon, N1);\n      assert ExistsCloseSuffix(sequence, limit2, epsilon);\n      var N2 : nat :| SuffixIsClose(sequence, limit2, epsilon, N2);\n      var N : nat :| N >= N1 && N >= N2;\n      calc {\n        RealArith.Dist(limit1, limit2);\n      <= { RealArith.TriangleInequality(limit1, sequence(N), limit2); }\n        RealArith.Dist(limit1, sequence(N)) + RealArith.Dist(sequence(N), limit2);\n      <\n        epsilon + epsilon;\n      ==\n        epsilon * 2.0;\n      ==\n        RealArith.Dist(limit1, limit2);\n      }\n    }\n  }\n"
    },
    {
        "benchmark_name": "vmc",
        "index": "17",
        "method_filepath": "./src/Math/Analysis/Limits.dfy",
        "method_without_assertion_filename": "LimitIsUnique_fix_17.dfy",
        "method_name": "LimitIsUnique",
        "method_content": "  lemma LimitIsUnique(sequence: nat -> real, limit1: real, limit2: real)\n    requires ConvergesTo(sequence, limit1)\n    requires ConvergesTo(sequence, limit2)\n    ensures limit1 == limit2\n  {\n    if ConvergesTo(sequence, limit1) && ConvergesTo(sequence, limit2) && limit1 != limit2 {\n      var epsilon := RealArith.Dist(limit1, limit2) / 2.0;\n      assert ExistsCloseSuffix(sequence, limit1, epsilon);\n      var N1 : nat :| SuffixIsClose(sequence, limit1, epsilon, N1);\n      assert ExistsCloseSuffix(sequence, limit2, epsilon);\n      var N2 : nat :| SuffixIsClose(sequence, limit2, epsilon, N2);\n      var N : nat :| N >= N1 && N >= N2;\n      calc {\n        RealArith.Dist(limit1, limit2);\n      <= { RealArith.TriangleInequality(limit1, sequence(N), limit2); }\n        RealArith.Dist(limit1, sequence(N)) + RealArith.Dist(sequence(N), limit2);\n      <\n        epsilon + epsilon;\n      ==\n        epsilon * 2.0;\n      ==\n        RealArith.Dist(limit1, limit2);\n      }\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LimitIsUnique(sequence: nat -> real, limit1: real, limit2: real)\n    requires ConvergesTo(sequence, limit1)\n    requires ConvergesTo(sequence, limit2)\n    ensures limit1 == limit2\n  {\n    if ConvergesTo(sequence, limit1) && ConvergesTo(sequence, limit2) && limit1 != limit2 {\n      var epsilon := RealArith.Dist(limit1, limit2) / 2.0;\n      assert ExistsCloseSuffix(sequence, limit1, epsilon);\n      var N1 : nat :| SuffixIsClose(sequence, limit1, epsilon, N1);\n            var N2 : nat :| SuffixIsClose(sequence, limit2, epsilon, N2);\n      var N : nat :| N >= N1 && N >= N2;\n      calc {\n        RealArith.Dist(limit1, limit2);\n      <= { RealArith.TriangleInequality(limit1, sequence(N), limit2); }\n        RealArith.Dist(limit1, sequence(N)) + RealArith.Dist(sequence(N), limit2);\n      <\n        epsilon + epsilon;\n      ==\n        epsilon * 2.0;\n      ==\n        RealArith.Dist(limit1, limit2);\n      }\n    }\n  }\n"
    },
    {
        "benchmark_name": "vmc",
        "index": "18",
        "method_filepath": "./src/Math/Analysis/Limits.dfy",
        "method_without_assertion_filename": "BoundOfConvergentSequence_fix_18.dfy",
        "method_name": "BoundOfConvergentSequence",
        "method_content": "  lemma BoundOfConvergentSequence(sequence: nat -> real, limit: real) returns (bound: real)\n    requires ConvergesTo(sequence, limit)\n    ensures Sequences.IsBounded(sequence, bound)\n    ensures bound > 0.0\n  {\n    assert ExistsCloseSuffix(sequence, limit, 1.0);\n    var N: nat :| SuffixIsClose(sequence, limit, 1.0, N);\n    bound := RealArith.Abs(limit) + 1.0;\n    for n := 0 to N\n      invariant bound >= RealArith.Abs(limit) + 1.0\n      invariant forall i: nat | i < n :: RealArith.Abs(sequence(i)) < bound\n    {\n      if RealArith.Abs(sequence(n)) >= bound {\n        bound := RealArith.Abs(sequence(n)) + 1.0;\n      }\n    }\n    assert forall n: nat | n < N :: RealArith.Abs(sequence(n)) < bound;\n    forall n: nat ensures RealArith.Abs(sequence(n)) < bound {\n      if n < N {\n        assert RealArith.Abs(sequence(n)) < bound;\n      } else {\n        assert RealArith.Abs(sequence(n)) < RealArith.Abs(limit) + 1.0 <= bound;\n      }\n    }\n  }\n",
        "method_without_assertion_content": "  lemma BoundOfConvergentSequence(sequence: nat -> real, limit: real) returns (bound: real)\n    requires ConvergesTo(sequence, limit)\n    ensures Sequences.IsBounded(sequence, bound)\n    ensures bound > 0.0\n  {\n        var N: nat :| SuffixIsClose(sequence, limit, 1.0, N);\n    bound := RealArith.Abs(limit) + 1.0;\n    for n := 0 to N\n      invariant bound >= RealArith.Abs(limit) + 1.0\n      invariant forall i: nat | i < n :: RealArith.Abs(sequence(i)) < bound\n    {\n      if RealArith.Abs(sequence(n)) >= bound {\n        bound := RealArith.Abs(sequence(n)) + 1.0;\n      }\n    }\n    assert forall n: nat | n < N :: RealArith.Abs(sequence(n)) < bound;\n    forall n: nat ensures RealArith.Abs(sequence(n)) < bound {\n      if n < N {\n        assert RealArith.Abs(sequence(n)) < bound;\n      } else {\n        assert RealArith.Abs(sequence(n)) < RealArith.Abs(limit) + 1.0 <= bound;\n      }\n    }\n  }\n"
    },
    {
        "benchmark_name": "vmc",
        "index": "22",
        "method_filepath": "./src/Math/Analysis/Limits.dfy",
        "method_without_assertion_filename": "LimitIsAdditive_fix_22.dfy",
        "method_name": "LimitIsAdditive",
        "method_content": "  lemma LimitIsAdditive(sequence1: nat -> real, limit1: real, sequence2: nat -> real, limit2: real)\n    requires ConvergesTo(sequence1, limit1)\n    requires ConvergesTo(sequence2, limit2)\n    ensures ConvergesTo(Sequences.Add(sequence1, sequence2), limit1 + limit2)\n  {\n    var sumSequence := Sequences.Add(sequence1, sequence2);\n    var sumLimit := limit1 + limit2;\n    forall epsilon: real | epsilon > 0.0 ensures ExistsCloseSuffix(sumSequence, sumLimit, epsilon) {\n      assert ExistsCloseSuffix(sequence1, limit1, epsilon / 2.0);\n      var N1: nat :| SuffixIsClose(sequence1, limit1, epsilon / 2.0, N1);\n      assert ExistsCloseSuffix(sequence2, limit2, epsilon / 2.0);\n      var N2: nat :| SuffixIsClose(sequence2, limit2, epsilon / 2.0, N2);\n      var N: nat :| N >= N1 && N >= N2;\n      assert SuffixIsClose(sumSequence, sumLimit, epsilon, N) by {\n        forall n: nat | n >= N ensures RealArith.Dist(sumSequence(n), sumLimit) < epsilon {\n          calc {\n            RealArith.Dist(sumSequence(n), sumLimit);\n          ==\n            RealArith.Dist(sequence1(n) + sequence2(n), limit1 + limit2);\n          <=\n            RealArith.Dist(sequence1(n), limit1) + RealArith.Dist(sequence2(n), limit2);\n          <\n            epsilon / 2.0 + epsilon / 2.0;\n          ==\n            epsilon;\n          }\n        }\n      }\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LimitIsAdditive(sequence1: nat -> real, limit1: real, sequence2: nat -> real, limit2: real)\n    requires ConvergesTo(sequence1, limit1)\n    requires ConvergesTo(sequence2, limit2)\n    ensures ConvergesTo(Sequences.Add(sequence1, sequence2), limit1 + limit2)\n  {\n    var sumSequence := Sequences.Add(sequence1, sequence2);\n    var sumLimit := limit1 + limit2;\n    forall epsilon: real | epsilon > 0.0 ensures ExistsCloseSuffix(sumSequence, sumLimit, epsilon) {\n            var N1: nat :| SuffixIsClose(sequence1, limit1, epsilon / 2.0, N1);\n      assert ExistsCloseSuffix(sequence2, limit2, epsilon / 2.0);\n      var N2: nat :| SuffixIsClose(sequence2, limit2, epsilon / 2.0, N2);\n      var N: nat :| N >= N1 && N >= N2;\n      assert SuffixIsClose(sumSequence, sumLimit, epsilon, N) by {\n        forall n: nat | n >= N ensures RealArith.Dist(sumSequence(n), sumLimit) < epsilon {\n          calc {\n            RealArith.Dist(sumSequence(n), sumLimit);\n          ==\n            RealArith.Dist(sequence1(n) + sequence2(n), limit1 + limit2);\n          <=\n            RealArith.Dist(sequence1(n), limit1) + RealArith.Dist(sequence2(n), limit2);\n          <\n            epsilon / 2.0 + epsilon / 2.0;\n          ==\n            epsilon;\n          }\n        }\n      }\n    }\n  }\n"
    },
    {
        "benchmark_name": "vmc",
        "index": "23",
        "method_filepath": "./src/Math/Analysis/Limits.dfy",
        "method_without_assertion_filename": "LimitIsAdditive_fix_23.dfy",
        "method_name": "LimitIsAdditive",
        "method_content": "  lemma LimitIsAdditive(sequence1: nat -> real, limit1: real, sequence2: nat -> real, limit2: real)\n    requires ConvergesTo(sequence1, limit1)\n    requires ConvergesTo(sequence2, limit2)\n    ensures ConvergesTo(Sequences.Add(sequence1, sequence2), limit1 + limit2)\n  {\n    var sumSequence := Sequences.Add(sequence1, sequence2);\n    var sumLimit := limit1 + limit2;\n    forall epsilon: real | epsilon > 0.0 ensures ExistsCloseSuffix(sumSequence, sumLimit, epsilon) {\n      assert ExistsCloseSuffix(sequence1, limit1, epsilon / 2.0);\n      var N1: nat :| SuffixIsClose(sequence1, limit1, epsilon / 2.0, N1);\n      assert ExistsCloseSuffix(sequence2, limit2, epsilon / 2.0);\n      var N2: nat :| SuffixIsClose(sequence2, limit2, epsilon / 2.0, N2);\n      var N: nat :| N >= N1 && N >= N2;\n      assert SuffixIsClose(sumSequence, sumLimit, epsilon, N) by {\n        forall n: nat | n >= N ensures RealArith.Dist(sumSequence(n), sumLimit) < epsilon {\n          calc {\n            RealArith.Dist(sumSequence(n), sumLimit);\n          ==\n            RealArith.Dist(sequence1(n) + sequence2(n), limit1 + limit2);\n          <=\n            RealArith.Dist(sequence1(n), limit1) + RealArith.Dist(sequence2(n), limit2);\n          <\n            epsilon / 2.0 + epsilon / 2.0;\n          ==\n            epsilon;\n          }\n        }\n      }\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LimitIsAdditive(sequence1: nat -> real, limit1: real, sequence2: nat -> real, limit2: real)\n    requires ConvergesTo(sequence1, limit1)\n    requires ConvergesTo(sequence2, limit2)\n    ensures ConvergesTo(Sequences.Add(sequence1, sequence2), limit1 + limit2)\n  {\n    var sumSequence := Sequences.Add(sequence1, sequence2);\n    var sumLimit := limit1 + limit2;\n    forall epsilon: real | epsilon > 0.0 ensures ExistsCloseSuffix(sumSequence, sumLimit, epsilon) {\n      assert ExistsCloseSuffix(sequence1, limit1, epsilon / 2.0);\n      var N1: nat :| SuffixIsClose(sequence1, limit1, epsilon / 2.0, N1);\n            var N2: nat :| SuffixIsClose(sequence2, limit2, epsilon / 2.0, N2);\n      var N: nat :| N >= N1 && N >= N2;\n      assert SuffixIsClose(sumSequence, sumLimit, epsilon, N) by {\n        forall n: nat | n >= N ensures RealArith.Dist(sumSequence(n), sumLimit) < epsilon {\n          calc {\n            RealArith.Dist(sumSequence(n), sumLimit);\n          ==\n            RealArith.Dist(sequence1(n) + sequence2(n), limit1 + limit2);\n          <=\n            RealArith.Dist(sequence1(n), limit1) + RealArith.Dist(sequence2(n), limit2);\n          <\n            epsilon / 2.0 + epsilon / 2.0;\n          ==\n            epsilon;\n          }\n        }\n      }\n    }\n  }\n"
    },
    {
        "benchmark_name": "vmc",
        "index": "24",
        "method_filepath": "./src/Math/Analysis/Limits.dfy",
        "method_without_assertion_filename": "LimitOfMultiplicationWithZeroSequence_fix_24.dfy",
        "method_name": "LimitOfMultiplicationWithZeroSequence",
        "method_content": "  lemma LimitOfMultiplicationWithZeroSequence(sequence: nat -> real, bound: real, zeroSeq: nat -> real)\n    requires Sequences.IsBounded(sequence, bound)\n    requires ConvergesTo(zeroSeq, 0.0)\n    ensures ConvergesTo(Sequences.Mul(sequence, zeroSeq), 0.0)\n  {\n    var productSequence := Sequences.Mul(sequence, zeroSeq);\n    forall epsilon: real | epsilon > 0.0 ensures ExistsCloseSuffix(productSequence, 0.0, epsilon) {\n      var epsilon' := epsilon / RealArith.Max(bound, 1.0);\n      assert ExistsCloseSuffix(zeroSeq, 0.0, epsilon');\n      var N :| SuffixIsClose(zeroSeq, 0.0, epsilon', N);\n      assert SuffixIsClose(productSequence, 0.0, epsilon, N) by {\n        forall n: nat | n >= N ensures RealArith.Dist(productSequence(n), 0.0) < epsilon {\n          var s := sequence(n);\n          var z := zeroSeq(n);\n          calc {\n            RealArith.Dist(productSequence(n), 0.0);\n          ==\n            RealArith.Abs(s * z);\n          == { RealArith.AbsMul(s, z); }\n            RealArith.Abs(s) * RealArith.Abs(z);\n          <= { RealArith.MulMonotonic(RealArith.Abs(s), RealArith.Abs(z), epsilon'); }\n            RealArith.Abs(s) * epsilon';\n          < { RealArith.MulMonotonicStrict(epsilon', RealArith.Abs(s), bound); }\n            bound * epsilon';\n          <= { RealArith.MulMonotonic(epsilon', bound, RealArith.Max(bound, 1.0)); }\n            RealArith.Max(bound, 1.0) * epsilon';\n          ==\n            epsilon;\n          }\n        }\n      }\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LimitOfMultiplicationWithZeroSequence(sequence: nat -> real, bound: real, zeroSeq: nat -> real)\n    requires Sequences.IsBounded(sequence, bound)\n    requires ConvergesTo(zeroSeq, 0.0)\n    ensures ConvergesTo(Sequences.Mul(sequence, zeroSeq), 0.0)\n  {\n    var productSequence := Sequences.Mul(sequence, zeroSeq);\n    forall epsilon: real | epsilon > 0.0 ensures ExistsCloseSuffix(productSequence, 0.0, epsilon) {\n      var epsilon' := epsilon / RealArith.Max(bound, 1.0);\n            var N :| SuffixIsClose(zeroSeq, 0.0, epsilon', N);\n      assert SuffixIsClose(productSequence, 0.0, epsilon, N) by {\n        forall n: nat | n >= N ensures RealArith.Dist(productSequence(n), 0.0) < epsilon {\n          var s := sequence(n);\n          var z := zeroSeq(n);\n          calc {\n            RealArith.Dist(productSequence(n), 0.0);\n          ==\n            RealArith.Abs(s * z);\n          == { RealArith.AbsMul(s, z); }\n            RealArith.Abs(s) * RealArith.Abs(z);\n          <= { RealArith.MulMonotonic(RealArith.Abs(s), RealArith.Abs(z), epsilon'); }\n            RealArith.Abs(s) * epsilon';\n          < { RealArith.MulMonotonicStrict(epsilon', RealArith.Abs(s), bound); }\n            bound * epsilon';\n          <= { RealArith.MulMonotonic(epsilon', bound, RealArith.Max(bound, 1.0)); }\n            RealArith.Max(bound, 1.0) * epsilon';\n          ==\n            epsilon;\n          }\n        }\n      }\n    }\n  }\n"
    },
    {
        "benchmark_name": "vmc",
        "index": "26",
        "method_filepath": "./src/Math/Analysis/Sequences.dfy",
        "method_without_assertion_filename": "OneOverNPlus1IsAntimonotonic_fix_26.dfy",
        "method_name": "OneOverNPlus1IsAntimonotonic",
        "method_content": "  lemma OneOverNPlus1IsAntimonotonic(m: nat, n: nat)\n    requires m <= n\n    ensures OneOverNPlus1(m) >= OneOverNPlus1(n)\n  {\n    var mp1 := (m + 1) as real;\n    var np1 := (n + 1) as real;\n    assert mp1 > 0.0;\n    assert np1 > 0.0;\n    calc {\n      mp1 <= np1;\n    ==\n      mp1 / np1 <= 1.0;\n    ==\n      (1.0 / np1) * mp1 <= (1.0 / mp1) * mp1;\n    == { RealArith.MultiplicationCancelMonotonic(mp1, 1.0 / np1, 1.0 / mp1); }\n      1.0 / np1 <= 1.0 / mp1;\n    ==\n      OneOverNPlus1(m) >= OneOverNPlus1(n);\n    }\n  }\n",
        "method_without_assertion_content": "  lemma OneOverNPlus1IsAntimonotonic(m: nat, n: nat)\n    requires m <= n\n    ensures OneOverNPlus1(m) >= OneOverNPlus1(n)\n  {\n    var mp1 := (m + 1) as real;\n    var np1 := (n + 1) as real;\n    assert mp1 > 0.0;\n        calc {\n      mp1 <= np1;\n    ==\n      mp1 / np1 <= 1.0;\n    ==\n      (1.0 / np1) * mp1 <= (1.0 / mp1) * mp1;\n    == { RealArith.MultiplicationCancelMonotonic(mp1, 1.0 / np1, 1.0 / mp1); }\n      1.0 / np1 <= 1.0 / mp1;\n    ==\n      OneOverNPlus1(m) >= OneOverNPlus1(n);\n    }\n  }\n"
    },
    {
        "benchmark_name": "vmc",
        "index": "27",
        "method_filepath": "./src/Math/Analysis/Reals.dfy",
        "method_without_assertion_filename": "Sqrt2Exists_fix_27.dfy",
        "method_name": "Sqrt2Exists",
        "method_content": "  lemma Sqrt2Exists() returns (sqrt2: real)\n    ensures sqrt2 * sqrt2 == 2.0\n  {\n    var lower := iset x: real | x >= 0.0 && Square(x) < 2.0;\n    var upper := iset x: real | x >= 0.0 && Square(x) > 2.0;\n    forall x <- lower, y <- upper ensures x < y {\n      if x >= y {\n        calc {\n          2.0;\n        <\n          Square(y);\n        <= { RealArith.MulMonotonic(y, y, x); RealArith.MulMonotonic(x, y, x); }\n          Square(x);\n        <\n          2.0;\n        }\n      }\n    }\n    assert 1.0 in lower;\n    assert 2.0 in upper;\n    sqrt2 := Reals.DedekindCompleteness(lower, upper);\n    assert 1.0 <= sqrt2 <= 2.0;\n    assert Square(sqrt2) == 2.0 by {\n      if sqrt2 * sqrt2 > 2.0 {\n        var eps := (sqrt2 * sqrt2 - 2.0) / (2.0 * sqrt2);\n        assert 0.0 < eps < 1.0;\n        var y := sqrt2 - eps;\n        assert y * y > 2.0 by {\n          calc {\n            y * y;\n            sqrt2 * sqrt2 - 2.0 * sqrt2 * eps + eps * eps;\n            sqrt2 * sqrt2 - (sqrt2 * sqrt2 - 2.0) + eps * eps;\n            2.0 + eps * eps;\n          >\n            2.0;\n          }\n        }\n        assert y in upper by {\n          assert y >= 0.0;\n          assert y * y > 2.0;\n        }\n        assert false;\n      }\n      if sqrt2 * sqrt2 < 2.0 {\n        var eps := (2.0 - sqrt2 * sqrt2) / (2.0 * sqrt2 + 1.0);\n        assert 0.0 < eps < 1.0;\n        var y := sqrt2 + eps;\n        assert y * y < 2.0 by {\n          calc {\n            y * y;\n            sqrt2 * sqrt2 + 2.0 * sqrt2 * eps + eps * eps;\n            sqrt2 * sqrt2 + (2.0 * sqrt2 + eps) * eps;\n          < { RealArith.MulMonotonicStrict(eps, 2.0 * sqrt2 + eps, 2.0 * sqrt2 + 1.0); }\n            sqrt2 * sqrt2 + (2.0 * sqrt2 + 1.0) * eps;\n            sqrt2 * sqrt2 + (2.0 - sqrt2 * sqrt2);\n            2.0;\n          }\n        }\n        assert y in lower by {\n          assert y >= 0.0;\n          assert y * y < 2.0;\n        }\n        assert false;\n      }\n    }\n  }\n",
        "method_without_assertion_content": "  lemma Sqrt2Exists() returns (sqrt2: real)\n    ensures sqrt2 * sqrt2 == 2.0\n  {\n    var lower := iset x: real | x >= 0.0 && Square(x) < 2.0;\n    var upper := iset x: real | x >= 0.0 && Square(x) > 2.0;\n    forall x <- lower, y <- upper ensures x < y {\n      if x >= y {\n        calc {\n          2.0;\n        <\n          Square(y);\n        <= { RealArith.MulMonotonic(y, y, x); RealArith.MulMonotonic(x, y, x); }\n          Square(x);\n        <\n          2.0;\n        }\n      }\n    }\n        assert 2.0 in upper;\n    sqrt2 := Reals.DedekindCompleteness(lower, upper);\n    assert 1.0 <= sqrt2 <= 2.0;\n    assert Square(sqrt2) == 2.0 by {\n      if sqrt2 * sqrt2 > 2.0 {\n        var eps := (sqrt2 * sqrt2 - 2.0) / (2.0 * sqrt2);\n        assert 0.0 < eps < 1.0;\n        var y := sqrt2 - eps;\n        assert y * y > 2.0 by {\n          calc {\n            y * y;\n            sqrt2 * sqrt2 - 2.0 * sqrt2 * eps + eps * eps;\n            sqrt2 * sqrt2 - (sqrt2 * sqrt2 - 2.0) + eps * eps;\n            2.0 + eps * eps;\n          >\n            2.0;\n          }\n        }\n        assert y in upper by {\n          assert y >= 0.0;\n          assert y * y > 2.0;\n        }\n        assert false;\n      }\n      if sqrt2 * sqrt2 < 2.0 {\n        var eps := (2.0 - sqrt2 * sqrt2) / (2.0 * sqrt2 + 1.0);\n        assert 0.0 < eps < 1.0;\n        var y := sqrt2 + eps;\n        assert y * y < 2.0 by {\n          calc {\n            y * y;\n            sqrt2 * sqrt2 + 2.0 * sqrt2 * eps + eps * eps;\n            sqrt2 * sqrt2 + (2.0 * sqrt2 + eps) * eps;\n          < { RealArith.MulMonotonicStrict(eps, 2.0 * sqrt2 + eps, 2.0 * sqrt2 + 1.0); }\n            sqrt2 * sqrt2 + (2.0 * sqrt2 + 1.0) * eps;\n            sqrt2 * sqrt2 + (2.0 - sqrt2 * sqrt2);\n            2.0;\n          }\n        }\n        assert y in lower by {\n          assert y >= 0.0;\n          assert y * y < 2.0;\n        }\n        assert false;\n      }\n    }\n  }\n"
    },
    {
        "benchmark_name": "vmc",
        "index": "28",
        "method_filepath": "./src/Math/Analysis/Reals.dfy",
        "method_without_assertion_filename": "Sqrt2Exists_fix_28.dfy",
        "method_name": "Sqrt2Exists",
        "method_content": "  lemma Sqrt2Exists() returns (sqrt2: real)\n    ensures sqrt2 * sqrt2 == 2.0\n  {\n    var lower := iset x: real | x >= 0.0 && Square(x) < 2.0;\n    var upper := iset x: real | x >= 0.0 && Square(x) > 2.0;\n    forall x <- lower, y <- upper ensures x < y {\n      if x >= y {\n        calc {\n          2.0;\n        <\n          Square(y);\n        <= { RealArith.MulMonotonic(y, y, x); RealArith.MulMonotonic(x, y, x); }\n          Square(x);\n        <\n          2.0;\n        }\n      }\n    }\n    assert 1.0 in lower;\n    assert 2.0 in upper;\n    sqrt2 := Reals.DedekindCompleteness(lower, upper);\n    assert 1.0 <= sqrt2 <= 2.0;\n    assert Square(sqrt2) == 2.0 by {\n      if sqrt2 * sqrt2 > 2.0 {\n        var eps := (sqrt2 * sqrt2 - 2.0) / (2.0 * sqrt2);\n        assert 0.0 < eps < 1.0;\n        var y := sqrt2 - eps;\n        assert y * y > 2.0 by {\n          calc {\n            y * y;\n            sqrt2 * sqrt2 - 2.0 * sqrt2 * eps + eps * eps;\n            sqrt2 * sqrt2 - (sqrt2 * sqrt2 - 2.0) + eps * eps;\n            2.0 + eps * eps;\n          >\n            2.0;\n          }\n        }\n        assert y in upper by {\n          assert y >= 0.0;\n          assert y * y > 2.0;\n        }\n        assert false;\n      }\n      if sqrt2 * sqrt2 < 2.0 {\n        var eps := (2.0 - sqrt2 * sqrt2) / (2.0 * sqrt2 + 1.0);\n        assert 0.0 < eps < 1.0;\n        var y := sqrt2 + eps;\n        assert y * y < 2.0 by {\n          calc {\n            y * y;\n            sqrt2 * sqrt2 + 2.0 * sqrt2 * eps + eps * eps;\n            sqrt2 * sqrt2 + (2.0 * sqrt2 + eps) * eps;\n          < { RealArith.MulMonotonicStrict(eps, 2.0 * sqrt2 + eps, 2.0 * sqrt2 + 1.0); }\n            sqrt2 * sqrt2 + (2.0 * sqrt2 + 1.0) * eps;\n            sqrt2 * sqrt2 + (2.0 - sqrt2 * sqrt2);\n            2.0;\n          }\n        }\n        assert y in lower by {\n          assert y >= 0.0;\n          assert y * y < 2.0;\n        }\n        assert false;\n      }\n    }\n  }\n",
        "method_without_assertion_content": "  lemma Sqrt2Exists() returns (sqrt2: real)\n    ensures sqrt2 * sqrt2 == 2.0\n  {\n    var lower := iset x: real | x >= 0.0 && Square(x) < 2.0;\n    var upper := iset x: real | x >= 0.0 && Square(x) > 2.0;\n    forall x <- lower, y <- upper ensures x < y {\n      if x >= y {\n        calc {\n          2.0;\n        <\n          Square(y);\n        <= { RealArith.MulMonotonic(y, y, x); RealArith.MulMonotonic(x, y, x); }\n          Square(x);\n        <\n          2.0;\n        }\n      }\n    }\n    assert 1.0 in lower;\n        sqrt2 := Reals.DedekindCompleteness(lower, upper);\n    assert 1.0 <= sqrt2 <= 2.0;\n    assert Square(sqrt2) == 2.0 by {\n      if sqrt2 * sqrt2 > 2.0 {\n        var eps := (sqrt2 * sqrt2 - 2.0) / (2.0 * sqrt2);\n        assert 0.0 < eps < 1.0;\n        var y := sqrt2 - eps;\n        assert y * y > 2.0 by {\n          calc {\n            y * y;\n            sqrt2 * sqrt2 - 2.0 * sqrt2 * eps + eps * eps;\n            sqrt2 * sqrt2 - (sqrt2 * sqrt2 - 2.0) + eps * eps;\n            2.0 + eps * eps;\n          >\n            2.0;\n          }\n        }\n        assert y in upper by {\n          assert y >= 0.0;\n          assert y * y > 2.0;\n        }\n        assert false;\n      }\n      if sqrt2 * sqrt2 < 2.0 {\n        var eps := (2.0 - sqrt2 * sqrt2) / (2.0 * sqrt2 + 1.0);\n        assert 0.0 < eps < 1.0;\n        var y := sqrt2 + eps;\n        assert y * y < 2.0 by {\n          calc {\n            y * y;\n            sqrt2 * sqrt2 + 2.0 * sqrt2 * eps + eps * eps;\n            sqrt2 * sqrt2 + (2.0 * sqrt2 + eps) * eps;\n          < { RealArith.MulMonotonicStrict(eps, 2.0 * sqrt2 + eps, 2.0 * sqrt2 + 1.0); }\n            sqrt2 * sqrt2 + (2.0 * sqrt2 + 1.0) * eps;\n            sqrt2 * sqrt2 + (2.0 - sqrt2 * sqrt2);\n            2.0;\n          }\n        }\n        assert y in lower by {\n          assert y >= 0.0;\n          assert y * y < 2.0;\n        }\n        assert false;\n      }\n    }\n  }\n"
    },
    {
        "benchmark_name": "vmc",
        "index": "56",
        "method_filepath": "./src/Distributions/UniformPowerOfTwo/Correctness.dfy",
        "method_without_assertion_filename": "UnifCorrectness2Inequality_fix_56.dfy",
        "method_name": "UnifCorrectness2Inequality",
        "method_content": "  lemma UnifCorrectness2Inequality(n: nat, m: nat)\n    requires n >= 1\n    requires m <= Helper.Power(2, Helper.Log2Floor(n))\n    ensures\n      var e := iset s | Model.Sample(n)(s).value < m;\n      && e in Rand.eventSpace\n      && Rand.prob(e) == (m as real) / (Helper.Power(2, Helper.Log2Floor(n)) as real)\n  {\n    var e := iset s | Model.Sample(n)(s).value < m;\n\n    if m == 0 {\n      assert e == iset{};\n      Rand.ProbIsProbabilityMeasure();\n    } else {\n      var e1 := iset s | Model.Sample(n)(s).value < m-1;\n      var e2 := iset s | Model.Sample(n)(s).value == m-1;\n      assert e1 in Rand.eventSpace by {\n        UnifCorrectness2Inequality(n, m-1);\n      }\n      assert e2 in Rand.eventSpace by {\n        UnifCorrectness2(n, m-1);\n      }\n      assert e in Rand.eventSpace by {\n        assert e == e1 + e2;\n        Rand.ProbIsProbabilityMeasure();\n        Measures.BinaryUnion(Rand.eventSpace, e1, e2);\n      }\n      calc {\n        Rand.prob(e);\n        { assert e == e1 + e2; }\n        Rand.prob(e1 + e2);\n        { assert e1 * e2 == iset{}; Rand.ProbIsProbabilityMeasure(); Measures.PosCountAddImpliesAdd(Rand.eventSpace, Rand.prob); assert Measures.IsAdditive(Rand.eventSpace, Rand.prob); }\n        Rand.prob(e1) + Rand.prob(e2);\n        { UnifCorrectness2(n, m-1); UnifCorrectness2Inequality(n, m-1); }\n        (1.0 / (Helper.Power(2, Helper.Log2Floor(n)) as real)) + (((m-1) as real) / (Helper.Power(2, Helper.Log2Floor(n)) as real));\n        { Helper.AdditionOfFractions(1.0, (m-1) as real, Helper.Power(2, Helper.Log2Floor(n)) as real); }\n        (1.0 + (m-1) as real) / (Helper.Power(2, Helper.Log2Floor(n)) as real);\n        { assert 1.0 + (m-1) as real == (m as real); }\n        (m as real) / (Helper.Power(2, Helper.Log2Floor(n)) as real);\n      }\n    }\n  }\n",
        "method_without_assertion_content": "  lemma UnifCorrectness2Inequality(n: nat, m: nat)\n    requires n >= 1\n    requires m <= Helper.Power(2, Helper.Log2Floor(n))\n    ensures\n      var e := iset s | Model.Sample(n)(s).value < m;\n      && e in Rand.eventSpace\n      && Rand.prob(e) == (m as real) / (Helper.Power(2, Helper.Log2Floor(n)) as real)\n  {\n    var e := iset s | Model.Sample(n)(s).value < m;\n\n    if m == 0 {\n            Rand.ProbIsProbabilityMeasure();\n    } else {\n      var e1 := iset s | Model.Sample(n)(s).value < m-1;\n      var e2 := iset s | Model.Sample(n)(s).value == m-1;\n      assert e1 in Rand.eventSpace by {\n        UnifCorrectness2Inequality(n, m-1);\n      }\n      assert e2 in Rand.eventSpace by {\n        UnifCorrectness2(n, m-1);\n      }\n      assert e in Rand.eventSpace by {\n        assert e == e1 + e2;\n        Rand.ProbIsProbabilityMeasure();\n        Measures.BinaryUnion(Rand.eventSpace, e1, e2);\n      }\n      calc {\n        Rand.prob(e);\n        { assert e == e1 + e2; }\n        Rand.prob(e1 + e2);\n        { assert e1 * e2 == iset{}; Rand.ProbIsProbabilityMeasure(); Measures.PosCountAddImpliesAdd(Rand.eventSpace, Rand.prob); assert Measures.IsAdditive(Rand.eventSpace, Rand.prob); }\n        Rand.prob(e1) + Rand.prob(e2);\n        { UnifCorrectness2(n, m-1); UnifCorrectness2Inequality(n, m-1); }\n        (1.0 / (Helper.Power(2, Helper.Log2Floor(n)) as real)) + (((m-1) as real) / (Helper.Power(2, Helper.Log2Floor(n)) as real));\n        { Helper.AdditionOfFractions(1.0, (m-1) as real, Helper.Power(2, Helper.Log2Floor(n)) as real); }\n        (1.0 + (m-1) as real) / (Helper.Power(2, Helper.Log2Floor(n)) as real);\n        { assert 1.0 + (m-1) as real == (m as real); }\n        (m as real) / (Helper.Power(2, Helper.Log2Floor(n)) as real);\n      }\n    }\n  }\n"
    },
    {
        "benchmark_name": "vmc",
        "index": "57",
        "method_filepath": "./src/Distributions/UniformPowerOfTwo/Correctness.dfy",
        "method_without_assertion_filename": "UnifCorrectness2Inequality_fix_57.dfy",
        "method_name": "UnifCorrectness2Inequality",
        "method_content": "  lemma UnifCorrectness2Inequality(n: nat, m: nat)\n    requires n >= 1\n    requires m <= Helper.Power(2, Helper.Log2Floor(n))\n    ensures\n      var e := iset s | Model.Sample(n)(s).value < m;\n      && e in Rand.eventSpace\n      && Rand.prob(e) == (m as real) / (Helper.Power(2, Helper.Log2Floor(n)) as real)\n  {\n    var e := iset s | Model.Sample(n)(s).value < m;\n\n    if m == 0 {\n      assert e == iset{};\n      Rand.ProbIsProbabilityMeasure();\n    } else {\n      var e1 := iset s | Model.Sample(n)(s).value < m-1;\n      var e2 := iset s | Model.Sample(n)(s).value == m-1;\n      assert e1 in Rand.eventSpace by {\n        UnifCorrectness2Inequality(n, m-1);\n      }\n      assert e2 in Rand.eventSpace by {\n        UnifCorrectness2(n, m-1);\n      }\n      assert e in Rand.eventSpace by {\n        assert e == e1 + e2;\n        Rand.ProbIsProbabilityMeasure();\n        Measures.BinaryUnion(Rand.eventSpace, e1, e2);\n      }\n      calc {\n        Rand.prob(e);\n        { assert e == e1 + e2; }\n        Rand.prob(e1 + e2);\n        { assert e1 * e2 == iset{}; Rand.ProbIsProbabilityMeasure(); Measures.PosCountAddImpliesAdd(Rand.eventSpace, Rand.prob); assert Measures.IsAdditive(Rand.eventSpace, Rand.prob); }\n        Rand.prob(e1) + Rand.prob(e2);\n        { UnifCorrectness2(n, m-1); UnifCorrectness2Inequality(n, m-1); }\n        (1.0 / (Helper.Power(2, Helper.Log2Floor(n)) as real)) + (((m-1) as real) / (Helper.Power(2, Helper.Log2Floor(n)) as real));\n        { Helper.AdditionOfFractions(1.0, (m-1) as real, Helper.Power(2, Helper.Log2Floor(n)) as real); }\n        (1.0 + (m-1) as real) / (Helper.Power(2, Helper.Log2Floor(n)) as real);\n        { assert 1.0 + (m-1) as real == (m as real); }\n        (m as real) / (Helper.Power(2, Helper.Log2Floor(n)) as real);\n      }\n    }\n  }\n",
        "method_without_assertion_content": "  lemma UnifCorrectness2Inequality(n: nat, m: nat)\n    requires n >= 1\n    requires m <= Helper.Power(2, Helper.Log2Floor(n))\n    ensures\n      var e := iset s | Model.Sample(n)(s).value < m;\n      && e in Rand.eventSpace\n      && Rand.prob(e) == (m as real) / (Helper.Power(2, Helper.Log2Floor(n)) as real)\n  {\n    var e := iset s | Model.Sample(n)(s).value < m;\n\n    if m == 0 {\n      assert e == iset{};\n      Rand.ProbIsProbabilityMeasure();\n    } else {\n      var e1 := iset s | Model.Sample(n)(s).value < m-1;\n      var e2 := iset s | Model.Sample(n)(s).value == m-1;\n      assert e1 in Rand.eventSpace by {\n        UnifCorrectness2Inequality(n, m-1);\n      }\n      assert e2 in Rand.eventSpace by {\n        UnifCorrectness2(n, m-1);\n      }\n      assert e in Rand.eventSpace by {\n                Rand.ProbIsProbabilityMeasure();\n        Measures.BinaryUnion(Rand.eventSpace, e1, e2);\n      }\n      calc {\n        Rand.prob(e);\n        { assert e == e1 + e2; }\n        Rand.prob(e1 + e2);\n        { assert e1 * e2 == iset{}; Rand.ProbIsProbabilityMeasure(); Measures.PosCountAddImpliesAdd(Rand.eventSpace, Rand.prob); assert Measures.IsAdditive(Rand.eventSpace, Rand.prob); }\n        Rand.prob(e1) + Rand.prob(e2);\n        { UnifCorrectness2(n, m-1); UnifCorrectness2Inequality(n, m-1); }\n        (1.0 / (Helper.Power(2, Helper.Log2Floor(n)) as real)) + (((m-1) as real) / (Helper.Power(2, Helper.Log2Floor(n)) as real));\n        { Helper.AdditionOfFractions(1.0, (m-1) as real, Helper.Power(2, Helper.Log2Floor(n)) as real); }\n        (1.0 + (m-1) as real) / (Helper.Power(2, Helper.Log2Floor(n)) as real);\n        { assert 1.0 + (m-1) as real == (m as real); }\n        (m as real) / (Helper.Power(2, Helper.Log2Floor(n)) as real);\n      }\n    }\n  }\n"
    },
    {
        "benchmark_name": "vmc",
        "index": "58",
        "method_filepath": "./src/Distributions/UniformPowerOfTwo/Correctness.dfy",
        "method_without_assertion_filename": "UnifCorrectness_fix_58.dfy",
        "method_name": "UnifCorrectness",
        "method_content": "  lemma UnifCorrectness2(n: nat, m: nat)\n    requires n >= 1\n    ensures\n      var e := iset s | Model.Sample(n)(s).value == m;\n      && e in Rand.eventSpace\n      && Rand.prob(e) == if m < Helper.Power(2, Helper.Log2Floor(n)) then 1.0 / (Helper.Power(2, Helper.Log2Floor(n)) as real) else 0.0\n  {\n    var e := iset s | Model.Sample(n)(s).value == m;\n    var k := Helper.Log2Floor(n);\n\n    assert e in Rand.eventSpace by {\n      var resultsWithValueM := Monad.ResultsWithValueIn(iset{m});\n      assert resultsWithValueM in Monad.natResultEventSpace by {\n        Monad.LiftInEventSpaceToResultEventSpace(iset{m}, Measures.natEventSpace);\n      }\n      var preimage := Measures.PreImage(Model.Sample(n), resultsWithValueM);\n      assert Measures.IsMeasurable(Rand.eventSpace, Monad.natResultEventSpace, Model.Sample(n)) by {\n        SampleIsIndep(n);\n        Independence.IsIndepImpliesMeasurableNat(Model.Sample(n));\n      }\n      assert e == preimage;\n    }\n    Helper.Power2OfLog2Floor(n);\n    UnifCorrectness(n, k);\n    assert UnifIsCorrect(n, k, m);\n  }\n",
        "method_without_assertion_content": "  lemma UnifCorrectness2(n: nat, m: nat)\n    requires n >= 1\n    ensures\n      var e := iset s | Model.Sample(n)(s).value == m;\n      && e in Rand.eventSpace\n      && Rand.prob(e) == if m < Helper.Power(2, Helper.Log2Floor(n)) then 1.0 / (Helper.Power(2, Helper.Log2Floor(n)) as real) else 0.0\n  {\n    var e := iset s | Model.Sample(n)(s).value == m;\n    var k := Helper.Log2Floor(n);\n\n    assert e in Rand.eventSpace by {\n      var resultsWithValueM := Monad.ResultsWithValueIn(iset{m});\n      assert resultsWithValueM in Monad.natResultEventSpace by {\n        Monad.LiftInEventSpaceToResultEventSpace(iset{m}, Measures.natEventSpace);\n      }\n      var preimage := Measures.PreImage(Model.Sample(n), resultsWithValueM);\n      assert Measures.IsMeasurable(Rand.eventSpace, Monad.natResultEventSpace, Model.Sample(n)) by {\n        SampleIsIndep(n);\n        Independence.IsIndepImpliesMeasurableNat(Model.Sample(n));\n      }\n          }\n    Helper.Power2OfLog2Floor(n);\n    UnifCorrectness(n, k);\n    assert UnifIsCorrect(n, k, m);\n  }\n"
    },
    {
        "benchmark_name": "vmc",
        "index": "60",
        "method_filepath": "./src/Distributions/UniformPowerOfTwo/Correctness.dfy",
        "method_without_assertion_filename": "UnifCorrectness2_fix_60.dfy",
        "method_name": "UnifCorrectness2",
        "method_content": "  lemma UnifCorrectness2(n: nat, m: nat)\n    requires n >= 1\n    ensures\n      var e := iset s | Model.Sample(n)(s).value == m;\n      && e in Rand.eventSpace\n      && Rand.prob(e) == if m < Helper.Power(2, Helper.Log2Floor(n)) then 1.0 / (Helper.Power(2, Helper.Log2Floor(n)) as real) else 0.0\n  {\n    var e := iset s | Model.Sample(n)(s).value == m;\n    var k := Helper.Log2Floor(n);\n\n    assert e in Rand.eventSpace by {\n      var resultsWithValueM := Monad.ResultsWithValueIn(iset{m});\n      assert resultsWithValueM in Monad.natResultEventSpace by {\n        Monad.LiftInEventSpaceToResultEventSpace(iset{m}, Measures.natEventSpace);\n      }\n      var preimage := Measures.PreImage(Model.Sample(n), resultsWithValueM);\n      assert Measures.IsMeasurable(Rand.eventSpace, Monad.natResultEventSpace, Model.Sample(n)) by {\n        SampleIsIndep(n);\n        Independence.IsIndepImpliesMeasurableNat(Model.Sample(n));\n      }\n      assert e == preimage;\n    }\n    Helper.Power2OfLog2Floor(n);\n    UnifCorrectness(n, k);\n    assert UnifIsCorrect(n, k, m);\n  }\n",
        "method_without_assertion_content": "  lemma UnifCorrectness2(n: nat, m: nat)\n    requires n >= 1\n    ensures\n      var e := iset s | Model.Sample(n)(s).value == m;\n      && e in Rand.eventSpace\n      && Rand.prob(e) == if m < Helper.Power(2, Helper.Log2Floor(n)) then 1.0 / (Helper.Power(2, Helper.Log2Floor(n)) as real) else 0.0\n  {\n    var e := iset s | Model.Sample(n)(s).value == m;\n    var k := Helper.Log2Floor(n);\n\n    assert e in Rand.eventSpace by {\n      var resultsWithValueM := Monad.ResultsWithValueIn(iset{m});\n      assert resultsWithValueM in Monad.natResultEventSpace by {\n        Monad.LiftInEventSpaceToResultEventSpace(iset{m}, Measures.natEventSpace);\n      }\n      var preimage := Measures.PreImage(Model.Sample(n), resultsWithValueM);\n      assert Measures.IsMeasurable(Rand.eventSpace, Monad.natResultEventSpace, Model.Sample(n)) by {\n        SampleIsIndep(n);\n        Independence.IsIndepImpliesMeasurableNat(Model.Sample(n));\n      }\n          }\n    Helper.Power2OfLog2Floor(n);\n    UnifCorrectness(n, k);\n    assert UnifIsCorrect(n, k, m);\n  }\n"
    },
    {
        "benchmark_name": "vmc",
        "index": "61",
        "method_filepath": "./src/Distributions/UniformPowerOfTwo/Correctness.dfy",
        "method_without_assertion_filename": "UnifCorrectness2_fix_61.dfy",
        "method_name": "UnifCorrectness2",
        "method_content": "  lemma UnifCorrectness2(n: nat, m: nat)\n    requires n >= 1\n    ensures\n      var e := iset s | Model.Sample(n)(s).value == m;\n      && e in Rand.eventSpace\n      && Rand.prob(e) == if m < Helper.Power(2, Helper.Log2Floor(n)) then 1.0 / (Helper.Power(2, Helper.Log2Floor(n)) as real) else 0.0\n  {\n    var e := iset s | Model.Sample(n)(s).value == m;\n    var k := Helper.Log2Floor(n);\n\n    assert e in Rand.eventSpace by {\n      var resultsWithValueM := Monad.ResultsWithValueIn(iset{m});\n      assert resultsWithValueM in Monad.natResultEventSpace by {\n        Monad.LiftInEventSpaceToResultEventSpace(iset{m}, Measures.natEventSpace);\n      }\n      var preimage := Measures.PreImage(Model.Sample(n), resultsWithValueM);\n      assert Measures.IsMeasurable(Rand.eventSpace, Monad.natResultEventSpace, Model.Sample(n)) by {\n        SampleIsIndep(n);\n        Independence.IsIndepImpliesMeasurableNat(Model.Sample(n));\n      }\n      assert e == preimage;\n    }\n    Helper.Power2OfLog2Floor(n);\n    UnifCorrectness(n, k);\n    assert UnifIsCorrect(n, k, m);\n  }\n",
        "method_without_assertion_content": "  lemma UnifCorrectness2(n: nat, m: nat)\n    requires n >= 1\n    ensures\n      var e := iset s | Model.Sample(n)(s).value == m;\n      && e in Rand.eventSpace\n      && Rand.prob(e) == if m < Helper.Power(2, Helper.Log2Floor(n)) then 1.0 / (Helper.Power(2, Helper.Log2Floor(n)) as real) else 0.0\n  {\n    var e := iset s | Model.Sample(n)(s).value == m;\n    var k := Helper.Log2Floor(n);\n\n    assert e in Rand.eventSpace by {\n      var resultsWithValueM := Monad.ResultsWithValueIn(iset{m});\n      assert resultsWithValueM in Monad.natResultEventSpace by {\n        Monad.LiftInEventSpaceToResultEventSpace(iset{m}, Measures.natEventSpace);\n      }\n      var preimage := Measures.PreImage(Model.Sample(n), resultsWithValueM);\n      assert Measures.IsMeasurable(Rand.eventSpace, Monad.natResultEventSpace, Model.Sample(n)) by {\n        SampleIsIndep(n);\n        Independence.IsIndepImpliesMeasurableNat(Model.Sample(n));\n      }\n      assert e == preimage;\n    }\n    Helper.Power2OfLog2Floor(n);\n    UnifCorrectness(n, k);\n      }\n"
    },
    {
        "benchmark_name": "vmc",
        "index": "62",
        "method_filepath": "./src/Distributions/UniformPowerOfTwo/Correctness.dfy",
        "method_without_assertion_filename": "SampleIsMeasurePreserving_fix_62.dfy",
        "method_name": "SampleIsMeasurePreserving",
        "method_content": "  lemma SampleIsMeasurePreserving(n: nat)\n    requires n >= 1\n    ensures Measures.IsMeasurePreserving(Rand.eventSpace, Rand.prob, Rand.eventSpace, Rand.prob, SampleRest(n))\n  {\n    var f := SampleRest(n);\n    assert Measures.IsMeasurable(Rand.eventSpace, Rand.eventSpace, f) by {\n      forall e | e in Rand.eventSpace ensures Measures.PreImage(f, e) in Rand.eventSpace {\n        var resultsWithRestInE := Monad.ResultsWithRestIn(e);\n        assert resultsWithRestInE in Monad.natResultEventSpace by {\n          Monad.LiftRestInEventSpaceToResultEventSpace(e, Measures.natEventSpace);\n        }\n        var preimage' := Measures.PreImage(Model.Sample(n), resultsWithRestInE);\n        assert preimage' in Rand.eventSpace by {\n          SampleIsIndep(n);\n          Independence.IsIndepImpliesMeasurableNat(Model.Sample(n));\n        }\n        assert Measures.PreImage(f, e) == preimage';\n      }\n    }\n    if n == 1 {\n      forall e | e in Rand.eventSpace ensures Rand.prob(Measures.PreImage(f, e)) == Rand.prob(e) {\n        forall s: Rand.Bitstream ensures f(s) == s {\n          reveal Model.Sample();\n          assert f(s) == s;\n        }\n        Measures.PreImageIdentity(f, e);\n      }\n      assert Measures.IsMeasurePreserving(Rand.eventSpace, Rand.prob, Rand.eventSpace, Rand.prob, f);\n    } else {\n      var g := SampleRest(n / 2);\n      forall e | e in Rand.eventSpace ensures Rand.prob(Measures.PreImage(f, e)) == Rand.prob(e) {\n        var e' := (iset s | Rand.Tail(s) in e);\n        assert e' in Rand.eventSpace by {\n          assert e' == Measures.PreImage(Rand.Tail, e);\n          Rand.TailIsMeasurePreserving();\n          assert Measures.IsMeasurable(Rand.eventSpace, Rand.eventSpace, Rand.Tail);\n        }\n        assert Measures.PreImage(f, e) == Measures.PreImage(g, e') by {\n          assert forall s :: f(s) in e <==> g(s) in e' by {\n            forall s ensures f(s) in e <==> g(s) in e' {\n              calc {\n                f(s) in e;\n              <==> { assert f(s) == Model.Sample(n)(s).rest; }\n                Model.Sample(n)(s).rest in e;\n              <==> { SampleTailDecompose(n, s); }\n                Rand.Tail(Model.Sample(n / 2)(s).rest) in e;\n              <==>\n                Model.Sample(n / 2)(s).rest in e';\n              <==> { assert Model.Sample(n / 2)(s).rest == g(s); }\n                g(s) in e';\n              }\n            }\n          }\n          Measures.PreImagesEqual(f, e, g, e');\n        }\n        assert Rand.prob(Measures.PreImage(f, e)) == Rand.prob(e) by {\n          calc {\n            Rand.prob(Measures.PreImage(f, e));\n          ==\n            Rand.prob(Measures.PreImage(g, e'));\n          == { SampleIsMeasurePreserving(n / 2); assert Measures.IsMeasurePreserving(Rand.eventSpace, Rand.prob, Rand.eventSpace, Rand.prob, g); assert e' in Rand.eventSpace; }\n            Rand.prob(e');\n          == { assert e' == Measures.PreImage(Rand.Tail, e); }\n            Rand.prob(Measures.PreImage(Rand.Tail, e));\n          == { Rand.TailIsMeasurePreserving(); }\n            Rand.prob(e);\n          }\n        }\n      }\n      assert Measures.IsMeasurePreserving(Rand.eventSpace, Rand.prob, Rand.eventSpace, Rand.prob, f);\n    }\n  }\n",
        "method_without_assertion_content": "  lemma SampleIsMeasurePreserving(n: nat)\n    requires n >= 1\n    ensures Measures.IsMeasurePreserving(Rand.eventSpace, Rand.prob, Rand.eventSpace, Rand.prob, SampleRest(n))\n  {\n    var f := SampleRest(n);\n    assert Measures.IsMeasurable(Rand.eventSpace, Rand.eventSpace, f) by {\n      forall e | e in Rand.eventSpace ensures Measures.PreImage(f, e) in Rand.eventSpace {\n        var resultsWithRestInE := Monad.ResultsWithRestIn(e);\n        assert resultsWithRestInE in Monad.natResultEventSpace by {\n          Monad.LiftRestInEventSpaceToResultEventSpace(e, Measures.natEventSpace);\n        }\n        var preimage' := Measures.PreImage(Model.Sample(n), resultsWithRestInE);\n        assert preimage' in Rand.eventSpace by {\n          SampleIsIndep(n);\n          Independence.IsIndepImpliesMeasurableNat(Model.Sample(n));\n        }\n              }\n    }\n    if n == 1 {\n      forall e | e in Rand.eventSpace ensures Rand.prob(Measures.PreImage(f, e)) == Rand.prob(e) {\n        forall s: Rand.Bitstream ensures f(s) == s {\n          reveal Model.Sample();\n          assert f(s) == s;\n        }\n        Measures.PreImageIdentity(f, e);\n      }\n      assert Measures.IsMeasurePreserving(Rand.eventSpace, Rand.prob, Rand.eventSpace, Rand.prob, f);\n    } else {\n      var g := SampleRest(n / 2);\n      forall e | e in Rand.eventSpace ensures Rand.prob(Measures.PreImage(f, e)) == Rand.prob(e) {\n        var e' := (iset s | Rand.Tail(s) in e);\n        assert e' in Rand.eventSpace by {\n          assert e' == Measures.PreImage(Rand.Tail, e);\n          Rand.TailIsMeasurePreserving();\n          assert Measures.IsMeasurable(Rand.eventSpace, Rand.eventSpace, Rand.Tail);\n        }\n        assert Measures.PreImage(f, e) == Measures.PreImage(g, e') by {\n          assert forall s :: f(s) in e <==> g(s) in e' by {\n            forall s ensures f(s) in e <==> g(s) in e' {\n              calc {\n                f(s) in e;\n              <==> { assert f(s) == Model.Sample(n)(s).rest; }\n                Model.Sample(n)(s).rest in e;\n              <==> { SampleTailDecompose(n, s); }\n                Rand.Tail(Model.Sample(n / 2)(s).rest) in e;\n              <==>\n                Model.Sample(n / 2)(s).rest in e';\n              <==> { assert Model.Sample(n / 2)(s).rest == g(s); }\n                g(s) in e';\n              }\n            }\n          }\n          Measures.PreImagesEqual(f, e, g, e');\n        }\n        assert Rand.prob(Measures.PreImage(f, e)) == Rand.prob(e) by {\n          calc {\n            Rand.prob(Measures.PreImage(f, e));\n          ==\n            Rand.prob(Measures.PreImage(g, e'));\n          == { SampleIsMeasurePreserving(n / 2); assert Measures.IsMeasurePreserving(Rand.eventSpace, Rand.prob, Rand.eventSpace, Rand.prob, g); assert e' in Rand.eventSpace; }\n            Rand.prob(e');\n          == { assert e' == Measures.PreImage(Rand.Tail, e); }\n            Rand.prob(Measures.PreImage(Rand.Tail, e));\n          == { Rand.TailIsMeasurePreserving(); }\n            Rand.prob(e);\n          }\n        }\n      }\n      assert Measures.IsMeasurePreserving(Rand.eventSpace, Rand.prob, Rand.eventSpace, Rand.prob, f);\n    }\n  }\n"
    },
    {
        "benchmark_name": "vmc",
        "index": "65",
        "method_filepath": "./src/Distributions/UniformPowerOfTwo/Correctness.dfy",
        "method_without_assertion_filename": "SampleIsMeasurePreserving_fix_65.dfy",
        "method_name": "SampleIsMeasurePreserving",
        "method_content": "  lemma SampleIsMeasurePreserving(n: nat)\n    requires n >= 1\n    ensures Measures.IsMeasurePreserving(Rand.eventSpace, Rand.prob, Rand.eventSpace, Rand.prob, SampleRest(n))\n  {\n    var f := SampleRest(n);\n    assert Measures.IsMeasurable(Rand.eventSpace, Rand.eventSpace, f) by {\n      forall e | e in Rand.eventSpace ensures Measures.PreImage(f, e) in Rand.eventSpace {\n        var resultsWithRestInE := Monad.ResultsWithRestIn(e);\n        assert resultsWithRestInE in Monad.natResultEventSpace by {\n          Monad.LiftRestInEventSpaceToResultEventSpace(e, Measures.natEventSpace);\n        }\n        var preimage' := Measures.PreImage(Model.Sample(n), resultsWithRestInE);\n        assert preimage' in Rand.eventSpace by {\n          SampleIsIndep(n);\n          Independence.IsIndepImpliesMeasurableNat(Model.Sample(n));\n        }\n        assert Measures.PreImage(f, e) == preimage';\n      }\n    }\n    if n == 1 {\n      forall e | e in Rand.eventSpace ensures Rand.prob(Measures.PreImage(f, e)) == Rand.prob(e) {\n        forall s: Rand.Bitstream ensures f(s) == s {\n          reveal Model.Sample();\n          assert f(s) == s;\n        }\n        Measures.PreImageIdentity(f, e);\n      }\n      assert Measures.IsMeasurePreserving(Rand.eventSpace, Rand.prob, Rand.eventSpace, Rand.prob, f);\n    } else {\n      var g := SampleRest(n / 2);\n      forall e | e in Rand.eventSpace ensures Rand.prob(Measures.PreImage(f, e)) == Rand.prob(e) {\n        var e' := (iset s | Rand.Tail(s) in e);\n        assert e' in Rand.eventSpace by {\n          assert e' == Measures.PreImage(Rand.Tail, e);\n          Rand.TailIsMeasurePreserving();\n          assert Measures.IsMeasurable(Rand.eventSpace, Rand.eventSpace, Rand.Tail);\n        }\n        assert Measures.PreImage(f, e) == Measures.PreImage(g, e') by {\n          assert forall s :: f(s) in e <==> g(s) in e' by {\n            forall s ensures f(s) in e <==> g(s) in e' {\n              calc {\n                f(s) in e;\n              <==> { assert f(s) == Model.Sample(n)(s).rest; }\n                Model.Sample(n)(s).rest in e;\n              <==> { SampleTailDecompose(n, s); }\n                Rand.Tail(Model.Sample(n / 2)(s).rest) in e;\n              <==>\n                Model.Sample(n / 2)(s).rest in e';\n              <==> { assert Model.Sample(n / 2)(s).rest == g(s); }\n                g(s) in e';\n              }\n            }\n          }\n          Measures.PreImagesEqual(f, e, g, e');\n        }\n        assert Rand.prob(Measures.PreImage(f, e)) == Rand.prob(e) by {\n          calc {\n            Rand.prob(Measures.PreImage(f, e));\n          ==\n            Rand.prob(Measures.PreImage(g, e'));\n          == { SampleIsMeasurePreserving(n / 2); assert Measures.IsMeasurePreserving(Rand.eventSpace, Rand.prob, Rand.eventSpace, Rand.prob, g); assert e' in Rand.eventSpace; }\n            Rand.prob(e');\n          == { assert e' == Measures.PreImage(Rand.Tail, e); }\n            Rand.prob(Measures.PreImage(Rand.Tail, e));\n          == { Rand.TailIsMeasurePreserving(); }\n            Rand.prob(e);\n          }\n        }\n      }\n      assert Measures.IsMeasurePreserving(Rand.eventSpace, Rand.prob, Rand.eventSpace, Rand.prob, f);\n    }\n  }\n",
        "method_without_assertion_content": "  lemma SampleIsMeasurePreserving(n: nat)\n    requires n >= 1\n    ensures Measures.IsMeasurePreserving(Rand.eventSpace, Rand.prob, Rand.eventSpace, Rand.prob, SampleRest(n))\n  {\n    var f := SampleRest(n);\n    assert Measures.IsMeasurable(Rand.eventSpace, Rand.eventSpace, f) by {\n      forall e | e in Rand.eventSpace ensures Measures.PreImage(f, e) in Rand.eventSpace {\n        var resultsWithRestInE := Monad.ResultsWithRestIn(e);\n        assert resultsWithRestInE in Monad.natResultEventSpace by {\n          Monad.LiftRestInEventSpaceToResultEventSpace(e, Measures.natEventSpace);\n        }\n        var preimage' := Measures.PreImage(Model.Sample(n), resultsWithRestInE);\n        assert preimage' in Rand.eventSpace by {\n          SampleIsIndep(n);\n          Independence.IsIndepImpliesMeasurableNat(Model.Sample(n));\n        }\n        assert Measures.PreImage(f, e) == preimage';\n      }\n    }\n    if n == 1 {\n      forall e | e in Rand.eventSpace ensures Rand.prob(Measures.PreImage(f, e)) == Rand.prob(e) {\n        forall s: Rand.Bitstream ensures f(s) == s {\n          reveal Model.Sample();\n          assert f(s) == s;\n        }\n        Measures.PreImageIdentity(f, e);\n      }\n      assert Measures.IsMeasurePreserving(Rand.eventSpace, Rand.prob, Rand.eventSpace, Rand.prob, f);\n    } else {\n      var g := SampleRest(n / 2);\n      forall e | e in Rand.eventSpace ensures Rand.prob(Measures.PreImage(f, e)) == Rand.prob(e) {\n        var e' := (iset s | Rand.Tail(s) in e);\n        assert e' in Rand.eventSpace by {\n                    Rand.TailIsMeasurePreserving();\n          assert Measures.IsMeasurable(Rand.eventSpace, Rand.eventSpace, Rand.Tail);\n        }\n        assert Measures.PreImage(f, e) == Measures.PreImage(g, e') by {\n          assert forall s :: f(s) in e <==> g(s) in e' by {\n            forall s ensures f(s) in e <==> g(s) in e' {\n              calc {\n                f(s) in e;\n              <==> { assert f(s) == Model.Sample(n)(s).rest; }\n                Model.Sample(n)(s).rest in e;\n              <==> { SampleTailDecompose(n, s); }\n                Rand.Tail(Model.Sample(n / 2)(s).rest) in e;\n              <==>\n                Model.Sample(n / 2)(s).rest in e';\n              <==> { assert Model.Sample(n / 2)(s).rest == g(s); }\n                g(s) in e';\n              }\n            }\n          }\n          Measures.PreImagesEqual(f, e, g, e');\n        }\n        assert Rand.prob(Measures.PreImage(f, e)) == Rand.prob(e) by {\n          calc {\n            Rand.prob(Measures.PreImage(f, e));\n          ==\n            Rand.prob(Measures.PreImage(g, e'));\n          == { SampleIsMeasurePreserving(n / 2); assert Measures.IsMeasurePreserving(Rand.eventSpace, Rand.prob, Rand.eventSpace, Rand.prob, g); assert e' in Rand.eventSpace; }\n            Rand.prob(e');\n          == { assert e' == Measures.PreImage(Rand.Tail, e); }\n            Rand.prob(Measures.PreImage(Rand.Tail, e));\n          == { Rand.TailIsMeasurePreserving(); }\n            Rand.prob(e);\n          }\n        }\n      }\n      assert Measures.IsMeasurePreserving(Rand.eventSpace, Rand.prob, Rand.eventSpace, Rand.prob, f);\n    }\n  }\n"
    },
    {
        "benchmark_name": "vmc",
        "index": "70",
        "method_filepath": "./src/Distributions/UniformPowerOfTwo/Correctness.dfy",
        "method_without_assertion_filename": "SampleRecursiveHalf_fix_70.dfy",
        "method_name": "SampleRecursiveHalf",
        "method_content": "  lemma SampleRecursiveHalf(n: nat, m: nat)\n    requires n >= 2\n    ensures Rand.prob(iset s | Model.Sample(n)(s).value == m) == Rand.prob(iset s | Model.Sample(n / 2)(s).value == m / 2) / 2.0\n  {\n    var aOf: Rand.Bitstream -> nat := (s: Rand.Bitstream) => Model.Sample(n / 2)(s).value;\n    var bOf: Rand.Bitstream -> bool := (s: Rand.Bitstream) => Monad.Coin(Model.Sample(n / 2)(s).rest).value;\n    var A: iset<nat> := (iset x: nat | x == m / 2);\n    var E: iset<Rand.Bitstream> := (iset s | m % 2 as nat == Helper.boolToNat(Monad.Coin(s).value));\n    var f := (s: Rand.Bitstream) => Model.Sample(n / 2)(s).rest;\n\n    var e1 := (iset s | Model.Sample(n / 2)(s).RestIn(E));\n    var e2 := (iset s | Model.Sample(n / 2)(s).In(A));\n    var e3 := (iset s | 2*aOf(s) + Helper.boolToNat(bOf(s)) == m);\n\n    assert SplitEvent: e3 == e1 * e2 by {\n      forall s ensures s in e3 <==> s in e1 && s in e2 {\n        var a: nat := aOf(s);\n        var b: nat := Helper.boolToNat(bOf(s));\n        assert b < 2;\n        calc {\n          s in e3;\n          2 * a + b == m;\n          m == a * 2 + b;\n          (a == m / 2) && (b == m % 2);\n          s in e1 && s in e2;\n        }\n      }\n    }\n\n    assert Eq2: (iset s | aOf(s) == m / 2) == e2 by {\n      forall s ensures aOf(s) == m / 2 <==> Model.Sample(n / 2)(s).value in A {\n      }\n    }\n\n    assert Eq3: (iset s | aOf(s) == m / 2) == (iset s | Model.Sample(n / 2)(s).value == m / 2) by {\n      forall s ensures aOf(s) == m / 2 <==> Model.Sample(n / 2)(s).value == m / 2 {\n        assert aOf(s) == Model.Sample(n / 2)(s).value;\n      }\n    }\n\n    assert Eq4: e1 == Measures.PreImage(f, E) by {\n      forall s ensures Model.Sample(n / 2)(s).rest in E <==> f(s) in E {\n      }\n    }\n\n    assert E in Rand.eventSpace && Rand.prob(E) == 0.5 by {\n      assert E == (iset s | Rand.Head(s) == (m % 2 == 1));\n      Rand.CoinHasProbOneHalf(m % 2 == 1);\n    }\n\n    assert Indep: Rand.prob(e1 * e2) == Rand.prob(e1) * Rand.prob(e2) by {\n      assert Measures.AreIndepEvents(Rand.eventSpace, Rand.prob, e1, e2) by {\n        assert Independence.IsIndepFunction(Model.Sample(n / 2)) by {\n          assert Independence.IsIndep(Model.Sample(n / 2)) by {\n            SampleIsIndep(n / 2);\n          }\n          Independence.IsIndepImpliesIsIndepFunction(Model.Sample(n / 2));\n        }\n        assert E in Rand.eventSpace;\n        assert Independence.IsIndepFunctionCondition(Model.Sample(n / 2), A, E);\n      }\n      Independence.AreIndepEventsConjunctElimination(e1, e2);\n    }\n\n    assert ProbE1: Rand.prob(e1) == 0.5 by {\n      calc {\n        0.5;\n      ==\n        Rand.prob(E);\n      == { SampleIsMeasurePreserving(n / 2); }\n        Rand.prob(Measures.PreImage(f, E));\n      == { reveal Eq4; }\n        Rand.prob(e1);\n      }\n    }\n\n    calc {\n      Rand.prob(iset s | Model.Sample(n)(s).value == m);\n    == { SampleSetEquality(n, m); }\n      Rand.prob(e3);\n    == { reveal SplitEvent; }\n      Rand.prob(e1 * e2);\n    == { reveal Indep; }\n      Rand.prob(e1) * Rand.prob(e2);\n    == { reveal ProbE1; Helper.Congruence(Rand.prob(e1), 0.5, x => x * Rand.prob(e2)); }\n      0.5 * Rand.prob(e2);\n    ==\n      Rand.prob(e2) / 2.0;\n    == { reveal Eq2; }\n      Rand.prob(iset s | aOf(s) == m / 2) / 2.0;\n    == { reveal Eq3; }\n      Rand.prob(iset s | Model.Sample(n / 2)(s).value == m / 2) / 2.0;\n    }\n  }\n",
        "method_without_assertion_content": "  lemma SampleRecursiveHalf(n: nat, m: nat)\n    requires n >= 2\n    ensures Rand.prob(iset s | Model.Sample(n)(s).value == m) == Rand.prob(iset s | Model.Sample(n / 2)(s).value == m / 2) / 2.0\n  {\n    var aOf: Rand.Bitstream -> nat := (s: Rand.Bitstream) => Model.Sample(n / 2)(s).value;\n    var bOf: Rand.Bitstream -> bool := (s: Rand.Bitstream) => Monad.Coin(Model.Sample(n / 2)(s).rest).value;\n    var A: iset<nat> := (iset x: nat | x == m / 2);\n    var E: iset<Rand.Bitstream> := (iset s | m % 2 as nat == Helper.boolToNat(Monad.Coin(s).value));\n    var f := (s: Rand.Bitstream) => Model.Sample(n / 2)(s).rest;\n\n    var e1 := (iset s | Model.Sample(n / 2)(s).RestIn(E));\n    var e2 := (iset s | Model.Sample(n / 2)(s).In(A));\n    var e3 := (iset s | 2*aOf(s) + Helper.boolToNat(bOf(s)) == m);\n\n    assert SplitEvent: e3 == e1 * e2 by {\n      forall s ensures s in e3 <==> s in e1 && s in e2 {\n        var a: nat := aOf(s);\n        var b: nat := Helper.boolToNat(bOf(s));\n        assert b < 2;\n        calc {\n          s in e3;\n          2 * a + b == m;\n          m == a * 2 + b;\n          (a == m / 2) && (b == m % 2);\n          s in e1 && s in e2;\n        }\n      }\n    }\n\n    assert Eq2: (iset s | aOf(s) == m / 2) == e2 by {\n      forall s ensures aOf(s) == m / 2 <==> Model.Sample(n / 2)(s).value in A {\n      }\n    }\n\n    assert Eq3: (iset s | aOf(s) == m / 2) == (iset s | Model.Sample(n / 2)(s).value == m / 2) by {\n      forall s ensures aOf(s) == m / 2 <==> Model.Sample(n / 2)(s).value == m / 2 {\n        assert aOf(s) == Model.Sample(n / 2)(s).value;\n      }\n    }\n\n    assert Eq4: e1 == Measures.PreImage(f, E) by {\n      forall s ensures Model.Sample(n / 2)(s).rest in E <==> f(s) in E {\n      }\n    }\n\n    assert E in Rand.eventSpace && Rand.prob(E) == 0.5 by {\n            Rand.CoinHasProbOneHalf(m % 2 == 1);\n    }\n\n    assert Indep: Rand.prob(e1 * e2) == Rand.prob(e1) * Rand.prob(e2) by {\n      assert Measures.AreIndepEvents(Rand.eventSpace, Rand.prob, e1, e2) by {\n        assert Independence.IsIndepFunction(Model.Sample(n / 2)) by {\n          assert Independence.IsIndep(Model.Sample(n / 2)) by {\n            SampleIsIndep(n / 2);\n          }\n          Independence.IsIndepImpliesIsIndepFunction(Model.Sample(n / 2));\n        }\n        assert E in Rand.eventSpace;\n        assert Independence.IsIndepFunctionCondition(Model.Sample(n / 2), A, E);\n      }\n      Independence.AreIndepEventsConjunctElimination(e1, e2);\n    }\n\n    assert ProbE1: Rand.prob(e1) == 0.5 by {\n      calc {\n        0.5;\n      ==\n        Rand.prob(E);\n      == { SampleIsMeasurePreserving(n / 2); }\n        Rand.prob(Measures.PreImage(f, E));\n      == { reveal Eq4; }\n        Rand.prob(e1);\n      }\n    }\n\n    calc {\n      Rand.prob(iset s | Model.Sample(n)(s).value == m);\n    == { SampleSetEquality(n, m); }\n      Rand.prob(e3);\n    == { reveal SplitEvent; }\n      Rand.prob(e1 * e2);\n    == { reveal Indep; }\n      Rand.prob(e1) * Rand.prob(e2);\n    == { reveal ProbE1; Helper.Congruence(Rand.prob(e1), 0.5, x => x * Rand.prob(e2)); }\n      0.5 * Rand.prob(e2);\n    ==\n      Rand.prob(e2) / 2.0;\n    == { reveal Eq2; }\n      Rand.prob(iset s | aOf(s) == m / 2) / 2.0;\n    == { reveal Eq3; }\n      Rand.prob(iset s | Model.Sample(n / 2)(s).value == m / 2) / 2.0;\n    }\n  }\n"
    },
    {
        "benchmark_name": "vmc",
        "index": "72",
        "method_filepath": "./src/Distributions/UniformPowerOfTwo/Correctness.dfy",
        "method_without_assertion_filename": "SampleRecursiveHalf_fix_72.dfy",
        "method_name": "SampleRecursiveHalf",
        "method_content": "  lemma SampleRecursiveHalf(n: nat, m: nat)\n    requires n >= 2\n    ensures Rand.prob(iset s | Model.Sample(n)(s).value == m) == Rand.prob(iset s | Model.Sample(n / 2)(s).value == m / 2) / 2.0\n  {\n    var aOf: Rand.Bitstream -> nat := (s: Rand.Bitstream) => Model.Sample(n / 2)(s).value;\n    var bOf: Rand.Bitstream -> bool := (s: Rand.Bitstream) => Monad.Coin(Model.Sample(n / 2)(s).rest).value;\n    var A: iset<nat> := (iset x: nat | x == m / 2);\n    var E: iset<Rand.Bitstream> := (iset s | m % 2 as nat == Helper.boolToNat(Monad.Coin(s).value));\n    var f := (s: Rand.Bitstream) => Model.Sample(n / 2)(s).rest;\n\n    var e1 := (iset s | Model.Sample(n / 2)(s).RestIn(E));\n    var e2 := (iset s | Model.Sample(n / 2)(s).In(A));\n    var e3 := (iset s | 2*aOf(s) + Helper.boolToNat(bOf(s)) == m);\n\n    assert SplitEvent: e3 == e1 * e2 by {\n      forall s ensures s in e3 <==> s in e1 && s in e2 {\n        var a: nat := aOf(s);\n        var b: nat := Helper.boolToNat(bOf(s));\n        assert b < 2;\n        calc {\n          s in e3;\n          2 * a + b == m;\n          m == a * 2 + b;\n          (a == m / 2) && (b == m % 2);\n          s in e1 && s in e2;\n        }\n      }\n    }\n\n    assert Eq2: (iset s | aOf(s) == m / 2) == e2 by {\n      forall s ensures aOf(s) == m / 2 <==> Model.Sample(n / 2)(s).value in A {\n      }\n    }\n\n    assert Eq3: (iset s | aOf(s) == m / 2) == (iset s | Model.Sample(n / 2)(s).value == m / 2) by {\n      forall s ensures aOf(s) == m / 2 <==> Model.Sample(n / 2)(s).value == m / 2 {\n        assert aOf(s) == Model.Sample(n / 2)(s).value;\n      }\n    }\n\n    assert Eq4: e1 == Measures.PreImage(f, E) by {\n      forall s ensures Model.Sample(n / 2)(s).rest in E <==> f(s) in E {\n      }\n    }\n\n    assert E in Rand.eventSpace && Rand.prob(E) == 0.5 by {\n      assert E == (iset s | Rand.Head(s) == (m % 2 == 1));\n      Rand.CoinHasProbOneHalf(m % 2 == 1);\n    }\n\n    assert Indep: Rand.prob(e1 * e2) == Rand.prob(e1) * Rand.prob(e2) by {\n      assert Measures.AreIndepEvents(Rand.eventSpace, Rand.prob, e1, e2) by {\n        assert Independence.IsIndepFunction(Model.Sample(n / 2)) by {\n          assert Independence.IsIndep(Model.Sample(n / 2)) by {\n            SampleIsIndep(n / 2);\n          }\n          Independence.IsIndepImpliesIsIndepFunction(Model.Sample(n / 2));\n        }\n        assert E in Rand.eventSpace;\n        assert Independence.IsIndepFunctionCondition(Model.Sample(n / 2), A, E);\n      }\n      Independence.AreIndepEventsConjunctElimination(e1, e2);\n    }\n\n    assert ProbE1: Rand.prob(e1) == 0.5 by {\n      calc {\n        0.5;\n      ==\n        Rand.prob(E);\n      == { SampleIsMeasurePreserving(n / 2); }\n        Rand.prob(Measures.PreImage(f, E));\n      == { reveal Eq4; }\n        Rand.prob(e1);\n      }\n    }\n\n    calc {\n      Rand.prob(iset s | Model.Sample(n)(s).value == m);\n    == { SampleSetEquality(n, m); }\n      Rand.prob(e3);\n    == { reveal SplitEvent; }\n      Rand.prob(e1 * e2);\n    == { reveal Indep; }\n      Rand.prob(e1) * Rand.prob(e2);\n    == { reveal ProbE1; Helper.Congruence(Rand.prob(e1), 0.5, x => x * Rand.prob(e2)); }\n      0.5 * Rand.prob(e2);\n    ==\n      Rand.prob(e2) / 2.0;\n    == { reveal Eq2; }\n      Rand.prob(iset s | aOf(s) == m / 2) / 2.0;\n    == { reveal Eq3; }\n      Rand.prob(iset s | Model.Sample(n / 2)(s).value == m / 2) / 2.0;\n    }\n  }\n",
        "method_without_assertion_content": "  lemma SampleRecursiveHalf(n: nat, m: nat)\n    requires n >= 2\n    ensures Rand.prob(iset s | Model.Sample(n)(s).value == m) == Rand.prob(iset s | Model.Sample(n / 2)(s).value == m / 2) / 2.0\n  {\n    var aOf: Rand.Bitstream -> nat := (s: Rand.Bitstream) => Model.Sample(n / 2)(s).value;\n    var bOf: Rand.Bitstream -> bool := (s: Rand.Bitstream) => Monad.Coin(Model.Sample(n / 2)(s).rest).value;\n    var A: iset<nat> := (iset x: nat | x == m / 2);\n    var E: iset<Rand.Bitstream> := (iset s | m % 2 as nat == Helper.boolToNat(Monad.Coin(s).value));\n    var f := (s: Rand.Bitstream) => Model.Sample(n / 2)(s).rest;\n\n    var e1 := (iset s | Model.Sample(n / 2)(s).RestIn(E));\n    var e2 := (iset s | Model.Sample(n / 2)(s).In(A));\n    var e3 := (iset s | 2*aOf(s) + Helper.boolToNat(bOf(s)) == m);\n\n    assert SplitEvent: e3 == e1 * e2 by {\n      forall s ensures s in e3 <==> s in e1 && s in e2 {\n        var a: nat := aOf(s);\n        var b: nat := Helper.boolToNat(bOf(s));\n        assert b < 2;\n        calc {\n          s in e3;\n          2 * a + b == m;\n          m == a * 2 + b;\n          (a == m / 2) && (b == m % 2);\n          s in e1 && s in e2;\n        }\n      }\n    }\n\n    assert Eq2: (iset s | aOf(s) == m / 2) == e2 by {\n      forall s ensures aOf(s) == m / 2 <==> Model.Sample(n / 2)(s).value in A {\n      }\n    }\n\n    assert Eq3: (iset s | aOf(s) == m / 2) == (iset s | Model.Sample(n / 2)(s).value == m / 2) by {\n      forall s ensures aOf(s) == m / 2 <==> Model.Sample(n / 2)(s).value == m / 2 {\n        assert aOf(s) == Model.Sample(n / 2)(s).value;\n      }\n    }\n\n    assert Eq4: e1 == Measures.PreImage(f, E) by {\n      forall s ensures Model.Sample(n / 2)(s).rest in E <==> f(s) in E {\n      }\n    }\n\n    assert E in Rand.eventSpace && Rand.prob(E) == 0.5 by {\n      assert E == (iset s | Rand.Head(s) == (m % 2 == 1));\n      Rand.CoinHasProbOneHalf(m % 2 == 1);\n    }\n\n    assert Indep: Rand.prob(e1 * e2) == Rand.prob(e1) * Rand.prob(e2) by {\n      assert Measures.AreIndepEvents(Rand.eventSpace, Rand.prob, e1, e2) by {\n        assert Independence.IsIndepFunction(Model.Sample(n / 2)) by {\n          assert Independence.IsIndep(Model.Sample(n / 2)) by {\n            SampleIsIndep(n / 2);\n          }\n          Independence.IsIndepImpliesIsIndepFunction(Model.Sample(n / 2));\n        }\n        assert E in Rand.eventSpace;\n              }\n      Independence.AreIndepEventsConjunctElimination(e1, e2);\n    }\n\n    assert ProbE1: Rand.prob(e1) == 0.5 by {\n      calc {\n        0.5;\n      ==\n        Rand.prob(E);\n      == { SampleIsMeasurePreserving(n / 2); }\n        Rand.prob(Measures.PreImage(f, E));\n      == { reveal Eq4; }\n        Rand.prob(e1);\n      }\n    }\n\n    calc {\n      Rand.prob(iset s | Model.Sample(n)(s).value == m);\n    == { SampleSetEquality(n, m); }\n      Rand.prob(e3);\n    == { reveal SplitEvent; }\n      Rand.prob(e1 * e2);\n    == { reveal Indep; }\n      Rand.prob(e1) * Rand.prob(e2);\n    == { reveal ProbE1; Helper.Congruence(Rand.prob(e1), 0.5, x => x * Rand.prob(e2)); }\n      0.5 * Rand.prob(e2);\n    ==\n      Rand.prob(e2) / 2.0;\n    == { reveal Eq2; }\n      Rand.prob(iset s | aOf(s) == m / 2) / 2.0;\n    == { reveal Eq3; }\n      Rand.prob(iset s | Model.Sample(n / 2)(s).value == m / 2) / 2.0;\n    }\n  }\n"
    },
    {
        "benchmark_name": "vmc",
        "index": "77",
        "method_filepath": "./src/Distributions/Uniform/Model.dfy",
        "method_without_assertion_filename": "SampleTerminates_fix_77.dfy",
        "method_name": "SampleTerminates",
        "method_content": "  lemma SampleTerminates(n: nat)\n    requires n > 0\n    ensures\n      && Independence.IsIndep(Proposal(n))\n      && Quantifier.WithPosProb(Loops.ProposalIsAccepted(Proposal(n), Accept(n)))\n      && Loops.UntilTerminatesAlmostSurely(Proposal(n), Accept(n))\n  {\n    assert Independence.IsIndep(Proposal(n)) by {\n      UniformPowerOfTwo.Correctness.SampleIsIndep(2 * n);\n    }\n    var e := iset s | Loops.ProposalIsAccepted(Proposal(n), Accept(n))(s);\n    assert e in Rand.eventSpace by {\n      var ltN := iset m: nat | m < n;\n      var resultsLtN := Monad.ResultsWithValueIn(ltN);\n      assert e == Measures.PreImage(UniformPowerOfTwo.Model.Sample(2 * n), resultsLtN);\n      assert Measures.PreImage(UniformPowerOfTwo.Model.Sample(2 * n), resultsLtN) in Rand.eventSpace by {\n        assert Independence.IsIndep(UniformPowerOfTwo.Model.Sample(2 * n)) by {\n          UniformPowerOfTwo.Correctness.SampleIsIndep(2 * n);\n        }\n        assert Measures.IsMeasurable(Rand.eventSpace, Monad.natResultEventSpace, UniformPowerOfTwo.Model.Sample(2 * n)) by {\n          Independence.IsIndepImpliesMeasurableNat(UniformPowerOfTwo.Model.Sample(2 * n));\n        }\n        assert resultsLtN in Monad.natResultEventSpace by {\n          Monad.LiftInEventSpaceToResultEventSpace(ltN, Measures.natEventSpace);\n        }\n      }\n    }\n    assert Quantifier.WithPosProb(Loops.ProposalIsAccepted(Proposal(n), Accept(n))) by {\n      assert Rand.prob(e) > 0.0 by {\n        assert e == (iset s | UniformPowerOfTwo.Model.Sample(2 * n)(s).value < n);\n        assert n <= Helper.Power(2, Helper.Log2Floor(2 * n)) by {\n          Helper.NLtPower2Log2FloorOf2N(n);\n        }\n        calc {\n          Rand.prob(e);\n        == { UniformPowerOfTwo.Correctness.UnifCorrectness2Inequality(2 * n, n); }\n          n as real / (Helper.Power(2, Helper.Log2Floor(2 * n)) as real);\n        >\n          0.0;\n        }\n      }\n    }\n    assert Loops.UntilTerminatesAlmostSurely(Proposal(n), Accept(n)) by {\n      Loops.EnsureUntilTerminates(Proposal(n), Accept(n));\n    }\n  }\n",
        "method_without_assertion_content": "  lemma SampleTerminates(n: nat)\n    requires n > 0\n    ensures\n      && Independence.IsIndep(Proposal(n))\n      && Quantifier.WithPosProb(Loops.ProposalIsAccepted(Proposal(n), Accept(n)))\n      && Loops.UntilTerminatesAlmostSurely(Proposal(n), Accept(n))\n  {\n    assert Independence.IsIndep(Proposal(n)) by {\n      UniformPowerOfTwo.Correctness.SampleIsIndep(2 * n);\n    }\n    var e := iset s | Loops.ProposalIsAccepted(Proposal(n), Accept(n))(s);\n    assert e in Rand.eventSpace by {\n      var ltN := iset m: nat | m < n;\n      var resultsLtN := Monad.ResultsWithValueIn(ltN);\n            assert Measures.PreImage(UniformPowerOfTwo.Model.Sample(2 * n), resultsLtN) in Rand.eventSpace by {\n        assert Independence.IsIndep(UniformPowerOfTwo.Model.Sample(2 * n)) by {\n          UniformPowerOfTwo.Correctness.SampleIsIndep(2 * n);\n        }\n        assert Measures.IsMeasurable(Rand.eventSpace, Monad.natResultEventSpace, UniformPowerOfTwo.Model.Sample(2 * n)) by {\n          Independence.IsIndepImpliesMeasurableNat(UniformPowerOfTwo.Model.Sample(2 * n));\n        }\n        assert resultsLtN in Monad.natResultEventSpace by {\n          Monad.LiftInEventSpaceToResultEventSpace(ltN, Measures.natEventSpace);\n        }\n      }\n    }\n    assert Quantifier.WithPosProb(Loops.ProposalIsAccepted(Proposal(n), Accept(n))) by {\n      assert Rand.prob(e) > 0.0 by {\n        assert e == (iset s | UniformPowerOfTwo.Model.Sample(2 * n)(s).value < n);\n        assert n <= Helper.Power(2, Helper.Log2Floor(2 * n)) by {\n          Helper.NLtPower2Log2FloorOf2N(n);\n        }\n        calc {\n          Rand.prob(e);\n        == { UniformPowerOfTwo.Correctness.UnifCorrectness2Inequality(2 * n, n); }\n          n as real / (Helper.Power(2, Helper.Log2Floor(2 * n)) as real);\n        >\n          0.0;\n        }\n      }\n    }\n    assert Loops.UntilTerminatesAlmostSurely(Proposal(n), Accept(n)) by {\n      Loops.EnsureUntilTerminates(Proposal(n), Accept(n));\n    }\n  }\n"
    },
    {
        "benchmark_name": "vmc",
        "index": "78",
        "method_filepath": "./src/Distributions/Uniform/Model.dfy",
        "method_without_assertion_filename": "SampleTerminates_fix_78.dfy",
        "method_name": "SampleTerminates",
        "method_content": "  lemma SampleTerminates(n: nat)\n    requires n > 0\n    ensures\n      && Independence.IsIndep(Proposal(n))\n      && Quantifier.WithPosProb(Loops.ProposalIsAccepted(Proposal(n), Accept(n)))\n      && Loops.UntilTerminatesAlmostSurely(Proposal(n), Accept(n))\n  {\n    assert Independence.IsIndep(Proposal(n)) by {\n      UniformPowerOfTwo.Correctness.SampleIsIndep(2 * n);\n    }\n    var e := iset s | Loops.ProposalIsAccepted(Proposal(n), Accept(n))(s);\n    assert e in Rand.eventSpace by {\n      var ltN := iset m: nat | m < n;\n      var resultsLtN := Monad.ResultsWithValueIn(ltN);\n      assert e == Measures.PreImage(UniformPowerOfTwo.Model.Sample(2 * n), resultsLtN);\n      assert Measures.PreImage(UniformPowerOfTwo.Model.Sample(2 * n), resultsLtN) in Rand.eventSpace by {\n        assert Independence.IsIndep(UniformPowerOfTwo.Model.Sample(2 * n)) by {\n          UniformPowerOfTwo.Correctness.SampleIsIndep(2 * n);\n        }\n        assert Measures.IsMeasurable(Rand.eventSpace, Monad.natResultEventSpace, UniformPowerOfTwo.Model.Sample(2 * n)) by {\n          Independence.IsIndepImpliesMeasurableNat(UniformPowerOfTwo.Model.Sample(2 * n));\n        }\n        assert resultsLtN in Monad.natResultEventSpace by {\n          Monad.LiftInEventSpaceToResultEventSpace(ltN, Measures.natEventSpace);\n        }\n      }\n    }\n    assert Quantifier.WithPosProb(Loops.ProposalIsAccepted(Proposal(n), Accept(n))) by {\n      assert Rand.prob(e) > 0.0 by {\n        assert e == (iset s | UniformPowerOfTwo.Model.Sample(2 * n)(s).value < n);\n        assert n <= Helper.Power(2, Helper.Log2Floor(2 * n)) by {\n          Helper.NLtPower2Log2FloorOf2N(n);\n        }\n        calc {\n          Rand.prob(e);\n        == { UniformPowerOfTwo.Correctness.UnifCorrectness2Inequality(2 * n, n); }\n          n as real / (Helper.Power(2, Helper.Log2Floor(2 * n)) as real);\n        >\n          0.0;\n        }\n      }\n    }\n    assert Loops.UntilTerminatesAlmostSurely(Proposal(n), Accept(n)) by {\n      Loops.EnsureUntilTerminates(Proposal(n), Accept(n));\n    }\n  }\n",
        "method_without_assertion_content": "  lemma SampleTerminates(n: nat)\n    requires n > 0\n    ensures\n      && Independence.IsIndep(Proposal(n))\n      && Quantifier.WithPosProb(Loops.ProposalIsAccepted(Proposal(n), Accept(n)))\n      && Loops.UntilTerminatesAlmostSurely(Proposal(n), Accept(n))\n  {\n    assert Independence.IsIndep(Proposal(n)) by {\n      UniformPowerOfTwo.Correctness.SampleIsIndep(2 * n);\n    }\n    var e := iset s | Loops.ProposalIsAccepted(Proposal(n), Accept(n))(s);\n    assert e in Rand.eventSpace by {\n      var ltN := iset m: nat | m < n;\n      var resultsLtN := Monad.ResultsWithValueIn(ltN);\n      assert e == Measures.PreImage(UniformPowerOfTwo.Model.Sample(2 * n), resultsLtN);\n      assert Measures.PreImage(UniformPowerOfTwo.Model.Sample(2 * n), resultsLtN) in Rand.eventSpace by {\n        assert Independence.IsIndep(UniformPowerOfTwo.Model.Sample(2 * n)) by {\n          UniformPowerOfTwo.Correctness.SampleIsIndep(2 * n);\n        }\n        assert Measures.IsMeasurable(Rand.eventSpace, Monad.natResultEventSpace, UniformPowerOfTwo.Model.Sample(2 * n)) by {\n          Independence.IsIndepImpliesMeasurableNat(UniformPowerOfTwo.Model.Sample(2 * n));\n        }\n        assert resultsLtN in Monad.natResultEventSpace by {\n          Monad.LiftInEventSpaceToResultEventSpace(ltN, Measures.natEventSpace);\n        }\n      }\n    }\n    assert Quantifier.WithPosProb(Loops.ProposalIsAccepted(Proposal(n), Accept(n))) by {\n      assert Rand.prob(e) > 0.0 by {\n                assert n <= Helper.Power(2, Helper.Log2Floor(2 * n)) by {\n          Helper.NLtPower2Log2FloorOf2N(n);\n        }\n        calc {\n          Rand.prob(e);\n        == { UniformPowerOfTwo.Correctness.UnifCorrectness2Inequality(2 * n, n); }\n          n as real / (Helper.Power(2, Helper.Log2Floor(2 * n)) as real);\n        >\n          0.0;\n        }\n      }\n    }\n    assert Loops.UntilTerminatesAlmostSurely(Proposal(n), Accept(n)) by {\n      Loops.EnsureUntilTerminates(Proposal(n), Accept(n));\n    }\n  }\n"
    },
    {
        "benchmark_name": "vmc",
        "index": "86",
        "method_filepath": "./src/ProbabilisticProgramming/Monad.dfy",
        "method_without_assertion_filename": "LiftInEventSpaceToResultEventSpace_fix_86.dfy",
        "method_name": "LiftInEventSpaceToResultEventSpace",
        "method_content": "  lemma LiftInEventSpaceToResultEventSpace<A(!new)>(event: iset<A>, eventSpace: iset<iset<A>>)\n    requires event in eventSpace\n    ensures ResultsWithValueIn(event) in ResultEventSpace(eventSpace)\n  {\n    var results := ResultsWithValueIn(event);\n    assert Measures.IsSigmaAlgebra(Rand.eventSpace) by {\n      Rand.ProbIsProbabilityMeasure();\n    }\n    assert Values(results) == event by {\n      forall v: A ensures v in event <==> v in Values(results) {\n        var s: Rand.Bitstream :| true;\n        assert v in event <==> Result(v, s) in results;\n      }\n    }\n    assert Rests(results) in Rand.eventSpace by {\n      if v :| v in event {\n        assert Rests(results) == Measures.SampleSpace() by {\n          forall s: Rand.Bitstream ensures s in Rests(results) <==> s in Measures.SampleSpace() {\n            calc {\n              s in Rests(results);\n              Result(v, s) in results;\n              true;\n            }\n          }\n        }\n      } else {\n        assert Rests(results) == iset{};\n      }\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LiftInEventSpaceToResultEventSpace<A(!new)>(event: iset<A>, eventSpace: iset<iset<A>>)\n    requires event in eventSpace\n    ensures ResultsWithValueIn(event) in ResultEventSpace(eventSpace)\n  {\n    var results := ResultsWithValueIn(event);\n    assert Measures.IsSigmaAlgebra(Rand.eventSpace) by {\n      Rand.ProbIsProbabilityMeasure();\n    }\n    assert Values(results) == event by {\n      forall v: A ensures v in event <==> v in Values(results) {\n        var s: Rand.Bitstream :| true;\n              }\n    }\n    assert Rests(results) in Rand.eventSpace by {\n      if v :| v in event {\n        assert Rests(results) == Measures.SampleSpace() by {\n          forall s: Rand.Bitstream ensures s in Rests(results) <==> s in Measures.SampleSpace() {\n            calc {\n              s in Rests(results);\n              Result(v, s) in results;\n              true;\n            }\n          }\n        }\n      } else {\n        assert Rests(results) == iset{};\n      }\n    }\n  }\n"
    },
    {
        "benchmark_name": "vmc",
        "index": "87",
        "method_filepath": "./src/ProbabilisticProgramming/Monad.dfy",
        "method_without_assertion_filename": "LiftInEventSpaceToResultEventSpace_fix_87.dfy",
        "method_name": "LiftInEventSpaceToResultEventSpace",
        "method_content": "  lemma LiftInEventSpaceToResultEventSpace<A(!new)>(event: iset<A>, eventSpace: iset<iset<A>>)\n    requires event in eventSpace\n    ensures ResultsWithValueIn(event) in ResultEventSpace(eventSpace)\n  {\n    var results := ResultsWithValueIn(event);\n    assert Measures.IsSigmaAlgebra(Rand.eventSpace) by {\n      Rand.ProbIsProbabilityMeasure();\n    }\n    assert Values(results) == event by {\n      forall v: A ensures v in event <==> v in Values(results) {\n        var s: Rand.Bitstream :| true;\n        assert v in event <==> Result(v, s) in results;\n      }\n    }\n    assert Rests(results) in Rand.eventSpace by {\n      if v :| v in event {\n        assert Rests(results) == Measures.SampleSpace() by {\n          forall s: Rand.Bitstream ensures s in Rests(results) <==> s in Measures.SampleSpace() {\n            calc {\n              s in Rests(results);\n              Result(v, s) in results;\n              true;\n            }\n          }\n        }\n      } else {\n        assert Rests(results) == iset{};\n      }\n    }\n  }\n",
        "method_without_assertion_content": "  lemma LiftInEventSpaceToResultEventSpace<A(!new)>(event: iset<A>, eventSpace: iset<iset<A>>)\n    requires event in eventSpace\n    ensures ResultsWithValueIn(event) in ResultEventSpace(eventSpace)\n  {\n    var results := ResultsWithValueIn(event);\n    assert Measures.IsSigmaAlgebra(Rand.eventSpace) by {\n      Rand.ProbIsProbabilityMeasure();\n    }\n    assert Values(results) == event by {\n      forall v: A ensures v in event <==> v in Values(results) {\n        var s: Rand.Bitstream :| true;\n        assert v in event <==> Result(v, s) in results;\n      }\n    }\n    assert Rests(results) in Rand.eventSpace by {\n      if v :| v in event {\n        assert Rests(results) == Measures.SampleSpace() by {\n          forall s: Rand.Bitstream ensures s in Rests(results) <==> s in Measures.SampleSpace() {\n            calc {\n              s in Rests(results);\n              Result(v, s) in results;\n              true;\n            }\n          }\n        }\n      } else {\n              }\n    }\n  }\n"
    },
    {
        "benchmark_name": "vmc",
        "index": "89",
        "method_filepath": "./src/ProbabilisticProgramming/Loops.dfy",
        "method_without_assertion_filename": "WhileUnroll_fix_89.dfy",
        "method_name": "WhileUnroll",
        "method_content": "  lemma WhileUnrollIfConditionSatisfied<A>(condition: A -> bool, body: A -> Monad.Hurd<A>, init: A, s: Rand.Bitstream, init': A, s': Rand.Bitstream, loop: Monad.Result<A>, unrolled: Monad.Result<A>)\n    requires WhileCutTerminates(condition, body, init, s)\n    requires condition(init)\n    requires body(init)(s) == Monad.Result(init', s')\n    requires loop == While(condition, body)(init)(s)\n    requires unrolled == While(condition, body)(init')(s')\n    ensures loop == unrolled\n  {\n    var fuel: nat := LeastFuel(condition, body, init, s);\n    assert fuel >= 1;\n    var fuel': nat := fuel - 1;\n    assert WhileCutTerminatesWithFuel(condition, body, init', s')(fuel');\n    assert WhileCutTerminates(condition, body, init', s');\n    var minFuel: nat := LeastFuel(condition, body, init', s');\n    assert minFuel == fuel' by {\n      LeastFuelUnroll(condition, body, init, s, init', s', minFuel);\n    }\n    assert loop == unrolled by {\n      calc {\n        loop;\n        { reveal While(); }\n        WhileCut(condition, body, init, fuel)(s);\n        { WhileCutUnroll(condition, body, init, s, init', s', fuel'); }\n        WhileCut(condition, body, init', fuel')(s');\n        { reveal While(); }\n        unrolled;\n      }\n    }\n  }\n",
        "method_without_assertion_content": "  lemma WhileUnrollIfConditionSatisfied<A>(condition: A -> bool, body: A -> Monad.Hurd<A>, init: A, s: Rand.Bitstream, init': A, s': Rand.Bitstream, loop: Monad.Result<A>, unrolled: Monad.Result<A>)\n    requires WhileCutTerminates(condition, body, init, s)\n    requires condition(init)\n    requires body(init)(s) == Monad.Result(init', s')\n    requires loop == While(condition, body)(init)(s)\n    requires unrolled == While(condition, body)(init')(s')\n    ensures loop == unrolled\n  {\n    var fuel: nat := LeastFuel(condition, body, init, s);\n    assert fuel >= 1;\n    var fuel': nat := fuel - 1;\n        assert WhileCutTerminates(condition, body, init', s');\n    var minFuel: nat := LeastFuel(condition, body, init', s');\n    assert minFuel == fuel' by {\n      LeastFuelUnroll(condition, body, init, s, init', s', minFuel);\n    }\n    assert loop == unrolled by {\n      calc {\n        loop;\n        { reveal While(); }\n        WhileCut(condition, body, init, fuel)(s);\n        { WhileCutUnroll(condition, body, init, s, init', s', fuel'); }\n        WhileCut(condition, body, init', fuel')(s');\n        { reveal While(); }\n        unrolled;\n      }\n    }\n  }\n"
    },
    {
        "benchmark_name": "vmc",
        "index": "94",
        "method_filepath": "./src/ProbabilisticProgramming/Loops.dfy",
        "method_without_assertion_filename": "WhileUnrollIfConditionSatisfied_fix_94.dfy",
        "method_name": "WhileUnrollIfConditionSatisfied",
        "method_content": "  lemma WhileUnrollIfConditionSatisfied<A>(condition: A -> bool, body: A -> Monad.Hurd<A>, init: A, s: Rand.Bitstream, init': A, s': Rand.Bitstream, loop: Monad.Result<A>, unrolled: Monad.Result<A>)\n    requires WhileCutTerminates(condition, body, init, s)\n    requires condition(init)\n    requires body(init)(s) == Monad.Result(init', s')\n    requires loop == While(condition, body)(init)(s)\n    requires unrolled == While(condition, body)(init')(s')\n    ensures loop == unrolled\n  {\n    var fuel: nat := LeastFuel(condition, body, init, s);\n    assert fuel >= 1;\n    var fuel': nat := fuel - 1;\n    assert WhileCutTerminatesWithFuel(condition, body, init', s')(fuel');\n    assert WhileCutTerminates(condition, body, init', s');\n    var minFuel: nat := LeastFuel(condition, body, init', s');\n    assert minFuel == fuel' by {\n      LeastFuelUnroll(condition, body, init, s, init', s', minFuel);\n    }\n    assert loop == unrolled by {\n      calc {\n        loop;\n        { reveal While(); }\n        WhileCut(condition, body, init, fuel)(s);\n        { WhileCutUnroll(condition, body, init, s, init', s', fuel'); }\n        WhileCut(condition, body, init', fuel')(s');\n        { reveal While(); }\n        unrolled;\n      }\n    }\n  }\n",
        "method_without_assertion_content": "  lemma WhileUnrollIfConditionSatisfied<A>(condition: A -> bool, body: A -> Monad.Hurd<A>, init: A, s: Rand.Bitstream, init': A, s': Rand.Bitstream, loop: Monad.Result<A>, unrolled: Monad.Result<A>)\n    requires WhileCutTerminates(condition, body, init, s)\n    requires condition(init)\n    requires body(init)(s) == Monad.Result(init', s')\n    requires loop == While(condition, body)(init)(s)\n    requires unrolled == While(condition, body)(init')(s')\n    ensures loop == unrolled\n  {\n    var fuel: nat := LeastFuel(condition, body, init, s);\n    assert fuel >= 1;\n    var fuel': nat := fuel - 1;\n        assert WhileCutTerminates(condition, body, init', s');\n    var minFuel: nat := LeastFuel(condition, body, init', s');\n    assert minFuel == fuel' by {\n      LeastFuelUnroll(condition, body, init, s, init', s', minFuel);\n    }\n    assert loop == unrolled by {\n      calc {\n        loop;\n        { reveal While(); }\n        WhileCut(condition, body, init, fuel)(s);\n        { WhileCutUnroll(condition, body, init, s, init', s', fuel'); }\n        WhileCut(condition, body, init', fuel')(s');\n        { reveal While(); }\n        unrolled;\n      }\n    }\n  }\n"
    },
    {
        "benchmark_name": "vmc",
        "index": "98",
        "method_filepath": "./src/ProbabilisticProgramming/Loops.dfy",
        "method_without_assertion_filename": "EnsureUntilTerminates_fix_98.dfy",
        "method_name": "EnsureUntilTerminates",
        "method_content": "  lemma EnsureUntilTerminates<A(!new)>(proposal: Monad.Hurd<A>, accept: A -> bool)\n    requires Independence.IsIndep(proposal)\n    requires Quantifier.WithPosProb((s: Rand.Bitstream) => proposal(s).Satisfies(accept))\n    ensures UntilTerminatesAlmostSurely(proposal, accept)\n  {\n    var reject := (a: A) => !accept(a);\n    var body := (a: A) => proposal;\n    var proposalIsAccepted := (s: Rand.Bitstream) => proposal(s).Satisfies(accept);\n    assert UntilTerminatesAlmostSurely(proposal, accept) by {\n      forall a: A ensures Independence.IsIndep(body(a)) {\n        assert body(a) == proposal;\n      }\n      forall a: A ensures Quantifier.WithPosProb(WhileLoopExitsAfterOneIteration(body, reject, a)) {\n        assert Quantifier.WithPosProb(proposalIsAccepted);\n        assert (iset s | proposalIsAccepted(s)) == (iset s | WhileLoopExitsAfterOneIteration(body, reject, a)(s));\n      }\n      assert WhileTerminatesAlmostSurely(reject, body) by {\n        EnsureWhileTerminates(reject, body);\n      }\n    }\n  }\n",
        "method_without_assertion_content": "  lemma EnsureUntilTerminates<A(!new)>(proposal: Monad.Hurd<A>, accept: A -> bool)\n    requires Independence.IsIndep(proposal)\n    requires Quantifier.WithPosProb((s: Rand.Bitstream) => proposal(s).Satisfies(accept))\n    ensures UntilTerminatesAlmostSurely(proposal, accept)\n  {\n    var reject := (a: A) => !accept(a);\n    var body := (a: A) => proposal;\n    var proposalIsAccepted := (s: Rand.Bitstream) => proposal(s).Satisfies(accept);\n    assert UntilTerminatesAlmostSurely(proposal, accept) by {\n      forall a: A ensures Independence.IsIndep(body(a)) {\n        assert body(a) == proposal;\n      }\n      forall a: A ensures Quantifier.WithPosProb(WhileLoopExitsAfterOneIteration(body, reject, a)) {\n        assert Quantifier.WithPosProb(proposalIsAccepted);\n              }\n      assert WhileTerminatesAlmostSurely(reject, body) by {\n        EnsureWhileTerminates(reject, body);\n      }\n    }\n  }\n"
    }
]